"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dataVis/page",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"7b083d5e4e40\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjdiMDgzZDVlNGU0MFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js":
/*!******************************************!*\
  !*** ./src/app/dataVis/TrendAnaIndex.js ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrendAnaTime */ \"(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__]);\n_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\n\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return; // 🔥 Ensure solves is valid\n            if (containerRef.current) {\n                drawSolveTimeTrend(solves);\n                window.addEventListener('resize', handleResize);\n            }\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]);\n    function handleResize() {\n        if (containerRef.current) {\n            drawSolveTimeTrend(solves);\n        }\n    }\n    function computeRollingAverage(data, windowSize) {\n        const rollingAvg = data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null;\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n        console.log(\"Window Size: \".concat(windowSize));\n        console.log(\"Original Data Length: \".concat(data.length));\n        console.log(\"Rolling Average (\".concat(windowSize, \") Length: \").concat(rollingAvg.length));\n        console.log(\"First Values:\", rollingAvg.slice(0, 15)); // Check first few values\n        console.log(\"Last Values:\", rollingAvg.slice(-15)); // Check last few values\n        return rollingAvg;\n    }\n    function drawSolveTimeTrend(data) {\n        if (!containerRef.current) return;\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        const times = data.map((solve)=>solve.time / 1000);\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        let xScale = d3.scaleLinear().domain([\n            0,\n            times.length - 1\n        ]).range([\n            50,\n            width - 50\n        ]);\n        let yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]) // Flip domain to match SVG coords\n        .range([\n            50,\n            height - 50\n        ]); // Ensure bottom is lower on the screen\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale));\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom().scaleExtent([\n            0.5,\n            5\n        ]).translateExtent([\n            [\n                0,\n                0\n            ],\n            [\n                width,\n                height\n            ]\n        ]).on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale));\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // ✅ Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 80)\")); // ⬇ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        function autoscale(event) {\n            event.preventDefault(); // Stop default zoom behavior\n            event.stopPropagation(); // Prevent further event propagation\n            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity); // Reset to original zoom state\n        }\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"🔄 Updating Plot with New Scales:\");\n            console.log(\"🟢 New X Scale Domain:\", newXScale.domain());\n            console.log(\"🟢 New Y Scale Domain:\", newYScale.domain());\n            // ✅ Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            console.log(\"✔ Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"✔ Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"⚠️ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"⚠️ No AO12 points found in updatePlot!\");\n            // ✅ Update all AO5 points\n            ao5Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // ✅ Update all AO12 points\n            ao12Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // ✅ Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // ✅ Update single solve points\n            svg.selectAll('.point-single').attr('cx', (_, i)=>newXScale(i)).attr('cy', (_, i)=>newYScale(times[i]));\n            // ✅ Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(times[i])));\n            // ✅ Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao5[i])));\n            // ✅ Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao12[i])));\n        }\n        svg.append('path').datum(times).attr('class', 'line line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao5).attr('class', 'line line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao12).attr('class', 'line line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2);\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, i) {\n            var _times_i, _ao5_i, _ao12_i;\n            const singleTime = (_times_i = times[i]) === null || _times_i === void 0 ? void 0 : _times_i.toFixed(2);\n            const ao5Time = ao5[i] !== null ? (_ao5_i = ao5[i]) === null || _ao5_i === void 0 ? void 0 : _ao5_i.toFixed(2) : '-';\n            const ao12Time = ao12[i] !== null ? (_ao12_i = ao12[i]) === null || _ao12_i === void 0 ? void 0 : _ao12_i.toFixed(2) : '-';\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // ✅ Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // ✅ Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // ✅ Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"✔ Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color).on('mouseover', (event, d)=>showTooltip(event, d.x)).on('mouseout', hideTooltip);\n        }\n        // ✅ Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n        const controls = d3.select(containerRef.current).append('div').attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow');\n        controls.append('button').text('Autoscale').style('margin-right', '5px').on('click', autoscale);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaIndex.js\",\n        lineNumber: 351,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYUluZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFMEM7QUFDMUMsTUFBTUUsS0FBSyxNQUFNLDRNQUFZO0FBQ2E7QUFFM0IsU0FBU0UsZUFBZSxLQUFVO1FBQVYsRUFBRUMsTUFBTSxFQUFFLEdBQVY7O0lBQ25DLE1BQU1DLGVBQWVMLDZDQUFNQSxDQUFDO0lBRTVCRCxnREFBU0E7b0NBQUM7WUFDTixJQUFJLENBQUNLLFVBQVUsQ0FBQ0UsTUFBTUMsT0FBTyxDQUFDSCxXQUFXQSxPQUFPSSxNQUFNLEtBQUssR0FBRyxRQUFRLDRCQUE0QjtZQUNsRyxJQUFJSCxhQUFhSSxPQUFPLEVBQUU7Z0JBQ3RCQyxtQkFBbUJOO2dCQUNuQk8sT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUM7WUFDdEM7WUFFQTs0Q0FBTyxJQUFNRixPQUFPRyxtQkFBbUIsQ0FBQyxVQUFVRDs7UUFDdEQ7bUNBQUc7UUFBQ1Q7S0FBTztJQUVYLFNBQVNTO1FBQ0wsSUFBSVIsYUFBYUksT0FBTyxFQUFFO1lBQ3RCQyxtQkFBbUJOO1FBQ3ZCO0lBQ0o7SUFFQSxTQUFTVyxzQkFBc0JDLElBQUksRUFBRUMsVUFBVTtRQUMzQyxNQUFNQyxhQUFhRixLQUFLRyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0MsR0FBR0M7WUFDL0IsSUFBSUQsSUFBSUosYUFBYSxHQUFHLE9BQU87WUFDL0IsTUFBTU0sU0FBU0QsSUFBSUUsS0FBSyxDQUFDSCxJQUFLSixDQUFBQSxhQUFhLElBQUlJLElBQUk7WUFDbkQsT0FBT0UsT0FBT0UsTUFBTSxDQUFDLENBQUNDLEtBQUtDLE1BQVFELE1BQU1DLEtBQUssS0FBS0osT0FBT2YsTUFBTTtRQUNwRTtRQUVBb0IsUUFBUUMsR0FBRyxDQUFDLGdCQUEyQixPQUFYWjtRQUM1QlcsUUFBUUMsR0FBRyxDQUFDLHlCQUFxQyxPQUFaYixLQUFLUixNQUFNO1FBQ2hEb0IsUUFBUUMsR0FBRyxD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QyxVQUFVLHdCQUF3QjthQUN2QzlFLElBQUksQ0FBQyxTQUFTLFNBQW1CLE9BQVZ3RSxZQUN2QnhFLElBQUksQ0FBQyxNQUFNc0IsQ0FBQUEsSUFBS2hCLE9BQU9nQixFQUFFMEIsQ0FBQyxHQUMxQmhELElBQUksQ0FBQyxNQUFNc0IsQ0FBQUEsSUFBS1osT0FBT1ksRUFBRTJCLENBQUMsR0FDMUJqRCxJQUFJLENBQUMsS0FBSyxHQUNWQSxJQUFJLENBQUMsUUFBUW9DLE9BQ2JWLEVBQUUsQ0FBQyxhQUFhLENBQUNDLE9BQU9MLElBQU11QyxZQUFZbEMsT0FBT0wsRUFBRTBCLENBQUMsR0FDcER0QixFQUFFLENBQUMsWUFBWTJDO1FBQ3hCO1FBRVIsNkRBQTZEO1FBQ3JERSxVQUFVdEUsT0FBTyxRQUFRLGdCQUFnQixDQUFDcEIsSUFBTW9CLEtBQUssQ0FBQ3BCLEVBQUUsRUFBRSxHQUFHO1FBQzdEMEYsVUFBVW5FLEtBQUssU0FBUyxhQUFhLENBQUN2QixJQUFNdUIsR0FBRyxDQUFDdkIsRUFBRSxFQUFFLEdBQUc7UUFDdkQwRixVQUFVbEUsTUFBTSxPQUFPLGNBQWMsQ0FBQ3hCLElBQU13QixJQUFJLENBQUN4QixFQUFFLEVBQUUsSUFBSTtRQUV6RCxNQUFNa0csV0FBV3RILEdBQUc4QixNQUFNLENBQUMxQixhQUFhSSxPQUFPLEVBQUU4QixNQUFNLENBQUMsT0FDbkRDLElBQUksQ0FBQyxTQUFTO1FBRW5CK0UsU0FBU2hGLE1BQU0sQ0FBQyxVQUNYeUMsSUFBSSxDQUFDLGFBQ0xvQixLQUFLLENBQUMsZ0JBQWdCLE9BQ3RCbEMsRUFBRSxDQUFDLFNBQVNlO0lBQ3JCO0lBRUEscUJBQ0ksOERBQUN1QztRQUNHQyxLQUFLcEg7UUFDTDJHLFdBQVU7Ozs7OztBQUd0QjtHQTdWd0I3RztLQUFBQSIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxTclxcMjAyNF9DX1Rlcm1cXENTNDI0MVxcSFdcXGZpbmFsLXByb2plY3Qta2VybWl0LXRoZS1mcm9nXFxzcmNcXGFwcFxcZGF0YVZpc1xcVHJlbmRBbmFJbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuY29uc3QgZDMgPSBhd2FpdCBpbXBvcnQoJ2QzJyk7XHJcbmltcG9ydCBUcmVuZEFuYVRpbWUgZnJvbSAnLi9UcmVuZEFuYVRpbWUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU29sdmVUaW1lVHJlbmQoeyBzb2x2ZXMgfSkge1xyXG4gICAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzb2x2ZXMgfHwgIUFycmF5LmlzQXJyYXkoc29sdmVzKSB8fCBzb2x2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIPCflKUgRW5zdXJlIHNvbHZlcyBpcyB2YWxpZFxyXG4gICAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBkcmF3U29sdmVUaW1lVHJlbmQoc29sdmVzKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICB9LCBbc29sdmVzXSk7XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBkcmF3U29sdmVUaW1lVHJlbmQoc29sdmVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKGRhdGEsIHdpbmRvd1NpemUpIHtcclxuICAgICAgICBjb25zdCByb2xsaW5nQXZnID0gZGF0YS5tYXAoKF8sIGksIGFycikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaSA8IHdpbmRvd1NpemUgLSAxKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgY29uc3Qgc3Vic2V0ID0gYXJyLnNsaWNlKGkgLSAod2luZG93U2l6ZSAtIDEpLCBpICsgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdWJzZXQucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSAvIHN1YnNldC5sZW5ndGg7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBXaW5kb3cgU2l6ZTogJHt3aW5kb3dTaXplfWApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBPcmlnaW5hbCBEYXRhIExlbmd0aDogJHtkYXRhLmxlbmd0aH1gKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgUm9sbGluZyBBdmVyYWdlICgke3dpbmRvd1NpemV9KSBMZW5ndGg6ICR7cm9sbGluZ0F2Zy5sZW5ndGh9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEZpcnN0IFZhbHVlczpgLCByb2xsaW5nQXZnLnNsaWNlKDAsIDE1KSk7IC8vIENoZWNrIGZpcnN0IGZldyB2YWx1ZXNcclxuICAgICAgICBjb25zb2xlLmxvZyhgTGFzdCBWYWx1ZXM6YCwgcm9sbGluZ0F2Zy5zbGljZSgtMTUpKTsgLy8gQ2hlY2sgbGFzdCBmZXcgdmFsdWVzXHJcblxyXG4gICAgICAgIHJldHVybiByb2xsaW5nQXZnO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdTb2x2ZVRpbWVUcmVuZChkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0IHx8IDUwMDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gY29udGFpbmVyLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzEwMCUnKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgJzEwMCUnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlld0JveCcsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YClcclxuICAgICAgICAgICAgLmF0dHIoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xyXG5cclxuICAgICAgICBjb25zdCB0aW1lcyA9IGRhdGEubWFwKChzb2x2ZSkgPT4gc29sdmUudGltZSAvIDEwMDApO1xyXG4gICAgICAgIGNvbnN0IGFvNSA9IGNvbXB1dGVSb2xsaW5nQXZlcmFnZSh0aW1lcywgNSk7XHJcbiAgICAgICAgY29uc3QgYW8xMiA9IGNvbXB1dGVSb2xsaW5nQXZlcmFnZSh0aW1lcywgMTIpO1xyXG5cclxuICAgICAgICBsZXQgeFNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFswLCB0aW1lcy5sZW5ndGggLSAxXSlcclxuICAgICAgICAgICAgLnJhbmdlKFs1MCwgd2lkdGggLSA1MF0pO1xyXG5cclxuICAgICAgICBsZXQgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFtkMy5tYXgodGltZXMpLCBkMy5taW4odGltZXMpXSkgIC8vIEZsaXAgZG9tYWluIHRvIG1hdGNoIFNWRyBjb29yZHNcclxuICAgICAgICAgICAgLnJhbmdlKFs1MCwgaGVpZ2h0IC0gNTBdKTsgLy8gRW5zdXJlIGJvdHRvbSBpcyBsb3dlciBvbiB0aGUgc2NyZWVuXHJcblxyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd4LWF4aXMnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke2hlaWdodCAtIDUwfSlgKVxyXG4gICAgICAgICAgICAuY2FsbChkMy5heGlzQm90dG9tKHhTY2FsZSkpO1xyXG5cclxuICAgICAgICBjb25zdCB5QXhpcyA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneS1heGlzJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoNTAsIDApYClcclxuICAgICAgICAgICAgLmNhbGwoZDMuYXhpc0xlZnQoeVNjYWxlKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGdyaWRHcm91cCA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdncmlkJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdHcmlkKHhTY2FsZSwgeVNjYWxlKSB7XHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgZ3JpZCBsaW5lc1xyXG4gICAgICAgICAgICBncmlkR3JvdXAuc2VsZWN0QWxsKCcuaG9yaXpvbnRhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHlTY2FsZS50aWNrcygxMCkpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaG9yaXpvbnRhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGggLSA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGQgPT4geVNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgZCA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAnNCw0Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJ0aWNhbCBncmlkIGxpbmVzXHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJy52ZXJ0aWNhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHhTY2FsZS50aWNrcygxMCkpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndmVydGljYWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBkID0+IHhTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGQgPT4geFNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBoZWlnaHQgLSA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICc0LDQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRyYXdHcmlkKHhTY2FsZSwgeVNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgem9vbSA9IGQzLnpvb20oKVxyXG4gICAgICAgICAgICAuc2NhbGVFeHRlbnQoWzAuNSwgNV0pXHJcbiAgICAgICAgICAgIC50cmFuc2xhdGVFeHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcclxuICAgICAgICAgICAgLm9uKCd6b29tJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdYU2NhbGUgPSB0cmFuc2Zvcm0ucmVzY2FsZVgoeFNjYWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1lTY2FsZSA9IHRyYW5zZm9ybS5yZXNjYWxlWSh5U2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgcGxvdHNcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVBsb3QobmV3WFNjYWxlLCBuZXdZU2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBheGVzXHJcbiAgICAgICAgICAgICAgICB4QXhpcy5jYWxsKGQzLmF4aXNCb3R0b20obmV3WFNjYWxlKSk7XHJcbiAgICAgICAgICAgICAgICB5QXhpcy5jYWxsKGQzLmF4aXNMZWZ0KG5ld1lTY2FsZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBncmlkIHdpdGggbmV3IHNjYWxlc1xyXG4gICAgICAgICAgICAgICAgZHJhd0dyaWQobmV3WFNjYWxlLCBuZXdZU2NhbGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc3ZnLmNhbGwoem9vbSk7XHJcblxyXG4gICAgICAgIC8vIOKchSBBZGQgTGVnZW5kcyAoQmVsb3cgQXV0b3NjYWxlIEJ1dHRvbilcclxuICAgICAgICBjb25zdCBsZWdlbmQgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt3aWR0aCAtIDEyMH0sIDgwKWApOyAvLyDirIcgTW92ZXMgbGVnZW5kIGxvd2VyIHVuZGVyIGJ1dHRvblxyXG5cclxuICAgICAgICBjb25zdCBsZWdlbmRJdGVtcyA9IFtcclxuICAgICAgICAgICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ1NpbmdsZScgfSxcclxuICAgICAgICAgICAgeyBjb2xvcjogJ2dyZWVuJywgbGFiZWw6ICdBTzUnIH0sXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdyZWQnLCBsYWJlbDogJ0FPMTInIH1cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBsZWdlbmRJdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBpICogMjApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgaXRlbS5jb2xvcik7XHJcblxyXG4gICAgICAgICAgICBsZWdlbmQuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMjApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGkgKiAyMCArIDEyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgICAgICAgICAgICAgIC50ZXh0KGl0ZW0ubGFiZWwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhdXRvc2NhbGUoZXZlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gU3RvcCBkZWZhdWx0IHpvb20gYmVoYXZpb3JcclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFByZXZlbnQgZnVydGhlciBldmVudCBwcm9wYWdhdGlvblxyXG5cclxuICAgICAgICAgICAgc3ZnLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcclxuICAgICAgICAgICAgICAgIC5jYWxsKHpvb20udHJhbnNmb3JtLCBkMy56b29tSWRlbnRpdHkpOyAvLyBSZXNldCB0byBvcmlnaW5hbCB6b29tIHN0YXRlXHJcbiAgICAgICAgfVxyXG5cclxuLy8gRW5zdXJlIGV2ZW50IGlzIHBhc3NlZCB0byBhdXRvc2NhbGVcclxuICAgICAgICBzdmcub24oJ2RibGNsaWNrJywgKGV2ZW50KSA9PiBhdXRvc2NhbGUoZXZlbnQpKTtcclxuXHJcbi8vIEFsc28gZXhwbGljaXRseSBkaXNhYmxlIHpvb20gb24gZG91YmxlLWNsaWNrIHRvIHByZXZlbnQgem9vbWluZyBpblxyXG4gICAgICAgIHN2Zy5jYWxsKHpvb20pLm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUGxvdChuZXdYU2NhbGUsIG5ld1lTY2FsZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflIQgVXBkYXRpbmcgUGxvdCB3aXRoIE5ldyBTY2FsZXM6XCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfn6IgTmV3IFggU2NhbGUgRG9tYWluOlwiLCBuZXdYU2NhbGUuZG9tYWluKCkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfn6IgTmV3IFkgU2NhbGUgRG9tYWluOlwiLCBuZXdZU2NhbGUuZG9tYWluKCkpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSB0aGF0IHRoZSBBTzUgYW5kIEFPMTIgcG9pbnRzIGFyZSBjb3JyZWN0bHkgYm91bmRcclxuICAgICAgICAgICAgY29uc3QgYW81U2VsZWN0aW9uID0gc3ZnLnNlbGVjdEFsbCgnLnBvaW50LWFvNScpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShhbzUubWFwKCh2YWwsIGkpID0+ICh7IHg6IGksIHk6IHZhbCB9KSksIGQgPT4gZC54KTsgLy8gRW5zdXJlIHVuaXF1ZSBrZXkgYmluZGluZ1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYW8xMlNlbGVjdGlvbiA9IHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1hbzEyJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGFvMTIubWFwKCh2YWwsIGkpID0+ICh7IHg6IGksIHk6IHZhbCB9KSksIGQgPT4gZC54KTsgLy8gRW5zdXJlIHVuaXF1ZSBrZXkgYmluZGluZ1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBUb3RhbCBBTzUgUG9pbnRzIFNlbGVjdGVkOiAke2FvNVNlbGVjdGlvbi5zaXplKCl9IChFeHBlY3RlZDogJHthbzUubGVuZ3RofSlgKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBUb3RhbCBBTzEyIFBvaW50cyBTZWxlY3RlZDogJHthbzEyU2VsZWN0aW9uLnNpemUoKX0gKEV4cGVjdGVkOiAke2FvMTIubGVuZ3RofSlgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbzVTZWxlY3Rpb24uc2l6ZSgpID09PSAwKSBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gQU81IHBvaW50cyBmb3VuZCBpbiB1cGRhdGVQbG90IVwiKTtcclxuICAgICAgICAgICAgaWYgKGFvMTJTZWxlY3Rpb24uc2l6ZSgpID09PSAwKSBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gQU8xMiBwb2ludHMgZm91bmQgaW4gdXBkYXRlUGxvdCFcIik7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIGFsbCBBTzUgcG9pbnRzXHJcbiAgICAgICAgICAgIGFvNVNlbGVjdGlvbi5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKGQueCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgYWxsIEFPMTIgcG9pbnRzXHJcbiAgICAgICAgICAgIGFvMTJTZWxlY3Rpb24uYXR0cignY3gnLCBkID0+IG5ld1hTY2FsZShkLngpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBuZXdZU2NhbGUoZC55KSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRGVidWdnaW5nOiBFbnN1cmUgbGFzdCBBTzUgJiBBTzEyIHBvaW50cyB1cGRhdGUgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGFvNVNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhbzUubGVuZ3RoIC0gNCkgeyAvLyBVc2UgYGFvNS5sZW5ndGhgIHRvIGNvcnJlY3RseSBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfn6IgQU81IFBvaW50ICR7aX06IHg9JHtuZXdYU2NhbGUoZC54KX0sIHk9JHtuZXdZU2NhbGUoZC55KX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBhbzEyU2VsZWN0aW9uLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGFvMTIubGVuZ3RoIC0gMTIpIHsgLy8gVXNlIGBhbzEyLmxlbmd0aGAgdG8gY29ycmVjdGx5IGl0ZXJhdGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtCBBTzEyIFBvaW50ICR7aX06IHg9JHtuZXdYU2NhbGUoZC54KX0sIHk9JHtuZXdZU2NhbGUoZC55KX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIHNpbmdsZSBzb2x2ZSBwb2ludHNcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLnBvaW50LXNpbmdsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCAoXywgaSkgPT4gbmV3WFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgKF8sIGkpID0+IG5ld1lTY2FsZSh0aW1lc1tpXSkpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBzaW5nbGUgc29sdmUgbGluZVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1zaW5nbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoKF8sIGkpID0+IG5ld1hTY2FsZShpKSlcclxuICAgICAgICAgICAgICAgICAgICAueSgoXywgaSkgPT4gbmV3WVNjYWxlKHRpbWVzW2ldKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIEFPNSBsaW5lIGFsaWducyBkeW5hbWljYWxseVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1hbzUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoKF8sIGkpID0+IGkgPj0gNCAmJiBhbzVbaV0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoKF8sIGkpID0+IG5ld1hTY2FsZShpKSlcclxuICAgICAgICAgICAgICAgICAgICAueSgoXywgaSkgPT4gbmV3WVNjYWxlKGFvNVtpXSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSBBTzEyIGxpbmUgYWxpZ25zIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoKF8sIGkpID0+IGkgPj0gMTEgJiYgYW8xMltpXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAueCgoXywgaSkgPT4gbmV3WFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiBuZXdZU2NhbGUoYW8xMltpXSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXR1bSh0aW1lcylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUgbGluZS1zaW5nbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsdWUnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKGFvNSlcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUgbGluZS1hbzUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2dyZWVuJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXR1bShhbzEyKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZSBsaW5lLWFvMTInKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ3JlZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Fic29sdXRlIGJnLXdoaXRlIHAtMiBib3JkZXIgcm91bmRlZCBzaGFkb3cgdGV4dC1zbScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKGV2ZW50LCBpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVRpbWUgPSB0aW1lc1tpXT8udG9GaXhlZCgyKTtcclxuICAgICAgICAgICAgY29uc3QgYW81VGltZSA9IGFvNVtpXSAhPT0gbnVsbCA/IGFvNVtpXT8udG9GaXhlZCgyKSA6ICctJztcclxuICAgICAgICAgICAgY29uc3QgYW8xMlRpbWUgPSBhbzEyW2ldICE9PSBudWxsID8gYW8xMltpXT8udG9GaXhlZCgyKSA6ICctJztcclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuaHRtbChgXHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+U2luZ2xlOjwvc3Ryb25nPiAke3NpbmdsZVRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPkFPNTo8L3N0cm9uZz4gJHthbzVUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5BTzEyOjwvc3Ryb25nPiAke2FvMTJUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgYClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnZml4ZWQnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgJ3doaXRlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncGFkZGluZycsICc2cHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXInLCAnMXB4IHNvbGlkICNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXItcmFkaXVzJywgJzVweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JveC1zaGFkb3cnLCAnMnB4IDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3otaW5kZXgnLCAnMTAwMCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgLTUwJSknKTtcclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ2xlZnQnLCBgJHtldmVudC5wYWdlWCArIDEyfXB4YCkuc3R5bGUoJ3RvcCcsIGAke2V2ZW50LnBhZ2VZfXB4YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcclxuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB1cGRhdGVQbG90KHhTY2FsZSwgeVNjYWxlKTsgIC8vIOKchSBGb3JjZSByZW5kZXIgYWZ0ZXIgaW5pdGlhbGl6YXRpb25cclxuICAgICAgICB9LCAxMDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRQb2ludHMoZGF0YSwgY29sb3IsIGNsYXNzTmFtZSwgdmFsdWVBY2Nlc3NvciwgbWluSW5kZXgsIGxhYmVsKSB7XHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgdGhhdCB3ZSBjb3JyZWN0bHkgaXRlcmF0ZSBvdmVyIHRoZSBmdWxsIGRhdGFzZXRcclxuICAgICAgICAgICAgY29uc3QgdmFsaWRQb2ludHMgPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAubWFwKCh2YWwsIGkpID0+ICh7IHg6IGksIHk6IHZhbHVlQWNjZXNzb3IoaSkgfSkpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGQgPT4gZC55ICE9PSBudWxsICYmIGQueCA+PSBtaW5JbmRleCk7IC8vIOKchSBSZW1vdmVkIHggPCB0aW1lcy5sZW5ndGggY29uc3RyYWludFxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfn6IgQWRkaW5nIFBvaW50cyBmb3IgJHtsYWJlbH0gfCBDbGFzczogJHtjbGFzc05hbWV9IHwgTWluSW5kZXg6ICR7bWluSW5kZXh9YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJQgVmFsaWQgUG9pbnRzIENvdW50OiAke3ZhbGlkUG9pbnRzLmxlbmd0aH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk40gRmlyc3QgNSBQb2ludHM6YCwgdmFsaWRQb2ludHMuc2xpY2UoMCwgNSkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjSBMYXN0IDUgUG9pbnRzOmAsIHZhbGlkUG9pbnRzLnNsaWNlKC01KSk7XHJcblxyXG4gICAgICAgICAgICB2YWxpZFBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICAgICAgYPCflLUgJHtsYWJlbH0gUG9pbnQgJHtpICsgbWluSW5kZXh9OiBSYXdYPSR7cG9pbnQueH0sIFNjYWxlZFg9JHt4U2NhbGUocG9pbnQueCl9LCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUmF3WT0ke3BvaW50LnkudG9GaXhlZCgzKX0sIFNjYWxlZFk9JHt5U2NhbGUocG9pbnQueSkudG9GaXhlZCgyKX1gXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSBkYXRhIGJpbmRpbmcgaXMgZG9uZSBjb3JyZWN0bHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbChgLiR7Y2xhc3NOYW1lfWApXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh2YWxpZFBvaW50cywgZCA9PiBkLngpIC8vIEVuc3VyZSB1bmlxdWUga2V5IGJpbmRpbmdcclxuICAgICAgICAgICAgICAgIC5qb2luKFwiY2lyY2xlXCIpIC8vIEVuc3VyZSBwcm9wZXIgYmluZGluZ1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYHBvaW50ICR7Y2xhc3NOYW1lfWApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IHhTY2FsZShkLngpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC55KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY29sb3IpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIChldmVudCwgZCkgPT4gc2hvd1Rvb2x0aXAoZXZlbnQsIGQueCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgaGlkZVRvb2x0aXApO1xyXG4gICAgICAgIH1cclxuXHJcbi8vIOKchSBFbnN1cmUgQU81ICYgQU8xMiBwb2ludHMgYXJlIGZ1bGx5IGFkZGVkIGJlZm9yZSB1cGRhdGluZ1xyXG4gICAgICAgIGFkZFBvaW50cyh0aW1lcywgJ2JsdWUnLCAncG9pbnQtc2luZ2xlJywgKGkpID0+IHRpbWVzW2ldLCAwLCBcIlNpbmdsZVwiKTtcclxuICAgICAgICBhZGRQb2ludHMoYW81LCAnZ3JlZW4nLCAncG9pbnQtYW81JywgKGkpID0+IGFvNVtpXSwgNCwgXCJBTzVcIik7XHJcbiAgICAgICAgYWRkUG9pbnRzKGFvMTIsICdyZWQnLCAncG9pbnQtYW8xMicsIChpKSA9PiBhbzEyW2ldLCAxMSwgXCJBTzEyXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBjb250cm9scyA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCkuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYWJzb2x1dGUgdG9wLTIgcmlnaHQtMiBiZy13aGl0ZSBwLTIgcm91bmRlZCBzaGFkb3cnKTtcclxuXHJcbiAgICAgICAgY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgICAgICAudGV4dCgnQXV0b3NjYWxlJylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tcmlnaHQnLCAnNXB4JylcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGF1dG9zY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHJlZj17Y29udGFpbmVyUmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3LXNjcmVlbiBoLVtjYWxjKDEwMHZoLTEwMHB4KV0gYmctd2hpdGUgcmVsYXRpdmVcIlxyXG4gICAgICAgID48L2Rpdj5cclxuICAgICk7XHJcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiZDMiLCJUcmVuZEFuYVRpbWUiLCJTb2x2ZVRpbWVUcmVuZCIsInNvbHZlcyIsImNvbnRhaW5lclJlZiIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImN1cnJlbnQiLCJkcmF3U29sdmVUaW1lVHJlbmQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlUmVzaXplIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbXB1dGVSb2xsaW5nQXZlcmFnZSIsImRhdGEiLCJ3aW5kb3dTaXplIiwicm9sbGluZ0F2ZyIsIm1hcCIsIl8iLCJpIiwiYXJyIiwic3Vic2V0Iiwic2xpY2UiLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJjb25zb2xlIiwibG9nIiwiY29udGFpbmVyIiwic2VsZWN0Iiwic2VsZWN0QWxsIiwicmVtb3ZlIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsInN2ZyIsImFwcGVuZCIsImF0dHIiLCJ0aW1lcyIsInNvbHZlIiwidGltZSIsImFvNSIsImFvMTIiLCJ4U2NhbGUiLCJzY2FsZUxpbmVhciIsImRvbWFpbiIsInJhbmdlIiwieVNjYWxlIiwibWF4IiwibWluIiwieEF4aXMiLCJjYWxsIiwiYXhpc0JvdHRvbSIsInlBeGlzIiwiYXhpc0xlZnQiLCJncmlkR3JvdXAiLCJkcmF3R3JpZCIsInRpY2tzIiwiZW50ZXIiLCJkIiwiem9vbSIsInNjYWxlRXh0ZW50IiwidHJhbnNsYXRlRXh0ZW50Iiwib24iLCJldmVudCIsInRyYW5zZm9ybSIsIm5ld1hTY2FsZSIsInJlc2NhbGVYIiwibmV3WVNjYWxlIiwicmVzY2FsZVkiLCJ1cGRhdGVQbG90IiwibGVnZW5kIiwibGVnZW5kSXRlbXMiLCJjb2xvciIsImxhYmVsIiwiZm9yRWFjaCIsIml0ZW0iLCJ0ZXh0IiwiYXV0b3NjYWxlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJ0cmFuc2l0aW9uIiwiZHVyYXRpb24iLCJ6b29tSWRlbnRpdHkiLCJhbzVTZWxlY3Rpb24iLCJ4IiwieSIsImFvMTJTZWxlY3Rpb24iLCJzaXplIiwid2FybiIsImVhY2giLCJsaW5lIiwiY3VydmUiLCJjdXJ2ZU1vbm90b25lWCIsImRlZmluZWQiLCJkYXR1bSIsInRvb2x0aXAiLCJzdHlsZSIsInNob3dUb29sdGlwIiwic2luZ2xlVGltZSIsInRvRml4ZWQiLCJhbzVUaW1lIiwiYW8xMlRpbWUiLCJodG1sIiwicGFnZVgiLCJwYWdlWSIsImhpZGVUb29sdGlwIiwic2V0VGltZW91dCIsImFkZFBvaW50cyIsImNsYXNzTmFtZSIsInZhbHVlQWNjZXNzb3IiLCJtaW5JbmRleCIsInZhbGlkUG9pbnRzIiwiZmlsdGVyIiwicG9pbnQiLCJqb2luIiwiY29udHJvbHMiLCJkaXYiLCJyZWYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js":
/*!*****************************************!*\
  !*** ./src/app/dataVis/TrendAnaTime.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrendAnaIndex */ \"(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__]);\n_TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [currentClusterIndex, setCurrentClusterIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [clusters, setClusters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [xDomain, setXDomain] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const xDomainRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // ✅ State to track whether we are in SolveTimeTrend or TrendAnaTime\n    const [showTimeView, setShowTimeView] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            console.log(\"🔄 XDomain or window size updated:\", xDomain);\n            if (!solves || solves.length === 0) {\n                console.warn(\"⚠️ No solves data available!\");\n                return;\n            }\n            const container = containerRef.current;\n            if (!container) {\n                console.warn(\"⚠️ Container reference is null!\");\n                return;\n            }\n            console.log(\"📏 Updating chart dimensions after resize...\");\n            drawSolveTimeTrend(solves);\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        xDomain,\n        containerRef\n    ]); // 🔥 Ensure chart updates when xDomain or container size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return;\n            console.log(\"🔍 Running cluster detection...\");\n            const detectedClusters = findClusters(solves);\n            setClusters(detectedClusters);\n            if (detectedClusters.length > 0) {\n                const firstCluster = detectedClusters[0];\n                const newDomain = [\n                    new Date(firstCluster[0].timestamp),\n                    new Date(firstCluster.slice(-1)[0].timestamp)\n                ];\n                setXDomain(newDomain);\n                xDomainRef.current = newDomain; // ✅ Ensure ref is updated\n                // ❗ Log AFTER setting the state to reflect the correct value\n                console.log(\"✅ X-Domain initialized to first cluster:\", newDomain);\n            }\n            // Attach resize event\n            window.addEventListener('resize', handleResize);\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]); // <-- Runs only on first load\n    if (showTimeView) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            solves: solves\n        }, void 0, false, {\n            fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n            lineNumber: 62,\n            columnNumber: 16\n        }, this);\n    }\n    function handleResize() {\n        console.log(\"🔄 Handling resize...\");\n        if (!solves || solves.length === 0) {\n            console.warn(\"⚠️ No solves available, skipping resize!\");\n            return;\n        }\n        let detectedClusters = clusters;\n        if (clusters.length === 0) {\n            console.warn(\"⚠️ No clusters available on resize! Refinding clusters...\");\n            detectedClusters = findClusters(solves);\n            setClusters(detectedClusters);\n        }\n        if (detectedClusters.length === 0) {\n            console.warn(\"⚠️ Still no clusters found after resize!\");\n            return;\n        }\n        const prevClusterIndex = currentClusterIndex;\n        const prevXDomain = xDomainRef.current;\n        console.log(\"\\uD83D\\uDCCC Preserving Cluster Index: \".concat(prevClusterIndex));\n        console.log(\"🔍 Preserving X-Domain before resize:\", prevXDomain);\n        // Ensure re-renders with correct states\n        setCurrentClusterIndex(prevClusterIndex);\n        setXDomain(prevXDomain);\n        xDomainRef.current = prevXDomain;\n        // ✅ Force state updates to re-enable buttons\n        setTimeout(()=>{\n            setClusters([\n                ...detectedClusters\n            ]);\n            setXDomain([\n                ...prevXDomain\n            ]);\n            setCurrentClusterIndex(prevClusterIndex);\n        }, 0);\n        // Redraw the chart after resize\n        drawSolveTimeTrend(solves);\n        console.log(\"✅ Resize handled, restoring states.\");\n    }\n    function findClusters(data) {\n        console.log(\"🔍 Running findClusters...\");\n        let detectedClusters = [];\n        let currentCluster = [\n            data[0]\n        ];\n        for(let i = 1; i < data.length; i++){\n            if (new Date(data[i].timestamp) - new Date(data[i - 1].timestamp) > 15 * 60 * 1000) {\n                if (currentCluster.length > 1) {\n                    const uniqueXValues = new Set(currentCluster.map((d)=>d.timestamp));\n                    if (uniqueXValues.size > 1) {\n                        detectedClusters.push(currentCluster);\n                    } else {\n                        console.warn(\"⚠️ Ignoring cluster with same X-Axis values:\", currentCluster);\n                    }\n                }\n                currentCluster = [];\n            }\n            currentCluster.push(data[i]);\n        }\n        // Check last cluster before adding it\n        if (currentCluster.length > 1) {\n            const uniqueXValues = new Set(currentCluster.map((d)=>d.timestamp));\n            if (uniqueXValues.size > 1) {\n                detectedClusters.push(currentCluster);\n            } else {\n                console.warn(\"⚠️ Ignoring cluster with same X-Axis values:\", currentCluster);\n            }\n        }\n        console.log(\"📊 Clusters identified (excluding single/same x-axis clusters):\", detectedClusters.length, detectedClusters);\n        return detectedClusters;\n    }\n    function computeRollingAverage(data, windowSize) {\n        return data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null; // ✅ Preserve nulls at the beginning\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n    }\n    function drawSolveTimeTrend(data) {\n        console.log(\"🔍 Current X-Domain in drawSolveTimeTrend:\", xDomainRef.current);\n        if (!containerRef.current) {\n            console.warn(\"⚠️ Container reference is null, cannot draw!\");\n            return;\n        }\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        console.log(\"📏 Chart dimensions:\", width, height);\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        // Ensure all data contains timestamps\n        const processedData = data.map((solve)=>{\n            if (!solve.timestamp) {\n                console.warn(\"⚠️ Skipping entry with missing timestamp:\", solve);\n                return null;\n            }\n            return {\n                timestamp: new Date(solve.timestamp),\n                time: solve.time / 1000\n            };\n        }).filter((d)=>d !== null); // Remove invalid entries\n        const timestamps = processedData.map((d)=>d.timestamp);\n        const times = processedData.map((d)=>d.time);\n        console.log(\"Processed timestamps:\", timestamps);\n        // 🔥 Find the first \"cluster\" (a short interval of data)\n        let clusterStartIndex = 0;\n        let clusterEndIndex = timestamps.length - 1;\n        for(let i = 1; i < timestamps.length; i++){\n            if (timestamps[i] - timestamps[0] > 15 * 60 * 1000) {\n                clusterEndIndex = i;\n                break;\n            }\n        }\n        // Extract the cluster time range\n        const initialXDomain = [\n            timestamps[clusterStartIndex],\n            timestamps[clusterEndIndex]\n        ];\n        console.log(\"⏳ Initial Focus X Domain: \".concat(initialXDomain[0], \" to \").concat(initialXDomain[1]));\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        const ao5Data = timestamps.map((timestamp, i)=>({\n                timestamp: timestamp,\n                value: ao5[i] !== null ? ao5[i] : null\n            })).filter((d)=>d.value !== null); // Remove initial nulls\n        const ao12Data = timestamps.map((timestamp, i)=>({\n                timestamp: timestamp,\n                value: ao12[i] !== null ? ao12[i] : null\n            })).filter((d)=>d.value !== null); // Remove initial nulls\n        var _xDomainRef_current;\n        // X Scale: Start zoomed into the identified cluster\n        let xScale = d3.scaleTime().domain((_xDomainRef_current = xDomainRef.current) !== null && _xDomainRef_current !== void 0 ? _xDomainRef_current : [\n            timestamps[0],\n            timestamps[timestamps.length - 1]\n        ]) // ✅ Use ref as fallback\n        .range([\n            50,\n            width - 50\n        ]);\n        console.log(\"📉 Applying X Scale domain in drawSolveTimeTrend:\", xScale.domain());\n        console.log(\"xScale range:\", xScale.range());\n        const yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]).range([\n            50,\n            height - 50\n        ]);\n        // Add X and Y axes\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M:%S')));\n        // Filter unique days for displaying date below\n        let lastDate = null;\n        xAxis.selectAll('text').attr('dy', '1.2em') // Move time labels up slightly\n        .each(function(d, i, nodes) {\n            const currentText = d3.select(this);\n            const dateStr = d3.timeFormat('%b %d, %Y')(new Date(d));\n            if (dateStr !== lastDate) {\n                currentText.append('tspan').attr('x', 0).attr('dy', '1.2em').text(dateStr);\n                lastDate = dateStr;\n            }\n        });\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom()// .scaleExtent([0.5, 5])\n        // .translateExtent([[0, 0], [width, height]])\n        .on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            console.log(\"Updated xScale domain:\", newXScale.domain());\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale).tickFormat(d3.timeFormat('%H:%M:%S')));\n            let lastZoomDate = null;\n            xAxis.selectAll('text').attr('dy', '1.2em').each(function(d, i, nodes) {\n                const currentText = d3.select(this);\n                const dateStr = d3.timeFormat('%b %d, %Y')(new Date(d));\n                if (dateStr !== lastZoomDate) {\n                    currentText.append('tspan').attr('x', 0).attr('dy', '1.2em').text(dateStr);\n                    lastZoomDate = dateStr;\n                }\n            });\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // ✅ Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 80)\")); // ⬇ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"🔄 Updating Plot with New Scales:\");\n            console.log(\"🟢 New X Scale Domain:\", newXScale.domain());\n            console.log(\"🟢 New Y Scale Domain:\", newYScale.domain());\n            // ✅ Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5Data, (d)=>d.timestamp).join('circle').attr('class', 'point-ao5').attr('cx', (d)=>xScale(new Date(d.timestamp))) // Align with timestamps\n            .attr('cy', (d)=>yScale(d.value)).attr('r', 5).attr('fill', 'green').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12Data, (d)=>d.timestamp).join('circle').attr('class', 'point-ao12').attr('cx', (d)=>xScale(new Date(d.timestamp))) // Align with timestamps\n            .attr('cy', (d)=>yScale(d.value)).attr('r', 5).attr('fill', 'red').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            console.log(\"✔ Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"✔ Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"⚠️ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"⚠️ No AO12 points found in updatePlot!\");\n            // ✅ Update all AO5 points correctly\n            ao5Selection.attr('cx', (d)=>newXScale(new Date(d.timestamp))).attr('cy', (d)=>newYScale(d.value)); // ✅ Use d.value for AO5\n            // ✅ Update all AO12 points correctly\n            ao12Selection.attr('cx', (d)=>newXScale(new Date(d.timestamp))).attr('cy', (d)=>newYScale(d.value)); // ✅ Use d.value for AO12\n            // ✅ Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // ✅ Update single solve points\n            svg.selectAll('.point-single').data(processedData, (d)=>d.timestamp).join('circle').attr('class', 'point-single').attr('cx', (d)=>newXScale(new Date(d.timestamp))) // FIX: Use newXScale\n            .attr('cy', (d)=>newYScale(d.time)) // FIX: Use newYScale\n            .attr('r', 5).attr('fill', 'blue').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            // ✅ Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.time)));\n            // ✅ Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').datum(ao5.map((val, i)=>({\n                    timestamp: timestamps[i],\n                    value: val\n                }))).attr('d', d3.line().curve(d3.curveMonotoneX).defined((d)=>d.value !== null).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.value)));\n            // ✅ Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').datum(ao12.map((val, i)=>({\n                    timestamp: timestamps[i],\n                    value: val\n                }))).attr('d', d3.line().curve(d3.curveMonotoneX).defined((d)=>d.value !== null).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.value)));\n        }\n        svg.append('path').datum(processedData).attr('class', 'line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).x((d)=>xScale(new Date(d.timestamp))).y((d)=>yScale(d.time)));\n        svg.selectAll('.line-ao5').data([\n            ao5\n        ]) // ✅ Use .data([]) instead of .datum()\n        .join(\"path\").attr('class', 'line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>xScale(new Date(timestamps[i]))) // ✅ Use timestamps\n        .y((_, i)=>yScale(ao5[i])));\n        svg.selectAll('.line-ao12').data([\n            ao12\n        ]) // ✅ Use .data([]) instead of .datum()\n        .join(\"path\").attr('class', 'line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>xScale(new Date(timestamps[i]))) // ✅ Use timestamps\n        .y((_, i)=>yScale(ao12[i])));\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, timestamp) {\n            if (!timestamp) {\n                console.warn(\"⚠️ showTooltip called with invalid timestamp:\", timestamp);\n                return;\n            }\n            // Find all data points with the same timestamp\n            const singleData = processedData.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const ao5DataPoint = ao5Data.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const ao12DataPoint = ao12Data.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const singleTime = singleData ? singleData.time.toFixed(2) : \"-\";\n            const ao5Time = ao5DataPoint ? ao5DataPoint.value.toFixed(2) : \"-\";\n            const ao12Time = ao12DataPoint ? ao12DataPoint.value.toFixed(2) : \"-\";\n            console.log(\"\\uD83D\\uDFE2 Showing tooltip for timestamp \".concat(timestamp, \": Single=\").concat(singleTime, \", AO5=\").concat(ao5Time, \", AO12=\").concat(ao12Time));\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // ✅ Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // ✅ Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // ✅ Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"✔ Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color);\n        }\n        // ✅ Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n    // const controls = d3.select(containerRef.current).append('div')\n    //     .attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow');\n    //\n    // controls.append('button')\n    //     .text('Previous Cluster')\n    //     .style('margin-right', '5px')\n    //     .attr('disabled', clusters.length === 0 || currentClusterIndex === 0 ? 'disabled' : null)\n    //     .on('click', prevCluster);\n    //\n    // controls.append('button')\n    //     .text('Next Cluster')\n    //     .style('margin-right', '5px')\n    //     .attr('disabled', clusters.length === 0 || currentClusterIndex >= clusters.length - 1 ? 'disabled' : null)\n    //     .on('click', nextCluster);\n    //\n    // controls.append('button')\n    //     .text('Autoscale')\n    //     .style('margin-right', '5px')\n    //     .on('click', autoscale);\n    //\n    // controls.append('button')\n    //     .text('Switch to Time View')\n    //     .style('margin-right', '5px')\n    //     .on('click', () => setShowTimeView(true));\n    }\n    function autoscale() {\n        console.log(\"🔍 Autoscale triggered...\");\n        if (!clusters || clusters.length === 0) {\n            console.warn(\"⚠️ No clusters available for autoscale!\");\n            return;\n        }\n        console.log(\"📌 Autoscaling to first cluster...\");\n        setCurrentClusterIndex(0);\n        const firstCluster = clusters[0];\n        if (!firstCluster || firstCluster.length === 0) {\n            console.warn(\"⚠️ First cluster is empty, cannot autoscale!\");\n            return;\n        }\n        const newDomain = [\n            new Date(firstCluster[0].timestamp),\n            new Date(firstCluster.slice(-1)[0].timestamp)\n        ];\n        console.log(\"✅ Setting autoscale X-Domain to:\", newDomain);\n        setXDomain(newDomain);\n        xDomainRef.current = newDomain;\n        // ✅ Force React to update UI state\n        setTimeout(()=>{\n            setClusters([\n                ...clusters\n            ]); // Force re-evaluation of clusters state\n        }, 0);\n    }\n    function nextCluster() {\n        console.log(\"➡️ Next cluster clicked...\");\n        if (currentClusterIndex < clusters.length - 1) {\n            const nextIndex = currentClusterIndex + 1;\n            console.log(\"📌 Moving to next cluster:\", nextIndex);\n            setCurrentClusterIndex(nextIndex);\n            const newDomain = [\n                new Date(clusters[nextIndex][0].timestamp),\n                new Date(clusters[nextIndex].slice(-1)[0].timestamp)\n            ];\n            setXDomain(newDomain);\n            xDomainRef.current = newDomain;\n        } else {\n            console.warn(\"⚠️ No next cluster available!\");\n        }\n    }\n    function prevCluster() {\n        console.log(\"⬅️ Previous cluster clicked...\");\n        if (currentClusterIndex > 0) {\n            const prevIndex = currentClusterIndex - 1;\n            console.log(\"📌 Moving to previous cluster:\", prevIndex);\n            setCurrentClusterIndex(prevIndex);\n            const newDomain = [\n                new Date(clusters[prevIndex][0].timestamp),\n                new Date(clusters[prevIndex].slice(-1)[0].timestamp)\n            ];\n            setXDomain(newDomain);\n            xDomainRef.current = newDomain;\n        } else {\n            console.warn(\"⚠️ No previous cluster available!\");\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: containerRef,\n                className: \"w-full h-full\"\n            }, void 0, false, {\n                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n                lineNumber: 686,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-2 right-2 bg-white p-2 rounded shadow flex space-x-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\",\n                        disabled: clusters.length === 0 || currentClusterIndex === 0,\n                        onClick: ()=>setCurrentClusterIndex(currentClusterIndex - 1),\n                        children: \"Previous Cluster\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n                        lineNumber: 690,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\",\n                        disabled: clusters.length === 0 || currentClusterIndex >= clusters.length - 1,\n                        onClick: ()=>setCurrentClusterIndex(currentClusterIndex + 1),\n                        children: \"Next Cluster\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n                        lineNumber: 698,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\",\n                        onClick: ()=>autoscale(),\n                        children: \"Autoscale\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n                        lineNumber: 706,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-700\",\n                        onClick: ()=>setShowTimeView(true),\n                        children: \"Switch to Time View\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n                        lineNumber: 714,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n                lineNumber: 689,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n        lineNumber: 684,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"33HgTpEWt3wIEpA3MVY/TKFnHyc=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYVRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVvRDtBQUNSO0FBQzVDLE1BQU1JLEtBQUssTUFBTSw0TUFBWTtBQUVkLFNBQVNDLGVBQWUsS0FBVTtRQUFWLEVBQUVDLE1BQU0sRUFBRSxHQUFWOztJQUNuQyxNQUFNQyxlQUFlTiw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNLENBQUNPLHFCQUFxQkMsdUJBQXVCLEdBQUdQLCtDQUFRQSxDQUFDO0lBQy9ELE1BQU0sQ0FBQ1EsVUFBVUMsWUFBWSxHQUFHVCwrQ0FBUUEsQ0FBQyxFQUFFO0lBQzNDLE1BQU0sQ0FBQ1UsU0FBU0MsV0FBVyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNWSxhQUFhYiw2Q0FBTUEsQ0FBQztJQUUxQixvRUFBb0U7SUFDcEUsTUFBTSxDQUFDYyxjQUFjQyxnQkFBZ0IsR0FBR2QsK0NBQVFBLENBQUM7SUFFakRGLGdEQUFTQTtvQ0FBQztZQUNOaUIsUUFBUUMsR0FBRyxDQUFDLHNDQUFzQ047WUFFbEQsSUFBSSxDQUFDTixVQUFVQSxPQUFPYSxNQUFNLEtBQUssR0FBRztnQkFDaENGLFFBQVFHLElBQUksQ0FBQztnQkFDYjtZQUNKO1lBRUEsTUFBTUMsWUFBWWQsYUFBYWUsT0FBTztZQUN0QyxJQUFJLENBQUNELFdBQVc7Z0JBQ1pKLFFBQVFHLElBQUksQ0FBQztnQkFDYjtZQUNKO1lBRUFILFFBQVFDLEdBQUcsQ0FBQztZQUNaSyxtQkFBbUJqQjtRQUN2QjttQ0FBRztRQUFDTTtRQUFTTDtLQUFhLEdBQUksaUVBQWlFO0lBRS9GUCxnREFBU0E7b0NBQUM7WUFDTixJQUFJLENBQUNNLFVBQVUsQ0FBQ2tCLE1BQU1DLE9BQU8sQ0FBQ25CLFdBQVdBLE9BQU9hLE1BQU0sS0FBSyxHQUFHO1lBRTlERixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNUSxtQkFBbUJDLGFBQWFyQjtZQUN0Q0ssWUFB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ZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxkYXRhVmlzXFxUcmVuZEFuYVRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgVHJlbmRBbmFJbmRleCBmcm9tICcuL1RyZW5kQW5hSW5kZXgnO1xyXG5jb25zdCBkMyA9IGF3YWl0IGltcG9ydCgnZDMnKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNvbHZlVGltZVRyZW5kKHsgc29sdmVzIH0pIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcclxuICAgIGNvbnN0IFtjdXJyZW50Q2x1c3RlckluZGV4LCBzZXRDdXJyZW50Q2x1c3RlckluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW2NsdXN0ZXJzLCBzZXRDbHVzdGVyc10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgICBjb25zdCBbeERvbWFpbiwgc2V0WERvbWFpbl0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IHhEb21haW5SZWYgPSB1c2VSZWYobnVsbCk7XHJcblxyXG4gICAgLy8g4pyFIFN0YXRlIHRvIHRyYWNrIHdoZXRoZXIgd2UgYXJlIGluIFNvbHZlVGltZVRyZW5kIG9yIFRyZW5kQW5hVGltZVxyXG4gICAgY29uc3QgW3Nob3dUaW1lVmlldywgc2V0U2hvd1RpbWVWaWV3XSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBYRG9tYWluIG9yIHdpbmRvdyBzaXplIHVwZGF0ZWQ6XCIsIHhEb21haW4pO1xyXG5cclxuICAgICAgICBpZiAoIXNvbHZlcyB8fCBzb2x2ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBzb2x2ZXMgZGF0YSBhdmFpbGFibGUhXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gQ29udGFpbmVyIHJlZmVyZW5jZSBpcyBudWxsIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OPIFVwZGF0aW5nIGNoYXJ0IGRpbWVuc2lvbnMgYWZ0ZXIgcmVzaXplLi4uXCIpO1xyXG4gICAgICAgIGRyYXdTb2x2ZVRpbWVUcmVuZChzb2x2ZXMpO1xyXG4gICAgfSwgW3hEb21haW4sIGNvbnRhaW5lclJlZl0pOyAgLy8g8J+UpSBFbnN1cmUgY2hhcnQgdXBkYXRlcyB3aGVuIHhEb21haW4gb3IgY29udGFpbmVyIHNpemUgY2hhbmdlc1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzb2x2ZXMgfHwgIUFycmF5LmlzQXJyYXkoc29sdmVzKSB8fCBzb2x2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBSdW5uaW5nIGNsdXN0ZXIgZGV0ZWN0aW9uLi4uXCIpO1xyXG4gICAgICAgIGNvbnN0IGRldGVjdGVkQ2x1c3RlcnMgPSBmaW5kQ2x1c3RlcnMoc29sdmVzKTtcclxuICAgICAgICBzZXRDbHVzdGVycyhkZXRlY3RlZENsdXN0ZXJzKTtcclxuXHJcbiAgICAgICAgaWYgKGRldGVjdGVkQ2x1c3RlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdENsdXN0ZXIgPSBkZXRlY3RlZENsdXN0ZXJzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdEb21haW4gPSBbXHJcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShmaXJzdENsdXN0ZXJbMF0udGltZXN0YW1wKSxcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGZpcnN0Q2x1c3Rlci5zbGljZSgtMSlbMF0udGltZXN0YW1wKVxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgc2V0WERvbWFpbihuZXdEb21haW4pO1xyXG4gICAgICAgICAgICB4RG9tYWluUmVmLmN1cnJlbnQgPSBuZXdEb21haW47ICAvLyDinIUgRW5zdXJlIHJlZiBpcyB1cGRhdGVkXHJcblxyXG4gICAgICAgICAgICAvLyDinZcgTG9nIEFGVEVSIHNldHRpbmcgdGhlIHN0YXRlIHRvIHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLinIUgWC1Eb21haW4gaW5pdGlhbGl6ZWQgdG8gZmlyc3QgY2x1c3RlcjpcIiwgbmV3RG9tYWluKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF0dGFjaCByZXNpemUgZXZlbnRcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICB9LCBbc29sdmVzXSk7ICAvLyA8LS0gUnVucyBvbmx5IG9uIGZpcnN0IGxvYWRcclxuXHJcbiAgICBpZiAoc2hvd1RpbWVWaWV3KSB7XHJcbiAgICAgICAgcmV0dXJuIDxUcmVuZEFuYUluZGV4IHNvbHZlcz17c29sdmVzfSAvPjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SEIEhhbmRsaW5nIHJlc2l6ZS4uLlwiKTtcclxuXHJcbiAgICAgICAgaWYgKCFzb2x2ZXMgfHwgc29sdmVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gc29sdmVzIGF2YWlsYWJsZSwgc2tpcHBpbmcgcmVzaXplIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGRldGVjdGVkQ2x1c3RlcnMgPSBjbHVzdGVycztcclxuXHJcbiAgICAgICAgaWYgKGNsdXN0ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gY2x1c3RlcnMgYXZhaWxhYmxlIG9uIHJlc2l6ZSEgUmVmaW5kaW5nIGNsdXN0ZXJzLi4uXCIpO1xyXG4gICAgICAgICAgICBkZXRlY3RlZENsdXN0ZXJzID0gZmluZENsdXN0ZXJzKHNvbHZlcyk7XHJcbiAgICAgICAgICAgIHNldENsdXN0ZXJzKGRldGVjdGVkQ2x1c3RlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRldGVjdGVkQ2x1c3RlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBTdGlsbCBubyBjbHVzdGVycyBmb3VuZCBhZnRlciByZXNpemUhXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcmV2Q2x1c3RlckluZGV4ID0gY3VycmVudENsdXN0ZXJJbmRleDtcclxuICAgICAgICBjb25zdCBwcmV2WERvbWFpbiA9IHhEb21haW5SZWYuY3VycmVudDtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4wgUHJlc2VydmluZyBDbHVzdGVyIEluZGV4OiAke3ByZXZDbHVzdGVySW5kZXh9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIFByZXNlcnZpbmcgWC1Eb21haW4gYmVmb3JlIHJlc2l6ZTpcIiwgcHJldlhEb21haW4pO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgcmUtcmVuZGVycyB3aXRoIGNvcnJlY3Qgc3RhdGVzXHJcbiAgICAgICAgc2V0Q3VycmVudENsdXN0ZXJJbmRleChwcmV2Q2x1c3RlckluZGV4KTtcclxuICAgICAgICBzZXRYRG9tYWluKHByZXZYRG9tYWluKTtcclxuICAgICAgICB4RG9tYWluUmVmLmN1cnJlbnQgPSBwcmV2WERvbWFpbjtcclxuXHJcbiAgICAgICAgLy8g4pyFIEZvcmNlIHN0YXRlIHVwZGF0ZXMgdG8gcmUtZW5hYmxlIGJ1dHRvbnNcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgc2V0Q2x1c3RlcnMoWy4uLmRldGVjdGVkQ2x1c3RlcnNdKTtcclxuICAgICAgICAgICAgc2V0WERvbWFpbihbLi4ucHJldlhEb21haW5dKTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudENsdXN0ZXJJbmRleChwcmV2Q2x1c3RlckluZGV4KTtcclxuICAgICAgICB9LCAwKTtcclxuXHJcbiAgICAgICAgLy8gUmVkcmF3IHRoZSBjaGFydCBhZnRlciByZXNpemVcclxuICAgICAgICBkcmF3U29sdmVUaW1lVHJlbmQoc29sdmVzKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLinIUgUmVzaXplIGhhbmRsZWQsIHJlc3RvcmluZyBzdGF0ZXMuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRDbHVzdGVycyhkYXRhKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIFJ1bm5pbmcgZmluZENsdXN0ZXJzLi4uXCIpO1xyXG5cclxuICAgICAgICBsZXQgZGV0ZWN0ZWRDbHVzdGVycyA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50Q2x1c3RlciA9IFtkYXRhWzBdXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXcgRGF0ZShkYXRhW2ldLnRpbWVzdGFtcCkgLSBuZXcgRGF0ZShkYXRhW2kgLSAxXS50aW1lc3RhbXApID4gMTUgKiA2MCAqIDEwMDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2x1c3Rlci5sZW5ndGggPiAxKSB7ICAvLyDinIUgSWdub3JlIGNsdXN0ZXJzIHdpdGggYSBzaW5nbGUgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVYVmFsdWVzID0gbmV3IFNldChjdXJyZW50Q2x1c3Rlci5tYXAoZCA9PiBkLnRpbWVzdGFtcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmlxdWVYVmFsdWVzLnNpemUgPiAxKSB7ICAvLyDinIUgSWdub3JlIGNsdXN0ZXJzIHdpdGggdGhlIHNhbWUgWC1BeGlzIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGVkQ2x1c3RlcnMucHVzaChjdXJyZW50Q2x1c3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIElnbm9yaW5nIGNsdXN0ZXIgd2l0aCBzYW1lIFgtQXhpcyB2YWx1ZXM6XCIsIGN1cnJlbnRDbHVzdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2x1c3RlciA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRDbHVzdGVyLnB1c2goZGF0YVtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBsYXN0IGNsdXN0ZXIgYmVmb3JlIGFkZGluZyBpdFxyXG4gICAgICAgIGlmIChjdXJyZW50Q2x1c3Rlci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVhWYWx1ZXMgPSBuZXcgU2V0KGN1cnJlbnRDbHVzdGVyLm1hcChkID0+IGQudGltZXN0YW1wKSk7XHJcbiAgICAgICAgICAgIGlmICh1bmlxdWVYVmFsdWVzLnNpemUgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBkZXRlY3RlZENsdXN0ZXJzLnB1c2goY3VycmVudENsdXN0ZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIElnbm9yaW5nIGNsdXN0ZXIgd2l0aCBzYW1lIFgtQXhpcyB2YWx1ZXM6XCIsIGN1cnJlbnRDbHVzdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OKIENsdXN0ZXJzIGlkZW50aWZpZWQgKGV4Y2x1ZGluZyBzaW5nbGUvc2FtZSB4LWF4aXMgY2x1c3RlcnMpOlwiLCBkZXRlY3RlZENsdXN0ZXJzLmxlbmd0aCwgZGV0ZWN0ZWRDbHVzdGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGRldGVjdGVkQ2x1c3RlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKGRhdGEsIHdpbmRvd1NpemUpIHtcclxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoKF8sIGksIGFycikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaSA8IHdpbmRvd1NpemUgLSAxKSByZXR1cm4gbnVsbDsgIC8vIOKchSBQcmVzZXJ2ZSBudWxscyBhdCB0aGUgYmVnaW5uaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnNldCA9IGFyci5zbGljZShpIC0gKHdpbmRvd1NpemUgLSAxKSwgaSArIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3Vic2V0LnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkgLyBzdWJzZXQubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdTb2x2ZVRpbWVUcmVuZChkYXRhKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIEN1cnJlbnQgWC1Eb21haW4gaW4gZHJhd1NvbHZlVGltZVRyZW5kOlwiLCB4RG9tYWluUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQpe1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gQ29udGFpbmVyIHJlZmVyZW5jZSBpcyBudWxsLCBjYW5ub3QgZHJhdyFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCk7XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgfHwgNTAwO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk48gQ2hhcnQgZGltZW5zaW9uczpcIiwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IGNvbnRhaW5lci5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICcxMDAlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsICcxMDAlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApXHJcbiAgICAgICAgICAgIC5hdHRyKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaWRZTWlkIG1lZXQnKTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIGFsbCBkYXRhIGNvbnRhaW5zIHRpbWVzdGFtcHNcclxuICAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gZGF0YVxyXG4gICAgICAgICAgICAubWFwKHNvbHZlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghc29sdmUudGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIFNraXBwaW5nIGVudHJ5IHdpdGggbWlzc2luZyB0aW1lc3RhbXA6XCIsIHNvbHZlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShzb2x2ZS50aW1lc3RhbXApLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IHNvbHZlLnRpbWUgLyAxMDAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZmlsdGVyKGQgPT4gZCAhPT0gbnVsbCk7ICAvLyBSZW1vdmUgaW52YWxpZCBlbnRyaWVzXHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBwcm9jZXNzZWREYXRhLm1hcChkID0+IGQudGltZXN0YW1wKTtcclxuICAgICAgICBjb25zdCB0aW1lcyA9IHByb2Nlc3NlZERhdGEubWFwKGQgPT4gZC50aW1lKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJQcm9jZXNzZWQgdGltZXN0YW1wczpcIiwgdGltZXN0YW1wcyk7XHJcblxyXG4gICAgICAgIC8vIPCflKUgRmluZCB0aGUgZmlyc3QgXCJjbHVzdGVyXCIgKGEgc2hvcnQgaW50ZXJ2YWwgb2YgZGF0YSlcclxuICAgICAgICBsZXQgY2x1c3RlclN0YXJ0SW5kZXggPSAwO1xyXG4gICAgICAgIGxldCBjbHVzdGVyRW5kSW5kZXggPSB0aW1lc3RhbXBzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGltZXN0YW1wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGltZXN0YW1wc1tpXSAtIHRpbWVzdGFtcHNbMF0gPiAxNSAqIDYwICogMTAwMCkgeyAvLyAxNS1taW51dGUgd2luZG93XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyRW5kSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGNsdXN0ZXIgdGltZSByYW5nZVxyXG4gICAgICAgIGNvbnN0IGluaXRpYWxYRG9tYWluID0gW1xyXG4gICAgICAgICAgICB0aW1lc3RhbXBzW2NsdXN0ZXJTdGFydEluZGV4XSxcclxuICAgICAgICAgICAgdGltZXN0YW1wc1tjbHVzdGVyRW5kSW5kZXhdXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYOKPsyBJbml0aWFsIEZvY3VzIFggRG9tYWluOiAke2luaXRpYWxYRG9tYWluWzBdfSB0byAke2luaXRpYWxYRG9tYWluWzFdfWApO1xyXG5cclxuICAgICAgICBjb25zdCBhbzUgPSBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UodGltZXMsIDUpO1xyXG4gICAgICAgIGNvbnN0IGFvMTIgPSBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UodGltZXMsIDEyKTtcclxuXHJcbiAgICAgICAgY29uc3QgYW81RGF0YSA9IHRpbWVzdGFtcHMubWFwKCh0aW1lc3RhbXAsIGkpID0+ICh7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxyXG4gICAgICAgICAgICB2YWx1ZTogYW81W2ldICE9PSBudWxsID8gYW81W2ldIDogbnVsbFxyXG4gICAgICAgIH0pKS5maWx0ZXIoZCA9PiBkLnZhbHVlICE9PSBudWxsKTsgLy8gUmVtb3ZlIGluaXRpYWwgbnVsbHNcclxuXHJcbiAgICAgICAgY29uc3QgYW8xMkRhdGEgPSB0aW1lc3RhbXBzLm1hcCgodGltZXN0YW1wLCBpKSA9PiAoe1xyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgdmFsdWU6IGFvMTJbaV0gIT09IG51bGwgPyBhbzEyW2ldIDogbnVsbFxyXG4gICAgICAgIH0pKS5maWx0ZXIoZCA9PiBkLnZhbHVlICE9PSBudWxsKTsgLy8gUmVtb3ZlIGluaXRpYWwgbnVsbHNcclxuXHJcbiAgICAgICAgLy8gWCBTY2FsZTogU3RhcnQgem9vbWVkIGludG8gdGhlIGlkZW50aWZpZWQgY2x1c3RlclxyXG4gICAgICAgIGxldCB4U2NhbGUgPSBkMy5zY2FsZVRpbWUoKVxyXG4gICAgICAgICAgICAuZG9tYWluKHhEb21haW5SZWYuY3VycmVudCA/PyBbdGltZXN0YW1wc1swXSwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdXSkgIC8vIOKchSBVc2UgcmVmIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgICAgIC5yYW5nZShbNTAsIHdpZHRoIC0gNTBdKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OJIEFwcGx5aW5nIFggU2NhbGUgZG9tYWluIGluIGRyYXdTb2x2ZVRpbWVUcmVuZDpcIiwgeFNjYWxlLmRvbWFpbigpKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInhTY2FsZSByYW5nZTpcIiwgeFNjYWxlLnJhbmdlKCkpO1xyXG5cclxuICAgICAgICBjb25zdCB5U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oW2QzLm1heCh0aW1lcyksIGQzLm1pbih0aW1lcyldKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCBoZWlnaHQgLSA1MF0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgWCBhbmQgWSBheGVzXHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3gtYXhpcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7aGVpZ2h0IC0gNTB9KWApXHJcbiAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNCb3R0b20oeFNjYWxlKS50aWNrRm9ybWF0KGQzLnRpbWVGb3JtYXQoJyVIOiVNOiVTJykpKTtcclxuXHJcbiAgICAgICAgLy8gRmlsdGVyIHVuaXF1ZSBkYXlzIGZvciBkaXNwbGF5aW5nIGRhdGUgYmVsb3dcclxuICAgICAgICBsZXQgbGFzdERhdGUgPSBudWxsO1xyXG4gICAgICAgIHhBeGlzLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcxLjJlbScpIC8vIE1vdmUgdGltZSBsYWJlbHMgdXAgc2xpZ2h0bHlcclxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCwgaSwgbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gZDMuc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IGQzLnRpbWVGb3JtYXQoJyViICVkLCAlWScpKG5ldyBEYXRlKGQpKTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlU3RyICE9PSBsYXN0RGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0LmFwcGVuZCgndHNwYW4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcxLjJlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGRhdGVTdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3REYXRlID0gZGF0ZVN0cjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5LWF4aXMnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSg1MCwgMClgKVxyXG4gICAgICAgICAgICAuY2FsbChkMy5heGlzTGVmdCh5U2NhbGUpKTtcclxuXHJcbiAgICAgICAgY29uc3QgZ3JpZEdyb3VwID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2dyaWQnKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd0dyaWQoeFNjYWxlLCB5U2NhbGUpIHtcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBncmlkIGxpbmVzXHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJy5ob3Jpem9udGFsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoeVNjYWxlLnRpY2tzKDEwKSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdob3Jpem9udGFsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZCA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBkID0+IHlTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICc0LDQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIGdyaWQgbGluZXNcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnLnZlcnRpY2FsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoeFNjYWxlLnRpY2tzKDEwKSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZXJ0aWNhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4geFNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiB4U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGhlaWdodCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjY2NjJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgJzQsNCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHJhd0dyaWQoeFNjYWxlLCB5U2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCB6b29tID0gZDMuem9vbSgpXHJcbiAgICAgICAgICAgIC8vIC5zY2FsZUV4dGVudChbMC41LCA1XSlcclxuICAgICAgICAgICAgLy8gLnRyYW5zbGF0ZUV4dGVudChbWzAsIDBdLCBbd2lkdGgsIGhlaWdodF1dKVxyXG4gICAgICAgICAgICAub24oJ3pvb20nLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1hTY2FsZSA9IHRyYW5zZm9ybS5yZXNjYWxlWCh4U2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3WVNjYWxlID0gdHJhbnNmb3JtLnJlc2NhbGVZKHlTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVcGRhdGVkIHhTY2FsZSBkb21haW46XCIsIG5ld1hTY2FsZS5kb21haW4oKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBwbG90c1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlUGxvdChuZXdYU2NhbGUsIG5ld1lTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGF4ZXNcclxuICAgICAgICAgICAgICAgIHhBeGlzLmNhbGwoZDMuYXhpc0JvdHRvbShuZXdYU2NhbGUpLnRpY2tGb3JtYXQoZDMudGltZUZvcm1hdCgnJUg6JU06JVMnKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBsYXN0Wm9vbURhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgeEF4aXMuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMS4yZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsIGksIG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gZDMuc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlU3RyID0gZDMudGltZUZvcm1hdCgnJWIgJWQsICVZJykobmV3IERhdGUoZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZVN0ciAhPT0gbGFzdFpvb21EYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dC5hcHBlbmQoJ3RzcGFuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzEuMmVtJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dChkYXRlU3RyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Rab29tRGF0ZSA9IGRhdGVTdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHlBeGlzLmNhbGwoZDMuYXhpc0xlZnQobmV3WVNjYWxlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdyaWQgd2l0aCBuZXcgc2NhbGVzXHJcbiAgICAgICAgICAgICAgICBkcmF3R3JpZChuZXdYU2NhbGUsIG5ld1lTY2FsZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzdmcuY2FsbCh6b29tKTtcclxuXHJcbiAgICAgICAgLy8g4pyFIEFkZCBMZWdlbmRzIChCZWxvdyBBdXRvc2NhbGUgQnV0dG9uKVxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3dpZHRoIC0gMTIwfSwgODApYCk7IC8vIOKshyBNb3ZlcyBsZWdlbmQgbG93ZXIgdW5kZXIgYnV0dG9uXHJcblxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1zID0gW1xyXG4gICAgICAgICAgICB7IGNvbG9yOiAnYmx1ZScsIGxhYmVsOiAnU2luZ2xlJyB9LFxyXG4gICAgICAgICAgICB7IGNvbG9yOiAnZ3JlZW4nLCBsYWJlbDogJ0FPNScgfSxcclxuICAgICAgICAgICAgeyBjb2xvcjogJ3JlZCcsIGxhYmVsOiAnQU8xMicgfVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGxlZ2VuZEl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcclxuICAgICAgICAgICAgbGVnZW5kLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGkgKiAyMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDE1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDE1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBpdGVtLmNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAyMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaSAqIDIwICsgMTIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzEycHgnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoaXRlbS5sYWJlbCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4vLyBFbnN1cmUgZXZlbnQgaXMgcGFzc2VkIHRvIGF1dG9zY2FsZVxyXG4gICAgICAgIHN2Zy5vbignZGJsY2xpY2snLCAoZXZlbnQpID0+IGF1dG9zY2FsZShldmVudCkpO1xyXG5cclxuLy8gQWxzbyBleHBsaWNpdGx5IGRpc2FibGUgem9vbSBvbiBkb3VibGUtY2xpY2sgdG8gcHJldmVudCB6b29taW5nIGluXHJcbiAgICAgICAgc3ZnLmNhbGwoem9vbSkub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVQbG90KG5ld1hTY2FsZSwgbmV3WVNjYWxlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBVcGRhdGluZyBQbG90IHdpdGggTmV3IFNjYWxlczpcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+foiBOZXcgWCBTY2FsZSBEb21haW46XCIsIG5ld1hTY2FsZS5kb21haW4oKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+foiBOZXcgWSBTY2FsZSBEb21haW46XCIsIG5ld1lTY2FsZS5kb21haW4oKSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIHRoYXQgdGhlIEFPNSBhbmQgQU8xMiBwb2ludHMgYXJlIGNvcnJlY3RseSBib3VuZFxyXG4gICAgICAgICAgICBjb25zdCBhbzVTZWxlY3Rpb24gPSBzdmcuc2VsZWN0QWxsKCcucG9pbnQtYW81JylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGFvNURhdGEsIGQgPT4gZC50aW1lc3RhbXApXHJcbiAgICAgICAgICAgICAgICAuam9pbignY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwb2ludC1hbzUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiB4U2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSkgIC8vIEFsaWduIHdpdGggdGltZXN0YW1wc1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdncmVlbicpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGV2ZW50LCBkKSA9PiBzaG93VG9vbHRpcChldmVudCwgZC50aW1lc3RhbXApKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKCkgPT4gdG9vbHRpcC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYW8xMlNlbGVjdGlvbiA9IHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1hbzEyJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGFvMTJEYXRhLCBkID0+IGQudGltZXN0YW1wKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncG9pbnQtYW8xMicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IHhTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKSAgLy8gQWxpZ24gd2l0aCB0aW1lc3RhbXBzXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IHlTY2FsZShkLnZhbHVlKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3JlZCcpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGV2ZW50LCBkKSA9PiBzaG93VG9vbHRpcChldmVudCwgZC50aW1lc3RhbXApKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKCkgPT4gdG9vbHRpcC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBUb3RhbCBBTzUgUG9pbnRzIFNlbGVjdGVkOiAke2FvNVNlbGVjdGlvbi5zaXplKCl9IChFeHBlY3RlZDogJHthbzUubGVuZ3RofSlgKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBUb3RhbCBBTzEyIFBvaW50cyBTZWxlY3RlZDogJHthbzEyU2VsZWN0aW9uLnNpemUoKX0gKEV4cGVjdGVkOiAke2FvMTIubGVuZ3RofSlgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbzVTZWxlY3Rpb24uc2l6ZSgpID09PSAwKSBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gQU81IHBvaW50cyBmb3VuZCBpbiB1cGRhdGVQbG90IVwiKTtcclxuICAgICAgICAgICAgaWYgKGFvMTJTZWxlY3Rpb24uc2l6ZSgpID09PSAwKSBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gQU8xMiBwb2ludHMgZm91bmQgaW4gdXBkYXRlUGxvdCFcIik7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIGFsbCBBTzUgcG9pbnRzIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBhbzVTZWxlY3Rpb24uYXR0cignY3gnLCBkID0+IG5ld1hTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBuZXdZU2NhbGUoZC52YWx1ZSkpOyAvLyDinIUgVXNlIGQudmFsdWUgZm9yIEFPNVxyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBhbGwgQU8xMiBwb2ludHMgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGFvMTJTZWxlY3Rpb24uYXR0cignY3gnLCBkID0+IG5ld1hTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBuZXdZU2NhbGUoZC52YWx1ZSkpOyAvLyDinIUgVXNlIGQudmFsdWUgZm9yIEFPMTJcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBEZWJ1Z2dpbmc6IEVuc3VyZSBsYXN0IEFPNSAmIEFPMTIgcG9pbnRzIHVwZGF0ZSBjb3JyZWN0bHlcclxuICAgICAgICAgICAgYW81U2VsZWN0aW9uLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGFvNS5sZW5ndGggLSA0KSB7IC8vIFVzZSBgYW81Lmxlbmd0aGAgdG8gY29ycmVjdGx5IGl0ZXJhdGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+foiBBTzUgUG9pbnQgJHtpfTogeD0ke25ld1hTY2FsZShkLngpfSwgeT0ke25ld1lTY2FsZShkLnkpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGFvMTJTZWxlY3Rpb24uZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYW8xMi5sZW5ndGggLSAxMikgeyAvLyBVc2UgYGFvMTIubGVuZ3RoYCB0byBjb3JyZWN0bHkgaXRlcmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S0IEFPMTIgUG9pbnQgJHtpfTogeD0ke25ld1hTY2FsZShkLngpfSwgeT0ke25ld1lTY2FsZShkLnkpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgc2luZ2xlIHNvbHZlIHBvaW50c1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcucG9pbnQtc2luZ2xlJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHByb2Nlc3NlZERhdGEsIGQgPT4gZC50aW1lc3RhbXApXHJcbiAgICAgICAgICAgICAgICAuam9pbignY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwb2ludC1zaW5nbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiBuZXdYU2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSkgLy8gRklYOiBVc2UgbmV3WFNjYWxlXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnRpbWUpKSAvLyBGSVg6IFVzZSBuZXdZU2NhbGVcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsdWUnKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChldmVudCwgZCkgPT4gc2hvd1Rvb2x0aXAoZXZlbnQsIGQudGltZXN0YW1wKSlcclxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsICgpID0+IHRvb2x0aXAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgc2luZ2xlIHNvbHZlIGxpbmVcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtc2luZ2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoZCA9PiBuZXdZU2NhbGUoZC50aW1lKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIEFPNSBsaW5lIGFsaWducyBkeW5hbWljYWxseVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1hbzUnKVxyXG4gICAgICAgICAgICAgICAgLmRhdHVtKGFvNS5tYXAoKHZhbCwgaSkgPT4gKHsgdGltZXN0YW1wOiB0aW1lc3RhbXBzW2ldLCB2YWx1ZTogdmFsIH0pKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKGQgPT4gZC52YWx1ZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAueChkID0+IG5ld1hTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KGQgPT4gbmV3WVNjYWxlKGQudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgQU8xMiBsaW5lIGFsaWducyBkeW5hbWljYWxseVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1hbzEyJylcclxuICAgICAgICAgICAgICAgIC5kYXR1bShhbzEyLm1hcCgodmFsLCBpKSA9PiAoeyB0aW1lc3RhbXA6IHRpbWVzdGFtcHNbaV0sIHZhbHVlOiB2YWwgfSkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoZCA9PiBkLnZhbHVlICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoZCA9PiBuZXdZU2NhbGUoZC52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXR1bShwcm9jZXNzZWREYXRhKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZS1zaW5nbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsdWUnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAueChkID0+IHhTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKVxyXG4gICAgICAgICAgICAgICAgLnkoZCA9PiB5U2NhbGUoZC50aW1lKSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtYW81JylcclxuICAgICAgICAgICAgLmRhdGEoW2FvNV0pICAvLyDinIUgVXNlIC5kYXRhKFtdKSBpbnN0ZWFkIG9mIC5kYXR1bSgpXHJcbiAgICAgICAgICAgIC5qb2luKFwicGF0aFwiKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZS1hbzUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2dyZWVuJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgLmRlZmluZWQoKF8sIGkpID0+IGkgPj0gNCAmJiBhbzVbaV0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAueCgoXywgaSkgPT4geFNjYWxlKG5ldyBEYXRlKHRpbWVzdGFtcHNbaV0pKSkgIC8vIOKchSBVc2UgdGltZXN0YW1wc1xyXG4gICAgICAgICAgICAgICAgLnkoKF8sIGkpID0+IHlTY2FsZShhbzVbaV0pKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1hbzEyJylcclxuICAgICAgICAgICAgLmRhdGEoW2FvMTJdKSAgLy8g4pyFIFVzZSAuZGF0YShbXSkgaW5zdGVhZCBvZiAuZGF0dW0oKVxyXG4gICAgICAgICAgICAuam9pbihcInBhdGhcIilcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUtYW8xMicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAncmVkJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgLmRlZmluZWQoKF8sIGkpID0+IGkgPj0gMTEgJiYgYW8xMltpXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIC54KChfLCBpKSA9PiB4U2NhbGUobmV3IERhdGUodGltZXN0YW1wc1tpXSkpKSAgLy8g4pyFIFVzZSB0aW1lc3RhbXBzXHJcbiAgICAgICAgICAgICAgICAueSgoXywgaSkgPT4geVNjYWxlKGFvMTJbaV0pKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCB0b29sdGlwID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdhYnNvbHV0ZSBiZy13aGl0ZSBwLTIgYm9yZGVyIHJvdW5kZWQgc2hhZG93IHRleHQtc20nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJylcclxuICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBzaG93VG9vbHRpcChldmVudCwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgIGlmICghdGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gc2hvd1Rvb2x0aXAgY2FsbGVkIHdpdGggaW52YWxpZCB0aW1lc3RhbXA6XCIsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgYWxsIGRhdGEgcG9pbnRzIHdpdGggdGhlIHNhbWUgdGltZXN0YW1wXHJcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZURhdGEgPSBwcm9jZXNzZWREYXRhLmZpbmQoZCA9PiBkLnRpbWVzdGFtcC5nZXRUaW1lKCkgPT09IHRpbWVzdGFtcC5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBhbzVEYXRhUG9pbnQgPSBhbzVEYXRhLmZpbmQoZCA9PiBkLnRpbWVzdGFtcC5nZXRUaW1lKCkgPT09IHRpbWVzdGFtcC5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBhbzEyRGF0YVBvaW50ID0gYW8xMkRhdGEuZmluZChkID0+IGQudGltZXN0YW1wLmdldFRpbWUoKSA9PT0gdGltZXN0YW1wLmdldFRpbWUoKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzaW5nbGVUaW1lID0gc2luZ2xlRGF0YSA/IHNpbmdsZURhdGEudGltZS50b0ZpeGVkKDIpIDogXCItXCI7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvNVRpbWUgPSBhbzVEYXRhUG9pbnQgPyBhbzVEYXRhUG9pbnQudmFsdWUudG9GaXhlZCgyKSA6IFwiLVwiO1xyXG4gICAgICAgICAgICBjb25zdCBhbzEyVGltZSA9IGFvMTJEYXRhUG9pbnQgPyBhbzEyRGF0YVBvaW50LnZhbHVlLnRvRml4ZWQoMikgOiBcIi1cIjtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5+iIFNob3dpbmcgdG9vbHRpcCBmb3IgdGltZXN0YW1wICR7dGltZXN0YW1wfTogU2luZ2xlPSR7c2luZ2xlVGltZX0sIEFPNT0ke2FvNVRpbWV9LCBBTzEyPSR7YW8xMlRpbWV9YCk7XHJcblxyXG4gICAgICAgICAgICB0b29sdGlwLmh0bWwoYFxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPlNpbmdsZTo8L3N0cm9uZz4gJHtzaW5nbGVUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5BTzU6PC9zdHJvbmc+ICR7YW81VGltZX1zPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+QU8xMjo8L3N0cm9uZz4gJHthbzEyVGltZX1zPC9kaXY+XHJcbiAgICAgICAgICAgIGApXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2ZpeGVkJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsICd3aGl0ZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BhZGRpbmcnLCAnNnB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm9yZGVyJywgJzFweCBzb2xpZCAjY2NjJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm9yZGVyLXJhZGl1cycsICc1cHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3gtc2hhZG93JywgJzJweCAycHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMSknKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCAnMTJweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd6LWluZGV4JywgJzEwMDAnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIC01MCUpJyk7XHJcblxyXG4gICAgICAgICAgICB0b29sdGlwLnN0eWxlKCdsZWZ0JywgYCR7ZXZlbnQucGFnZVggKyAxMn1weGApLnN0eWxlKCd0b3AnLCBgJHtldmVudC5wYWdlWX1weGApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGlkZVRvb2x0aXAoKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdXBkYXRlUGxvdCh4U2NhbGUsIHlTY2FsZSk7ICAvLyDinIUgRm9yY2UgcmVuZGVyIGFmdGVyIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgfSwgMTAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkUG9pbnRzKGRhdGEsIGNvbG9yLCBjbGFzc05hbWUsIHZhbHVlQWNjZXNzb3IsIG1pbkluZGV4LCBsYWJlbCkge1xyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIHRoYXQgd2UgY29ycmVjdGx5IGl0ZXJhdGUgb3ZlciB0aGUgZnVsbCBkYXRhc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkUG9pbnRzID0gZGF0YVxyXG4gICAgICAgICAgICAgICAgLm1hcCgodmFsLCBpKSA9PiAoeyB4OiBpLCB5OiB2YWx1ZUFjY2Vzc29yKGkpIH0pKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihkID0+IGQueSAhPT0gbnVsbCAmJiBkLnggPj0gbWluSW5kZXgpOyAvLyDinIUgUmVtb3ZlZCB4IDwgdGltZXMubGVuZ3RoIGNvbnN0cmFpbnRcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBcXG7wn5+iIEFkZGluZyBQb2ludHMgZm9yICR7bGFiZWx9IHwgQ2xhc3M6ICR7Y2xhc3NOYW1lfSB8IE1pbkluZGV4OiAke21pbkluZGV4fWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFZhbGlkIFBvaW50cyBDb3VudDogJHt2YWxpZFBvaW50cy5sZW5ndGh9YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5ONIEZpcnN0IDUgUG9pbnRzOmAsIHZhbGlkUG9pbnRzLnNsaWNlKDAsIDUpKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk40gTGFzdCA1IFBvaW50czpgLCB2YWxpZFBvaW50cy5zbGljZSgtNSkpO1xyXG5cclxuICAgICAgICAgICAgdmFsaWRQb2ludHMuZm9yRWFjaCgocG9pbnQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgICAgIGDwn5S1ICR7bGFiZWx9IFBvaW50ICR7aSArIG1pbkluZGV4fTogUmF3WD0ke3BvaW50Lnh9LCBTY2FsZWRYPSR7eFNjYWxlKHBvaW50LngpfSwgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFJhd1k9JHtwb2ludC55LnRvRml4ZWQoMyl9LCBTY2FsZWRZPSR7eVNjYWxlKHBvaW50LnkpLnRvRml4ZWQoMil9YFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgZGF0YSBiaW5kaW5nIGlzIGRvbmUgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoYC4ke2NsYXNzTmFtZX1gKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodmFsaWRQb2ludHMsIGQgPT4gZC54KSAvLyBFbnN1cmUgdW5pcXVlIGtleSBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICAuam9pbihcImNpcmNsZVwiKSAvLyBFbnN1cmUgcHJvcGVyIGJpbmRpbmdcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBwb2ludCAke2NsYXNzTmFtZX1gKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiB4U2NhbGUoZC54KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4geVNjYWxlKGQueSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGNvbG9yKVxyXG4gICAgICAgIH1cclxuXHJcbi8vIOKchSBFbnN1cmUgQU81ICYgQU8xMiBwb2ludHMgYXJlIGZ1bGx5IGFkZGVkIGJlZm9yZSB1cGRhdGluZ1xyXG4gICAgICAgIGFkZFBvaW50cyh0aW1lcywgJ2JsdWUnLCAncG9pbnQtc2luZ2xlJywgKGkpID0+IHRpbWVzW2ldLCAwLCBcIlNpbmdsZVwiKTtcclxuICAgICAgICBhZGRQb2ludHMoYW81LCAnZ3JlZW4nLCAncG9pbnQtYW81JywgKGkpID0+IGFvNVtpXSwgNCwgXCJBTzVcIik7XHJcbiAgICAgICAgYWRkUG9pbnRzKGFvMTIsICdyZWQnLCAncG9pbnQtYW8xMicsIChpKSA9PiBhbzEyW2ldLCAxMSwgXCJBTzEyXCIpO1xyXG5cclxuICAgICAgICAvLyBjb25zdCBjb250cm9scyA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCkuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgIC8vICAgICAuYXR0cignY2xhc3MnLCAnYWJzb2x1dGUgdG9wLTIgcmlnaHQtMiBiZy13aGl0ZSBwLTIgcm91bmRlZCBzaGFkb3cnKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcclxuICAgICAgICAvLyAgICAgLnRleHQoJ1ByZXZpb3VzIENsdXN0ZXInKVxyXG4gICAgICAgIC8vICAgICAuc3R5bGUoJ21hcmdpbi1yaWdodCcsICc1cHgnKVxyXG4gICAgICAgIC8vICAgICAuYXR0cignZGlzYWJsZWQnLCBjbHVzdGVycy5sZW5ndGggPT09IDAgfHwgY3VycmVudENsdXN0ZXJJbmRleCA9PT0gMCA/ICdkaXNhYmxlZCcgOiBudWxsKVxyXG4gICAgICAgIC8vICAgICAub24oJ2NsaWNrJywgcHJldkNsdXN0ZXIpO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgIC8vICAgICAudGV4dCgnTmV4dCBDbHVzdGVyJylcclxuICAgICAgICAvLyAgICAgLnN0eWxlKCdtYXJnaW4tcmlnaHQnLCAnNXB4JylcclxuICAgICAgICAvLyAgICAgLmF0dHIoJ2Rpc2FibGVkJywgY2x1c3RlcnMubGVuZ3RoID09PSAwIHx8IGN1cnJlbnRDbHVzdGVySW5kZXggPj0gY2x1c3RlcnMubGVuZ3RoIC0gMSA/ICdkaXNhYmxlZCcgOiBudWxsKVxyXG4gICAgICAgIC8vICAgICAub24oJ2NsaWNrJywgbmV4dENsdXN0ZXIpO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgIC8vICAgICAudGV4dCgnQXV0b3NjYWxlJylcclxuICAgICAgICAvLyAgICAgLnN0eWxlKCdtYXJnaW4tcmlnaHQnLCAnNXB4JylcclxuICAgICAgICAvLyAgICAgLm9uKCdjbGljaycsIGF1dG9zY2FsZSk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBjb250cm9scy5hcHBlbmQoJ2J1dHRvbicpXHJcbiAgICAgICAgLy8gICAgIC50ZXh0KCdTd2l0Y2ggdG8gVGltZSBWaWV3JylcclxuICAgICAgICAvLyAgICAgLnN0eWxlKCdtYXJnaW4tcmlnaHQnLCAnNXB4JylcclxuICAgICAgICAvLyAgICAgLm9uKCdjbGljaycsICgpID0+IHNldFNob3dUaW1lVmlldyh0cnVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXV0b3NjYWxlKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBBdXRvc2NhbGUgdHJpZ2dlcmVkLi4uXCIpO1xyXG5cclxuICAgICAgICBpZiAoIWNsdXN0ZXJzIHx8IGNsdXN0ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gY2x1c3RlcnMgYXZhaWxhYmxlIGZvciBhdXRvc2NhbGUhXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4wgQXV0b3NjYWxpbmcgdG8gZmlyc3QgY2x1c3Rlci4uLlwiKTtcclxuICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KDApO1xyXG5cclxuICAgICAgICBjb25zdCBmaXJzdENsdXN0ZXIgPSBjbHVzdGVyc1swXTtcclxuXHJcbiAgICAgICAgaWYgKCFmaXJzdENsdXN0ZXIgfHwgZmlyc3RDbHVzdGVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gRmlyc3QgY2x1c3RlciBpcyBlbXB0eSwgY2Fubm90IGF1dG9zY2FsZSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld0RvbWFpbiA9IFtcclxuICAgICAgICAgICAgbmV3IERhdGUoZmlyc3RDbHVzdGVyWzBdLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgIG5ldyBEYXRlKGZpcnN0Q2x1c3Rlci5zbGljZSgtMSlbMF0udGltZXN0YW1wKVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFNldHRpbmcgYXV0b3NjYWxlIFgtRG9tYWluIHRvOlwiLCBuZXdEb21haW4pO1xyXG4gICAgICAgIHNldFhEb21haW4obmV3RG9tYWluKTtcclxuICAgICAgICB4RG9tYWluUmVmLmN1cnJlbnQgPSBuZXdEb21haW47XHJcblxyXG4gICAgICAgIC8vIOKchSBGb3JjZSBSZWFjdCB0byB1cGRhdGUgVUkgc3RhdGVcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgc2V0Q2x1c3RlcnMoWy4uLmNsdXN0ZXJzXSk7IC8vIEZvcmNlIHJlLWV2YWx1YXRpb24gb2YgY2x1c3RlcnMgc3RhdGVcclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuZXh0Q2x1c3RlcigpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIuKeoe+4jyBOZXh0IGNsdXN0ZXIgY2xpY2tlZC4uLlwiKTtcclxuICAgICAgICBpZiAoY3VycmVudENsdXN0ZXJJbmRleCA8IGNsdXN0ZXJzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gY3VycmVudENsdXN0ZXJJbmRleCArIDE7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjCBNb3ZpbmcgdG8gbmV4dCBjbHVzdGVyOlwiLCBuZXh0SW5kZXgpO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KG5leHRJbmRleCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0RvbWFpbiA9IFtcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGNsdXN0ZXJzW25leHRJbmRleF1bMF0udGltZXN0YW1wKSxcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGNsdXN0ZXJzW25leHRJbmRleF0uc2xpY2UoLTEpWzBdLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIHNldFhEb21haW4obmV3RG9tYWluKTtcclxuICAgICAgICAgICAgeERvbWFpblJlZi5jdXJyZW50ID0gbmV3RG9tYWluO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBuZXh0IGNsdXN0ZXIgYXZhaWxhYmxlIVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJldkNsdXN0ZXIoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLirIXvuI8gUHJldmlvdXMgY2x1c3RlciBjbGlja2VkLi4uXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50Q2x1c3RlckluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2SW5kZXggPSBjdXJyZW50Q2x1c3RlckluZGV4IC0gMTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OMIE1vdmluZyB0byBwcmV2aW91cyBjbHVzdGVyOlwiLCBwcmV2SW5kZXgpO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KHByZXZJbmRleCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0RvbWFpbiA9IFtcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGNsdXN0ZXJzW3ByZXZJbmRleF1bMF0udGltZXN0YW1wKSxcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGNsdXN0ZXJzW3ByZXZJbmRleF0uc2xpY2UoLTEpWzBdLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIHNldFhEb21haW4obmV3RG9tYWluKTtcclxuICAgICAgICAgICAgeERvbWFpblJlZi5jdXJyZW50ID0gbmV3RG9tYWluO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBwcmV2aW91cyBjbHVzdGVyIGF2YWlsYWJsZSFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LXNjcmVlbiBoLVtjYWxjKDEwMHZoLTEwMHB4KV0gYmctd2hpdGUgcmVsYXRpdmVcIj5cclxuICAgICAgICAgICAgey8qIOKchSBDaGFydCBjb250YWluZXIgKi99XHJcbiAgICAgICAgICAgIDxkaXYgcmVmPXtjb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIj48L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHsvKiDinIUgQ29udHJvbHMgU2VjdGlvbiAqL31cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMiByaWdodC0yIGJnLXdoaXRlIHAtMiByb3VuZGVkIHNoYWRvdyBmbGV4IHNwYWNlLXgtMlwiPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmF5LTIwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktMzAwXCJcclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y2x1c3RlcnMubGVuZ3RoID09PSAwIHx8IGN1cnJlbnRDbHVzdGVySW5kZXggPT09IDB9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0Q3VycmVudENsdXN0ZXJJbmRleChjdXJyZW50Q2x1c3RlckluZGV4IC0gMSl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgUHJldmlvdXMgQ2x1c3RlclxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcblxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmF5LTIwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktMzAwXCJcclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y2x1c3RlcnMubGVuZ3RoID09PSAwIHx8IGN1cnJlbnRDbHVzdGVySW5kZXggPj0gY2x1c3RlcnMubGVuZ3RoIC0gMX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRDdXJyZW50Q2x1c3RlckluZGV4KGN1cnJlbnRDbHVzdGVySW5kZXggKyAxKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICBOZXh0IENsdXN0ZXJcclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG5cclxuICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctZ3JheS0yMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTMwMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gYXV0b3NjYWxlKCl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgQXV0b3NjYWxlXHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuXHJcbiAgICAgICAgICAgICAgICB7Lyog4pyFIFN3aXRjaCBidXR0b24gdG8gZ28gdG8gVHJlbmRBbmFUaW1lLmpzICovfVxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgaG92ZXI6YmctYmx1ZS03MDBcIlxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNob3dUaW1lVmlldyh0cnVlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICBTd2l0Y2ggdG8gVGltZSBWaWV3XHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiVHJlbmRBbmFJbmRleCIsImQzIiwiU29sdmVUaW1lVHJlbmQiLCJzb2x2ZXMiLCJjb250YWluZXJSZWYiLCJjdXJyZW50Q2x1c3RlckluZGV4Iiwic2V0Q3VycmVudENsdXN0ZXJJbmRleCIsImNsdXN0ZXJzIiwic2V0Q2x1c3RlcnMiLCJ4RG9tYWluIiwic2V0WERvbWFpbiIsInhEb21haW5SZWYiLCJzaG93VGltZVZpZXciLCJzZXRTaG93VGltZVZpZXciLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwid2FybiIsImNvbnRhaW5lciIsImN1cnJlbnQiLCJkcmF3U29sdmVUaW1lVHJlbmQiLCJBcnJheSIsImlzQXJyYXkiLCJkZXRlY3RlZENsdXN0ZXJzIiwiZmluZENsdXN0ZXJzIiwiZmlyc3RDbHVzdGVyIiwibmV3RG9tYWluIiwiRGF0ZSIsInRpbWVzdGFtcCIsInNsaWNlIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZVJlc2l6ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwcmV2Q2x1c3RlckluZGV4IiwicHJldlhEb21haW4iLCJzZXRUaW1lb3V0IiwiZGF0YSIsImN1cnJlbnRDbHVzdGVyIiwiaSIsInVuaXF1ZVhWYWx1ZXMiLCJTZXQiLCJtYXAiLCJkIiwic2l6ZSIsInB1c2giLCJjb21wdXRlUm9sbGluZ0F2ZXJhZ2UiLCJ3aW5kb3dTaXplIiwiXyIsImFyciIsInN1YnNldCIsInJlZHVjZSIsInN1bSIsInZhbCIsInNlbGVjdCIsInNlbGVjdEFsbCIsInJlbW92ZSIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzdmciLCJhcHBlbmQiLCJhdHRyIiwicHJvY2Vzc2VkRGF0YSIsInNvbHZlIiwidGltZSIsImZpbHRlciIsInRpbWVzdGFtcHMiLCJ0aW1lcyIsImNsdXN0ZXJTdGFydEluZGV4IiwiY2x1c3RlckVuZEluZGV4IiwiaW5pdGlhbFhEb21haW4iLCJhbzUiLCJhbzEyIiwiYW81RGF0YSIsInZhbHVlIiwiYW8xMkRhdGEiLCJ4U2NhbGUiLCJzY2FsZVRpbWUiLCJkb21haW4iLCJyYW5nZSIsInlTY2FsZSIsInNjYWxlTGluZWFyIiwibWF4IiwibWluIiwieEF4aXMiLCJjYWxsIiwiYXhpc0JvdHRvbSIsInRpY2tGb3JtYXQiLCJ0aW1lRm9ybWF0IiwibGFzdERhdGUiLCJlYWNoIiwibm9kZXMiLCJjdXJyZW50VGV4dCIsImRhdGVTdHIiLCJ0ZXh0IiwieUF4aXMiLCJheGlzTGVmdCIsImdyaWRHcm91cCIsImRyYXdHcmlkIiwidGlja3MiLCJlbnRlciIsInpvb20iLCJvbiIsImV2ZW50IiwidHJhbnNmb3JtIiwibmV3WFNjYWxlIiwicmVzY2FsZVgiLCJuZXdZU2NhbGUiLCJyZXNjYWxlWSIsInVwZGF0ZVBsb3QiLCJsYXN0Wm9vbURhdGUiLCJsZWdlbmQiLCJsZWdlbmRJdGVtcyIsImNvbG9yIiwibGFiZWwiLCJmb3JFYWNoIiwiaXRlbSIsImF1dG9zY2FsZSIsImFvNVNlbGVjdGlvbiIsImpvaW4iLCJzaG93VG9vbHRpcCIsInRvb2x0aXAiLCJzdHlsZSIsImFvMTJTZWxlY3Rpb24iLCJ4IiwieSIsImxpbmUiLCJjdXJ2ZSIsImN1cnZlTW9ub3RvbmVYIiwiZGF0dW0iLCJkZWZpbmVkIiwic2luZ2xlRGF0YSIsImZpbmQiLCJnZXRUaW1lIiwiYW81RGF0YVBvaW50IiwiYW8xMkRhdGFQb2ludCIsInNpbmdsZVRpbWUiLCJ0b0ZpeGVkIiwiYW81VGltZSIsImFvMTJUaW1lIiwiaHRtbCIsInBhZ2VYIiwicGFnZVkiLCJoaWRlVG9vbHRpcCIsImFkZFBvaW50cyIsImNsYXNzTmFtZSIsInZhbHVlQWNjZXNzb3IiLCJtaW5JbmRleCIsInZhbGlkUG9pbnRzIiwicG9pbnQiLCJuZXh0Q2x1c3RlciIsIm5leHRJbmRleCIsInByZXZDbHVzdGVyIiwicHJldkluZGV4IiwiZGl2IiwicmVmIiwiYnV0dG9uIiwiZGlzYWJsZWQiLCJvbkNsaWNrIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\n"));

/***/ })

});