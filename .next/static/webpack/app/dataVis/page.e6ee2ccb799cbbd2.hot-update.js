"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dataVis/page",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"4d430c78061e\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjRkNDMwYzc4MDYxZVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js":
/*!******************************************!*\
  !*** ./src/app/dataVis/TrendAnaIndex.js ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrendAnaTime */ \"(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__]);\n_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\n\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [showTimeView, setShowTimeView] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return; // 🔥 Ensure solves is valid\n            if (containerRef.current) {\n                drawSolveTimeTrend(solves);\n                window.addEventListener('resize', handleResize);\n            }\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]);\n    if (showTimeView) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            solves: solves\n        }, void 0, false, {\n            fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaIndex.js\",\n            lineNumber: 23,\n            columnNumber: 16\n        }, this);\n    }\n    function handleResize() {\n        if (containerRef.current) {\n            drawSolveTimeTrend(solves);\n        }\n    }\n    function computeRollingAverage(data, windowSize) {\n        const rollingAvg = data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null;\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n        console.log(\"Window Size: \".concat(windowSize));\n        console.log(\"Original Data Length: \".concat(data.length));\n        console.log(\"Rolling Average (\".concat(windowSize, \") Length: \").concat(rollingAvg.length));\n        console.log(\"First Values:\", rollingAvg.slice(0, 15)); // Check first few values\n        console.log(\"Last Values:\", rollingAvg.slice(-15)); // Check last few values\n        return rollingAvg;\n    }\n    function drawSolveTimeTrend(data) {\n        if (!containerRef.current) return;\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        const times = data.map((solve)=>solve.time / 1000);\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        let xScale = d3.scaleLinear().domain([\n            0,\n            times.length - 1\n        ]).range([\n            50,\n            width - 50\n        ]);\n        let yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]) // Flip domain to match SVG coords\n        .range([\n            50,\n            height - 50\n        ]); // Ensure bottom is lower on the screen\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale));\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom().scaleExtent([\n            0.5,\n            5\n        ]).translateExtent([\n            [\n                0,\n                0\n            ],\n            [\n                width,\n                height\n            ]\n        ]).on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale));\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // ✅ Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 80)\")); // ⬇ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        function autoscale(event) {\n            event.preventDefault(); // Stop default zoom behavior\n            event.stopPropagation(); // Prevent further event propagation\n            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity); // Reset to original zoom state\n        }\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"🔄 Updating Plot with New Scales:\");\n            console.log(\"🟢 New X Scale Domain:\", newXScale.domain());\n            console.log(\"🟢 New Y Scale Domain:\", newYScale.domain());\n            // ✅ Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            console.log(\"✔ Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"✔ Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"⚠️ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"⚠️ No AO12 points found in updatePlot!\");\n            // ✅ Update all AO5 points\n            ao5Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // ✅ Update all AO12 points\n            ao12Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // ✅ Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // ✅ Update single solve points\n            svg.selectAll('.point-single').attr('cx', (_, i)=>newXScale(i)).attr('cy', (_, i)=>newYScale(times[i]));\n            // ✅ Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(times[i])));\n            // ✅ Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao5[i])));\n            // ✅ Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao12[i])));\n        }\n        svg.append('path').datum(times).attr('class', 'line line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao5).attr('class', 'line line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao12).attr('class', 'line line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2);\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, i) {\n            var _times_i, _ao5_i, _ao12_i;\n            const singleTime = (_times_i = times[i]) === null || _times_i === void 0 ? void 0 : _times_i.toFixed(2);\n            const ao5Time = ao5[i] !== null ? (_ao5_i = ao5[i]) === null || _ao5_i === void 0 ? void 0 : _ao5_i.toFixed(2) : '-';\n            const ao12Time = ao12[i] !== null ? (_ao12_i = ao12[i]) === null || _ao12_i === void 0 ? void 0 : _ao12_i.toFixed(2) : '-';\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // ✅ Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // ✅ Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // ✅ Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"✔ Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color).on('mouseover', (event, d)=>showTooltip(event, d.x)).on('mouseout', hideTooltip);\n        }\n        // ✅ Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n        const controls = d3.select(containerRef.current).append('div').attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow');\n        controls.append('button').text('Autoscale').style('margin-right', '5px').on('click', autoscale);\n        controls.append('button').text('Switch to Time View').style('margin-right', '5px').on('click', ()=>setShowTimeView(true));\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaIndex.js\",\n        lineNumber: 362,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"ndK8gk+SELWIn4XZP6sgEtccqj4=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYUluZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFb0Q7QUFDcEQsTUFBTUcsS0FBSyxNQUFNLDRNQUFZO0FBQ2E7QUFFM0IsU0FBU0UsZUFBZSxLQUFVO1FBQVYsRUFBRUMsTUFBTSxFQUFFLEdBQVY7O0lBQ25DLE1BQU1DLGVBQWVOLDZDQUFNQSxDQUFDO0lBRTVCLE1BQU0sQ0FBQ08sY0FBY0MsZ0JBQWdCLEdBQUdQLCtDQUFRQSxDQUFDO0lBRWpERixnREFBU0E7b0NBQUM7WUFDTixJQUFJLENBQUNNLFVBQVUsQ0FBQ0ksTUFBTUMsT0FBTyxDQUFDTCxXQUFXQSxPQUFPTSxNQUFNLEtBQUssR0FBRyxRQUFRLDRCQUE0QjtZQUNsRyxJQUFJTCxhQUFhTSxPQUFPLEVBQUU7Z0JBQ3RCQyxtQkFBbUJSO2dCQUNuQlMsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUM7WUFDdEM7WUFFQTs0Q0FBTyxJQUFNRixPQUFPRyxtQkFBbUIsQ0FBQyxVQUFVRDs7UUFDdEQ7bUNBQUc7UUFBQ1g7S0FBTztJQUVYLElBQUlFLGNBQWM7UUFDZCxxQkFBTyw4REFBQ0oscURBQVlBO1lBQUNFLFFBQVFBOzs7Ozs7SUFDakM7SUFFQSxTQUFTVztRQUNMLElBQUlWLGFBQWFNLE9BQU8sRUFBRTtZQUN0QkMsbUJBQW1CUjtRQUN2QjtJQUNKO0lBRUEsU0FBU2Esc0JBQXNCQyxJQUFJLEVBQUVDLFVBQVU7UUFDM0MsTUFBTUMsYUFBYUYsS0FBS0csR0FBRyxDQUFDLENBQUNDLEdBQUdDLEdBQUdDO1lBQy9CLElBQUlELElBQUlKLGFBQWEsR0FBRyxPQUFPO1lBQy9CLE1BQU1NLFNBQVNELElBQUlFLEtBQUssQ0FBQ0gsSUFBS0osQ0FBQUEsYUFBYSxJQUFJSSxJQUFJO1lBQ25ELE9BQU9FLE9BQU9FLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFNQyxLQUFLLEtBQUtKLE9BQU9mLE1B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LENBQUMsU0FBUyxJQUFNN0QsZ0JBQWdCO0lBQzNDO0lBRUEscUJBQ0ksOERBQUNtSDtRQUNHQyxLQUFLdEg7UUFDTDZHLFdBQVU7Ozs7OztBQUd0QjtHQXhXd0IvRztLQUFBQSIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxTclxcMjAyNF9DX1Rlcm1cXENTNDI0MVxcSFdcXGZpbmFsLXByb2plY3Qta2VybWl0LXRoZS1mcm9nXFxzcmNcXGFwcFxcZGF0YVZpc1xcVHJlbmRBbmFJbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmNvbnN0IGQzID0gYXdhaXQgaW1wb3J0KCdkMycpO1xyXG5pbXBvcnQgVHJlbmRBbmFUaW1lIGZyb20gJy4vVHJlbmRBbmFUaW1lJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNvbHZlVGltZVRyZW5kKHsgc29sdmVzIH0pIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcclxuXHJcbiAgICBjb25zdCBbc2hvd1RpbWVWaWV3LCBzZXRTaG93VGltZVZpZXddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzb2x2ZXMgfHwgIUFycmF5LmlzQXJyYXkoc29sdmVzKSB8fCBzb2x2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIPCflKUgRW5zdXJlIHNvbHZlcyBpcyB2YWxpZFxyXG4gICAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBkcmF3U29sdmVUaW1lVHJlbmQoc29sdmVzKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICB9LCBbc29sdmVzXSk7XHJcblxyXG4gICAgaWYgKHNob3dUaW1lVmlldykge1xyXG4gICAgICAgIHJldHVybiA8VHJlbmRBbmFUaW1lIHNvbHZlcz17c29sdmVzfSAvPjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGRyYXdTb2x2ZVRpbWVUcmVuZChzb2x2ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UoZGF0YSwgd2luZG93U2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IHJvbGxpbmdBdmcgPSBkYXRhLm1hcCgoXywgaSwgYXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgd2luZG93U2l6ZSAtIDEpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBzdWJzZXQgPSBhcnIuc2xpY2UoaSAtICh3aW5kb3dTaXplIC0gMSksIGkgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnNldC5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gc3Vic2V0Lmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFdpbmRvdyBTaXplOiAke3dpbmRvd1NpemV9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYE9yaWdpbmFsIERhdGEgTGVuZ3RoOiAke2RhdGEubGVuZ3RofWApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBSb2xsaW5nIEF2ZXJhZ2UgKCR7d2luZG93U2l6ZX0pIExlbmd0aDogJHtyb2xsaW5nQXZnLmxlbmd0aH1gKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgRmlyc3QgVmFsdWVzOmAsIHJvbGxpbmdBdmcuc2xpY2UoMCwgMTUpKTsgLy8gQ2hlY2sgZmlyc3QgZmV3IHZhbHVlc1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBMYXN0IFZhbHVlczpgLCByb2xsaW5nQXZnLnNsaWNlKC0xNSkpOyAvLyBDaGVjayBsYXN0IGZldyB2YWx1ZXNcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvbGxpbmdBdmc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NvbHZlVGltZVRyZW5kKGRhdGEpIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCk7XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgfHwgNTAwO1xyXG5cclxuICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXIuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKVxyXG4gICAgICAgICAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVzID0gZGF0YS5tYXAoKHNvbHZlKSA9PiBzb2x2ZS50aW1lIC8gMTAwMCk7XHJcbiAgICAgICAgY29uc3QgYW81ID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCA1KTtcclxuICAgICAgICBjb25zdCBhbzEyID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCAxMik7XHJcblxyXG4gICAgICAgIGxldCB4U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oWzAsIHRpbWVzLmxlbmd0aCAtIDFdKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCB3aWR0aCAtIDUwXSk7XHJcblxyXG4gICAgICAgIGxldCB5U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oW2QzLm1heCh0aW1lcyksIGQzLm1pbih0aW1lcyldKSAgLy8gRmxpcCBkb21haW4gdG8gbWF0Y2ggU1ZHIGNvb3Jkc1xyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCBoZWlnaHQgLSA1MF0pOyAvLyBFbnN1cmUgYm90dG9tIGlzIGxvd2VyIG9uIHRoZSBzY3JlZW5cclxuXHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3gtYXhpcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7aGVpZ2h0IC0gNTB9KWApXHJcbiAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNCb3R0b20oeFNjYWxlKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5LWF4aXMnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSg1MCwgMClgKVxyXG4gICAgICAgICAgICAuY2FsbChkMy5heGlzTGVmdCh5U2NhbGUpKTtcclxuXHJcbiAgICAgICAgY29uc3QgZ3JpZEdyb3VwID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2dyaWQnKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd0dyaWQoeFNjYWxlLCB5U2NhbGUpIHtcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBncmlkIGxpbmVzXHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJy5ob3Jpem9udGFsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoeVNjYWxlLnRpY2tzKDEwKSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdob3Jpem9udGFsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZCA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBkID0+IHlTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICc0LDQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIGdyaWQgbGluZXNcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnLnZlcnRpY2FsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoeFNjYWxlLnRpY2tzKDEwKSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZXJ0aWNhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4geFNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiB4U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGhlaWdodCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjY2NjJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgJzQsNCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHJhd0dyaWQoeFNjYWxlLCB5U2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCB6b29tID0gZDMuem9vbSgpXHJcbiAgICAgICAgICAgIC5zY2FsZUV4dGVudChbMC41LCA1XSlcclxuICAgICAgICAgICAgLnRyYW5zbGF0ZUV4dGVudChbWzAsIDBdLCBbd2lkdGgsIGhlaWdodF1dKVxyXG4gICAgICAgICAgICAub24oJ3pvb20nLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1hTY2FsZSA9IHRyYW5zZm9ybS5yZXNjYWxlWCh4U2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3WVNjYWxlID0gdHJhbnNmb3JtLnJlc2NhbGVZKHlTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBwbG90c1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlUGxvdChuZXdYU2NhbGUsIG5ld1lTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGF4ZXNcclxuICAgICAgICAgICAgICAgIHhBeGlzLmNhbGwoZDMuYXhpc0JvdHRvbShuZXdYU2NhbGUpKTtcclxuICAgICAgICAgICAgICAgIHlBeGlzLmNhbGwoZDMuYXhpc0xlZnQobmV3WVNjYWxlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdyaWQgd2l0aCBuZXcgc2NhbGVzXHJcbiAgICAgICAgICAgICAgICBkcmF3R3JpZChuZXdYU2NhbGUsIG5ld1lTY2FsZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzdmcuY2FsbCh6b29tKTtcclxuXHJcbiAgICAgICAgLy8g4pyFIEFkZCBMZWdlbmRzIChCZWxvdyBBdXRvc2NhbGUgQnV0dG9uKVxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3dpZHRoIC0gMTIwfSwgODApYCk7IC8vIOKshyBNb3ZlcyBsZWdlbmQgbG93ZXIgdW5kZXIgYnV0dG9uXHJcblxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1zID0gW1xyXG4gICAgICAgICAgICB7IGNvbG9yOiAnYmx1ZScsIGxhYmVsOiAnU2luZ2xlJyB9LFxyXG4gICAgICAgICAgICB7IGNvbG9yOiAnZ3JlZW4nLCBsYWJlbDogJ0FPNScgfSxcclxuICAgICAgICAgICAgeyBjb2xvcjogJ3JlZCcsIGxhYmVsOiAnQU8xMicgfVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGxlZ2VuZEl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcclxuICAgICAgICAgICAgbGVnZW5kLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGkgKiAyMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDE1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDE1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBpdGVtLmNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAyMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaSAqIDIwICsgMTIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzEycHgnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoaXRlbS5sYWJlbCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGF1dG9zY2FsZShldmVudCkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBTdG9wIGRlZmF1bHQgem9vbSBiZWhhdmlvclxyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudCBmdXJ0aGVyIGV2ZW50IHByb3BhZ2F0aW9uXHJcblxyXG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxyXG4gICAgICAgICAgICAgICAgLmNhbGwoem9vbS50cmFuc2Zvcm0sIGQzLnpvb21JZGVudGl0eSk7IC8vIFJlc2V0IHRvIG9yaWdpbmFsIHpvb20gc3RhdGVcclxuICAgICAgICB9XHJcblxyXG4vLyBFbnN1cmUgZXZlbnQgaXMgcGFzc2VkIHRvIGF1dG9zY2FsZVxyXG4gICAgICAgIHN2Zy5vbignZGJsY2xpY2snLCAoZXZlbnQpID0+IGF1dG9zY2FsZShldmVudCkpO1xyXG5cclxuLy8gQWxzbyBleHBsaWNpdGx5IGRpc2FibGUgem9vbSBvbiBkb3VibGUtY2xpY2sgdG8gcHJldmVudCB6b29taW5nIGluXHJcbiAgICAgICAgc3ZnLmNhbGwoem9vbSkub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVQbG90KG5ld1hTY2FsZSwgbmV3WVNjYWxlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBVcGRhdGluZyBQbG90IHdpdGggTmV3IFNjYWxlczpcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+foiBOZXcgWCBTY2FsZSBEb21haW46XCIsIG5ld1hTY2FsZS5kb21haW4oKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+foiBOZXcgWSBTY2FsZSBEb21haW46XCIsIG5ld1lTY2FsZS5kb21haW4oKSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIHRoYXQgdGhlIEFPNSBhbmQgQU8xMiBwb2ludHMgYXJlIGNvcnJlY3RseSBib3VuZFxyXG4gICAgICAgICAgICBjb25zdCBhbzVTZWxlY3Rpb24gPSBzdmcuc2VsZWN0QWxsKCcucG9pbnQtYW81JylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGFvNS5tYXAoKHZhbCwgaSkgPT4gKHsgeDogaSwgeTogdmFsIH0pKSwgZCA9PiBkLngpOyAvLyBFbnN1cmUgdW5pcXVlIGtleSBiaW5kaW5nXHJcblxyXG4gICAgICAgICAgICBjb25zdCBhbzEyU2VsZWN0aW9uID0gc3ZnLnNlbGVjdEFsbCgnLnBvaW50LWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoYW8xMi5tYXAoKHZhbCwgaSkgPT4gKHsgeDogaSwgeTogdmFsIH0pKSwgZCA9PiBkLngpOyAvLyBFbnN1cmUgdW5pcXVlIGtleSBiaW5kaW5nXHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFRvdGFsIEFPNSBQb2ludHMgU2VsZWN0ZWQ6ICR7YW81U2VsZWN0aW9uLnNpemUoKX0gKEV4cGVjdGVkOiAke2FvNS5sZW5ndGh9KWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFRvdGFsIEFPMTIgUG9pbnRzIFNlbGVjdGVkOiAke2FvMTJTZWxlY3Rpb24uc2l6ZSgpfSAoRXhwZWN0ZWQ6ICR7YW8xMi5sZW5ndGh9KWApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFvNVNlbGVjdGlvbi5zaXplKCkgPT09IDApIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBBTzUgcG9pbnRzIGZvdW5kIGluIHVwZGF0ZVBsb3QhXCIpO1xyXG4gICAgICAgICAgICBpZiAoYW8xMlNlbGVjdGlvbi5zaXplKCkgPT09IDApIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBBTzEyIHBvaW50cyBmb3VuZCBpbiB1cGRhdGVQbG90IVwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgYWxsIEFPNSBwb2ludHNcclxuICAgICAgICAgICAgYW81U2VsZWN0aW9uLmF0dHIoJ2N4JywgZCA9PiBuZXdYU2NhbGUoZC54KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4gbmV3WVNjYWxlKGQueSkpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBhbGwgQU8xMiBwb2ludHNcclxuICAgICAgICAgICAgYW8xMlNlbGVjdGlvbi5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKGQueCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBEZWJ1Z2dpbmc6IEVuc3VyZSBsYXN0IEFPNSAmIEFPMTIgcG9pbnRzIHVwZGF0ZSBjb3JyZWN0bHlcclxuICAgICAgICAgICAgYW81U2VsZWN0aW9uLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGFvNS5sZW5ndGggLSA0KSB7IC8vIFVzZSBgYW81Lmxlbmd0aGAgdG8gY29ycmVjdGx5IGl0ZXJhdGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+foiBBTzUgUG9pbnQgJHtpfTogeD0ke25ld1hTY2FsZShkLngpfSwgeT0ke25ld1lTY2FsZShkLnkpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGFvMTJTZWxlY3Rpb24uZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYW8xMi5sZW5ndGggLSAxMikgeyAvLyBVc2UgYGFvMTIubGVuZ3RoYCB0byBjb3JyZWN0bHkgaXRlcmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S0IEFPMTIgUG9pbnQgJHtpfTogeD0ke25ld1hTY2FsZShkLngpfSwgeT0ke25ld1lTY2FsZShkLnkpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgc2luZ2xlIHNvbHZlIHBvaW50c1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcucG9pbnQtc2luZ2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIChfLCBpKSA9PiBuZXdYU2NhbGUoaSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCAoXywgaSkgPT4gbmV3WVNjYWxlKHRpbWVzW2ldKSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIHNpbmdsZSBzb2x2ZSBsaW5lXHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLXNpbmdsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAueCgoXywgaSkgPT4gbmV3WFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiBuZXdZU2NhbGUodGltZXNbaV0pKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgQU81IGxpbmUgYWxpZ25zIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvNScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZCgoXywgaSkgPT4gaSA+PSA0ICYmIGFvNVtpXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAueCgoXywgaSkgPT4gbmV3WFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiBuZXdZU2NhbGUoYW81W2ldKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIEFPMTIgbGluZSBhbGlnbnMgZHluYW1pY2FsbHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtYW8xMicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZCgoXywgaSkgPT4gaSA+PSAxMSAmJiBhbzEyW2ldICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KChfLCBpKSA9PiBuZXdYU2NhbGUoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoKF8sIGkpID0+IG5ld1lTY2FsZShhbzEyW2ldKSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKHRpbWVzKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZSBsaW5lLXNpbmdsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmx1ZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XHJcblxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZGF0dW0oYW81KVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZSBsaW5lLWFvNScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnZ3JlZW4nKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKGFvMTIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lIGxpbmUtYW8xMicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAncmVkJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCkuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYWJzb2x1dGUgYmctd2hpdGUgcC0yIGJvcmRlciByb3VuZGVkIHNoYWRvdyB0ZXh0LXNtJylcclxuICAgICAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpXHJcbiAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZXZlbnQsIGkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2luZ2xlVGltZSA9IHRpbWVzW2ldPy50b0ZpeGVkKDIpO1xyXG4gICAgICAgICAgICBjb25zdCBhbzVUaW1lID0gYW81W2ldICE9PSBudWxsID8gYW81W2ldPy50b0ZpeGVkKDIpIDogJy0nO1xyXG4gICAgICAgICAgICBjb25zdCBhbzEyVGltZSA9IGFvMTJbaV0gIT09IG51bGwgPyBhbzEyW2ldPy50b0ZpeGVkKDIpIDogJy0nO1xyXG5cclxuICAgICAgICAgICAgdG9vbHRpcC5odG1sKGBcclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5TaW5nbGU6PC9zdHJvbmc+ICR7c2luZ2xlVGltZX1zPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+QU81Ojwvc3Ryb25nPiAke2FvNVRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPkFPMTI6PC9zdHJvbmc+ICR7YW8xMlRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICBgKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdmaXhlZCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nJywgJzZweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JvcmRlcicsICcxcHggc29saWQgI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JvcmRlci1yYWRpdXMnLCAnNXB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm94LXNoYWRvdycsICcycHggMnB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjEpJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnei1pbmRleCcsICcxMDAwJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAtNTAlKScpO1xyXG5cclxuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZSgnbGVmdCcsIGAke2V2ZW50LnBhZ2VYICsgMTJ9cHhgKS5zdHlsZSgndG9wJywgYCR7ZXZlbnQucGFnZVl9cHhgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwKCkge1xyXG4gICAgICAgICAgICB0b29sdGlwLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVBsb3QoeFNjYWxlLCB5U2NhbGUpOyAgLy8g4pyFIEZvcmNlIHJlbmRlciBhZnRlciBpbml0aWFsaXphdGlvblxyXG4gICAgICAgIH0sIDEwMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZFBvaW50cyhkYXRhLCBjb2xvciwgY2xhc3NOYW1lLCB2YWx1ZUFjY2Vzc29yLCBtaW5JbmRleCwgbGFiZWwpIHtcclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSB0aGF0IHdlIGNvcnJlY3RseSBpdGVyYXRlIG92ZXIgdGhlIGZ1bGwgZGF0YXNldFxyXG4gICAgICAgICAgICBjb25zdCB2YWxpZFBvaW50cyA9IGRhdGFcclxuICAgICAgICAgICAgICAgIC5tYXAoKHZhbCwgaSkgPT4gKHsgeDogaSwgeTogdmFsdWVBY2Nlc3NvcihpKSB9KSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkLnkgIT09IG51bGwgJiYgZC54ID49IG1pbkluZGV4KTsgLy8g4pyFIFJlbW92ZWQgeCA8IHRpbWVzLmxlbmd0aCBjb25zdHJhaW50XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+foiBBZGRpbmcgUG9pbnRzIGZvciAke2xhYmVsfSB8IENsYXNzOiAke2NsYXNzTmFtZX0gfCBNaW5JbmRleDogJHttaW5JbmRleH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBWYWxpZCBQb2ludHMgQ291bnQ6ICR7dmFsaWRQb2ludHMubGVuZ3RofWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjSBGaXJzdCA1IFBvaW50czpgLCB2YWxpZFBvaW50cy5zbGljZSgwLCA1KSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5ONIExhc3QgNSBQb2ludHM6YCwgdmFsaWRQb2ludHMuc2xpY2UoLTUpKTtcclxuXHJcbiAgICAgICAgICAgIHZhbGlkUG9pbnRzLmZvckVhY2goKHBvaW50LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICBg8J+UtSAke2xhYmVsfSBQb2ludCAke2kgKyBtaW5JbmRleH06IFJhd1g9JHtwb2ludC54fSwgU2NhbGVkWD0ke3hTY2FsZShwb2ludC54KX0sIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBSYXdZPSR7cG9pbnQueS50b0ZpeGVkKDMpfSwgU2NhbGVkWT0ke3lTY2FsZShwb2ludC55KS50b0ZpeGVkKDIpfWBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIGRhdGEgYmluZGluZyBpcyBkb25lIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKGAuJHtjbGFzc05hbWV9YClcclxuICAgICAgICAgICAgICAgIC5kYXRhKHZhbGlkUG9pbnRzLCBkID0+IGQueCkgLy8gRW5zdXJlIHVuaXF1ZSBrZXkgYmluZGluZ1xyXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJjaXJjbGVcIikgLy8gRW5zdXJlIHByb3BlciBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgcG9pbnQgJHtjbGFzc05hbWV9YClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4geFNjYWxlKGQueCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IHlTY2FsZShkLnkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb2xvcilcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgKGV2ZW50LCBkKSA9PiBzaG93VG9vbHRpcChldmVudCwgZC54KSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBoaWRlVG9vbHRpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuLy8g4pyFIEVuc3VyZSBBTzUgJiBBTzEyIHBvaW50cyBhcmUgZnVsbHkgYWRkZWQgYmVmb3JlIHVwZGF0aW5nXHJcbiAgICAgICAgYWRkUG9pbnRzKHRpbWVzLCAnYmx1ZScsICdwb2ludC1zaW5nbGUnLCAoaSkgPT4gdGltZXNbaV0sIDAsIFwiU2luZ2xlXCIpO1xyXG4gICAgICAgIGFkZFBvaW50cyhhbzUsICdncmVlbicsICdwb2ludC1hbzUnLCAoaSkgPT4gYW81W2ldLCA0LCBcIkFPNVwiKTtcclxuICAgICAgICBhZGRQb2ludHMoYW8xMiwgJ3JlZCcsICdwb2ludC1hbzEyJywgKGkpID0+IGFvMTJbaV0sIDExLCBcIkFPMTJcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdhYnNvbHV0ZSB0b3AtMiByaWdodC0yIGJnLXdoaXRlIHAtMiByb3VuZGVkIHNoYWRvdycpO1xyXG5cclxuICAgICAgICBjb250cm9scy5hcHBlbmQoJ2J1dHRvbicpXHJcbiAgICAgICAgICAgIC50ZXh0KCdBdXRvc2NhbGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmdpbi1yaWdodCcsICc1cHgnKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgYXV0b3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgICAgICAudGV4dCgnU3dpdGNoIHRvIFRpbWUgVmlldycpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLXJpZ2h0JywgJzVweCcpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiBzZXRTaG93VGltZVZpZXcodHJ1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICByZWY9e2NvbnRhaW5lclJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC1bY2FsYygxMDB2aC0xMDBweCldIGJnLXdoaXRlIHJlbGF0aXZlXCJcclxuICAgICAgICA+PC9kaXY+XHJcbiAgICApO1xyXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiZDMiLCJUcmVuZEFuYVRpbWUiLCJTb2x2ZVRpbWVUcmVuZCIsInNvbHZlcyIsImNvbnRhaW5lclJlZiIsInNob3dUaW1lVmlldyIsInNldFNob3dUaW1lVmlldyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImN1cnJlbnQiLCJkcmF3U29sdmVUaW1lVHJlbmQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlUmVzaXplIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbXB1dGVSb2xsaW5nQXZlcmFnZSIsImRhdGEiLCJ3aW5kb3dTaXplIiwicm9sbGluZ0F2ZyIsIm1hcCIsIl8iLCJpIiwiYXJyIiwic3Vic2V0Iiwic2xpY2UiLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJjb25zb2xlIiwibG9nIiwiY29udGFpbmVyIiwic2VsZWN0Iiwic2VsZWN0QWxsIiwicmVtb3ZlIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsInN2ZyIsImFwcGVuZCIsImF0dHIiLCJ0aW1lcyIsInNvbHZlIiwidGltZSIsImFvNSIsImFvMTIiLCJ4U2NhbGUiLCJzY2FsZUxpbmVhciIsImRvbWFpbiIsInJhbmdlIiwieVNjYWxlIiwibWF4IiwibWluIiwieEF4aXMiLCJjYWxsIiwiYXhpc0JvdHRvbSIsInlBeGlzIiwiYXhpc0xlZnQiLCJncmlkR3JvdXAiLCJkcmF3R3JpZCIsInRpY2tzIiwiZW50ZXIiLCJkIiwiem9vbSIsInNjYWxlRXh0ZW50IiwidHJhbnNsYXRlRXh0ZW50Iiwib24iLCJldmVudCIsInRyYW5zZm9ybSIsIm5ld1hTY2FsZSIsInJlc2NhbGVYIiwibmV3WVNjYWxlIiwicmVzY2FsZVkiLCJ1cGRhdGVQbG90IiwibGVnZW5kIiwibGVnZW5kSXRlbXMiLCJjb2xvciIsImxhYmVsIiwiZm9yRWFjaCIsIml0ZW0iLCJ0ZXh0IiwiYXV0b3NjYWxlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJ0cmFuc2l0aW9uIiwiZHVyYXRpb24iLCJ6b29tSWRlbnRpdHkiLCJhbzVTZWxlY3Rpb24iLCJ4IiwieSIsImFvMTJTZWxlY3Rpb24iLCJzaXplIiwid2FybiIsImVhY2giLCJsaW5lIiwiY3VydmUiLCJjdXJ2ZU1vbm90b25lWCIsImRlZmluZWQiLCJkYXR1bSIsInRvb2x0aXAiLCJzdHlsZSIsInNob3dUb29sdGlwIiwic2luZ2xlVGltZSIsInRvRml4ZWQiLCJhbzVUaW1lIiwiYW8xMlRpbWUiLCJodG1sIiwicGFnZVgiLCJwYWdlWSIsImhpZGVUb29sdGlwIiwic2V0VGltZW91dCIsImFkZFBvaW50cyIsImNsYXNzTmFtZSIsInZhbHVlQWNjZXNzb3IiLCJtaW5JbmRleCIsInZhbGlkUG9pbnRzIiwiZmlsdGVyIiwicG9pbnQiLCJqb2luIiwiY29udHJvbHMiLCJkaXYiLCJyZWYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js\n"));

/***/ })

});