"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dataVis/page",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2551dcdb1d08\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjI1NTFkY2RiMWQwOFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js":
/*!******************************************!*\
  !*** ./src/app/dataVis/TrendAnaIndex.js ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return; // ðŸ”¥ Ensure solves is valid\n            if (containerRef.current) {\n                drawSolveTimeTrend(solves);\n                window.addEventListener('resize', handleResize);\n            }\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]);\n    function handleResize() {\n        if (containerRef.current) {\n            drawSolveTimeTrend(solves);\n        }\n    }\n    function computeRollingAverage(data, windowSize) {\n        const rollingAvg = data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null;\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n        console.log(\"Window Size: \".concat(windowSize));\n        console.log(\"Original Data Length: \".concat(data.length));\n        console.log(\"Rolling Average (\".concat(windowSize, \") Length: \").concat(rollingAvg.length));\n        console.log(\"First Values:\", rollingAvg.slice(0, 15)); // Check first few values\n        console.log(\"Last Values:\", rollingAvg.slice(-15)); // Check last few values\n        return rollingAvg;\n    }\n    function drawSolveTimeTrend(data) {\n        if (!containerRef.current) return;\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        const times = data.map((solve)=>solve.time / 1000);\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        let xScale = d3.scaleLinear().domain([\n            0,\n            times.length - 1\n        ]).range([\n            50,\n            width - 50\n        ]);\n        let yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]) // Flip domain to match SVG coords\n        .range([\n            50,\n            height - 50\n        ]); // Ensure bottom is lower on the screen\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale));\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom().scaleExtent([\n            0.5,\n            5\n        ]).translateExtent([\n            [\n                0,\n                0\n            ],\n            [\n                width,\n                height\n            ]\n        ]).on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale));\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // âœ… Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 80)\")); // â¬‡ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        function autoscale(event) {\n            event.preventDefault(); // Stop default zoom behavior\n            event.stopPropagation(); // Prevent further event propagation\n            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity); // Reset to original zoom state\n        }\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"ðŸ”„ Updating Plot with New Scales:\");\n            console.log(\"ðŸŸ¢ New X Scale Domain:\", newXScale.domain());\n            console.log(\"ðŸŸ¢ New Y Scale Domain:\", newYScale.domain());\n            // âœ… Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            console.log(\"âœ” Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"âœ” Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"âš ï¸ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"âš ï¸ No AO12 points found in updatePlot!\");\n            // âœ… Update all AO5 points\n            ao5Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // âœ… Update all AO12 points\n            ao12Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // âœ… Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // âœ… Update single solve points\n            svg.selectAll('.point-single').attr('cx', (_, i)=>newXScale(i)).attr('cy', (_, i)=>newYScale(times[i]));\n            // âœ… Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(times[i])));\n            // âœ… Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao5[i])));\n            // âœ… Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao12[i])));\n        }\n        svg.append('path').datum(times).attr('class', 'line line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao5).attr('class', 'line line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao12).attr('class', 'line line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2);\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, i) {\n            var _times_i, _ao5_i, _ao12_i;\n            const singleTime = (_times_i = times[i]) === null || _times_i === void 0 ? void 0 : _times_i.toFixed(2);\n            const ao5Time = ao5[i] !== null ? (_ao5_i = ao5[i]) === null || _ao5_i === void 0 ? void 0 : _ao5_i.toFixed(2) : '-';\n            const ao12Time = ao12[i] !== null ? (_ao12_i = ao12[i]) === null || _ao12_i === void 0 ? void 0 : _ao12_i.toFixed(2) : '-';\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // âœ… Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // âœ… Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // âœ… Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"âœ” Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color).on('mouseover', (event, d)=>showTooltip(event, d.x)).on('mouseout', hideTooltip);\n        }\n        // âœ… Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n        const controls = d3.select(containerRef.current).append('div').attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow');\n        controls.append('button').text('Autoscale').style('margin-right', '5px').on('click', autoscale);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaIndex.js\",\n        lineNumber: 350,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYUluZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFMEM7QUFDMUMsTUFBTUUsS0FBSyxNQUFNLDRNQUFZO0FBRWQsU0FBU0MsZUFBZSxLQUFVO1FBQVYsRUFBRUMsTUFBTSxFQUFFLEdBQVY7O0lBQ25DLE1BQU1DLGVBQWVKLDZDQUFNQSxDQUFDO0lBRTVCRCxnREFBU0E7b0NBQUM7WUFDTixJQUFJLENBQUNJLFVBQVUsQ0FBQ0UsTUFBTUMsT0FBTyxDQUFDSCxXQUFXQSxPQUFPSSxNQUFNLEtBQUssR0FBRyxRQUFRLDRCQUE0QjtZQUNsRyxJQUFJSCxhQUFhSSxPQUFPLEVBQUU7Z0JBQ3RCQyxtQkFBbUJOO2dCQUNuQk8sT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUM7WUFDdEM7WUFFQTs0Q0FBTyxJQUFNRixPQUFPRyxtQkFBbUIsQ0FBQyxVQUFVRDs7UUFDdEQ7bUNBQUc7UUFBQ1Q7S0FBTztJQUVYLFNBQVNTO1FBQ0wsSUFBSVIsYUFBYUksT0FBTyxFQUFFO1lBQ3RCQyxtQkFBbUJOO1FBQ3ZCO0lBQ0o7SUFFQSxTQUFTVyxzQkFBc0JDLElBQUksRUFBRUMsVUFBVTtRQUMzQyxNQUFNQyxhQUFhRixLQUFLRyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0MsR0FBR0M7WUFDL0IsSUFBSUQsSUFBSUosYUFBYSxHQUFHLE9BQU87WUFDL0IsTUFBTU0sU0FBU0QsSUFBSUUsS0FBSyxDQUFDSCxJQUFLSixDQUFBQSxhQUFhLElBQUlJLElBQUk7WUFDbkQsT0FBT0UsT0FBT0UsTUFBTSxDQUFDLENBQUNDLEtBQUtDLE1BQVFELE1BQU1DLEtBQUssS0FBS0osT0FBT2YsTUFBTTtRQUNwRTtRQUVBb0IsUUFBUUMsR0FBRyxDQUFDLGdCQUEyQixPQUFYWjtRQUM1QlcsUUFBUUMsR0FBRyxDQUFDLHlCQUFxQyxPQUFaYixLQUFLUixNQUFNO1FBQ2hEb0IsUUFBUUMsR0FBRyxDQUFDLG9CQUEy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QUF3QjthQUN2QzlFLElBQUksQ0FBQyxTQUFTLFNBQW1CLE9BQVZ3RSxZQUN2QnhFLElBQUksQ0FBQyxNQUFNc0IsQ0FBQUEsSUFBS2hCLE9BQU9nQixFQUFFMEIsQ0FBQyxHQUMxQmhELElBQUksQ0FBQyxNQUFNc0IsQ0FBQUEsSUFBS1osT0FBT1ksRUFBRTJCLENBQUMsR0FDMUJqRCxJQUFJLENBQUMsS0FBSyxHQUNWQSxJQUFJLENBQUMsUUFBUW9DLE9BQ2JWLEVBQUUsQ0FBQyxhQUFhLENBQUNDLE9BQU9MLElBQU11QyxZQUFZbEMsT0FBT0wsRUFBRTBCLENBQUMsR0FDcER0QixFQUFFLENBQUMsWUFBWTJDO1FBQ3hCO1FBRVIsNkRBQTZEO1FBQ3JERSxVQUFVdEUsT0FBTyxRQUFRLGdCQUFnQixDQUFDcEIsSUFBTW9CLEtBQUssQ0FBQ3BCLEVBQUUsRUFBRSxHQUFHO1FBQzdEMEYsVUFBVW5FLEtBQUssU0FBUyxhQUFhLENBQUN2QixJQUFNdUIsR0FBRyxDQUFDdkIsRUFBRSxFQUFFLEdBQUc7UUFDdkQwRixVQUFVbEUsTUFBTSxPQUFPLGNBQWMsQ0FBQ3hCLElBQU13QixJQUFJLENBQUN4QixFQUFFLEVBQUUsSUFBSTtRQUV6RCxNQUFNa0csV0FBV3JILEdBQUc2QixNQUFNLENBQUMxQixhQUFhSSxPQUFPLEVBQUU4QixNQUFNLENBQUMsT0FDbkRDLElBQUksQ0FBQyxTQUFTO1FBRW5CK0UsU0FBU2hGLE1BQU0sQ0FBQyxVQUNYeUMsSUFBSSxDQUFDLGFBQ0xvQixLQUFLLENBQUMsZ0JBQWdCLE9BQ3RCbEMsRUFBRSxDQUFDLFNBQVNlO0lBQ3JCO0lBRUEscUJBQ0ksOERBQUN1QztRQUNHQyxLQUFLcEg7UUFDTDJHLFdBQVU7Ozs7OztBQUd0QjtHQTdWd0I3RztLQUFBQSIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxTclxcMjAyNF9DX1Rlcm1cXENTNDI0MVxcSFdcXGZpbmFsLXByb2plY3Qta2VybWl0LXRoZS1mcm9nXFxzcmNcXGFwcFxcZGF0YVZpc1xcVHJlbmRBbmFJbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuY29uc3QgZDMgPSBhd2FpdCBpbXBvcnQoJ2QzJyk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTb2x2ZVRpbWVUcmVuZCh7IHNvbHZlcyB9KSB7XHJcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIXNvbHZlcyB8fCAhQXJyYXkuaXNBcnJheShzb2x2ZXMpIHx8IHNvbHZlcy5sZW5ndGggPT09IDApIHJldHVybjsgLy8g8J+UpSBFbnN1cmUgc29sdmVzIGlzIHZhbGlkXHJcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGRyYXdTb2x2ZVRpbWVUcmVuZChzb2x2ZXMpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgIH0sIFtzb2x2ZXNdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGRyYXdTb2x2ZVRpbWVUcmVuZChzb2x2ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UoZGF0YSwgd2luZG93U2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IHJvbGxpbmdBdmcgPSBkYXRhLm1hcCgoXywgaSwgYXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgd2luZG93U2l6ZSAtIDEpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBzdWJzZXQgPSBhcnIuc2xpY2UoaSAtICh3aW5kb3dTaXplIC0gMSksIGkgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnNldC5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gc3Vic2V0Lmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFdpbmRvdyBTaXplOiAke3dpbmRvd1NpemV9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYE9yaWdpbmFsIERhdGEgTGVuZ3RoOiAke2RhdGEubGVuZ3RofWApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBSb2xsaW5nIEF2ZXJhZ2UgKCR7d2luZG93U2l6ZX0pIExlbmd0aDogJHtyb2xsaW5nQXZnLmxlbmd0aH1gKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgRmlyc3QgVmFsdWVzOmAsIHJvbGxpbmdBdmcuc2xpY2UoMCwgMTUpKTsgLy8gQ2hlY2sgZmlyc3QgZmV3IHZhbHVlc1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBMYXN0IFZhbHVlczpgLCByb2xsaW5nQXZnLnNsaWNlKC0xNSkpOyAvLyBDaGVjayBsYXN0IGZldyB2YWx1ZXNcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvbGxpbmdBdmc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NvbHZlVGltZVRyZW5kKGRhdGEpIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCk7XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgfHwgNTAwO1xyXG5cclxuICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXIuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKVxyXG4gICAgICAgICAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVzID0gZGF0YS5tYXAoKHNvbHZlKSA9PiBzb2x2ZS50aW1lIC8gMTAwMCk7XHJcbiAgICAgICAgY29uc3QgYW81ID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCA1KTtcclxuICAgICAgICBjb25zdCBhbzEyID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCAxMik7XHJcblxyXG4gICAgICAgIGxldCB4U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oWzAsIHRpbWVzLmxlbmd0aCAtIDFdKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCB3aWR0aCAtIDUwXSk7XHJcblxyXG4gICAgICAgIGxldCB5U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oW2QzLm1heCh0aW1lcyksIGQzLm1pbih0aW1lcyldKSAgLy8gRmxpcCBkb21haW4gdG8gbWF0Y2ggU1ZHIGNvb3Jkc1xyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCBoZWlnaHQgLSA1MF0pOyAvLyBFbnN1cmUgYm90dG9tIGlzIGxvd2VyIG9uIHRoZSBzY3JlZW5cclxuXHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3gtYXhpcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7aGVpZ2h0IC0gNTB9KWApXHJcbiAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNCb3R0b20oeFNjYWxlKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5LWF4aXMnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSg1MCwgMClgKVxyXG4gICAgICAgICAgICAuY2FsbChkMy5heGlzTGVmdCh5U2NhbGUpKTtcclxuXHJcbiAgICAgICAgY29uc3QgZ3JpZEdyb3VwID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2dyaWQnKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd0dyaWQoeFNjYWxlLCB5U2NhbGUpIHtcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBncmlkIGxpbmVzXHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJy5ob3Jpem9udGFsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoeVNjYWxlLnRpY2tzKDEwKSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdob3Jpem9udGFsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZCA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBkID0+IHlTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICc0LDQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIGdyaWQgbGluZXNcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnLnZlcnRpY2FsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoeFNjYWxlLnRpY2tzKDEwKSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZXJ0aWNhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4geFNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiB4U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGhlaWdodCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjY2NjJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgJzQsNCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHJhd0dyaWQoeFNjYWxlLCB5U2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCB6b29tID0gZDMuem9vbSgpXHJcbiAgICAgICAgICAgIC5zY2FsZUV4dGVudChbMC41LCA1XSlcclxuICAgICAgICAgICAgLnRyYW5zbGF0ZUV4dGVudChbWzAsIDBdLCBbd2lkdGgsIGhlaWdodF1dKVxyXG4gICAgICAgICAgICAub24oJ3pvb20nLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1hTY2FsZSA9IHRyYW5zZm9ybS5yZXNjYWxlWCh4U2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3WVNjYWxlID0gdHJhbnNmb3JtLnJlc2NhbGVZKHlTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBwbG90c1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlUGxvdChuZXdYU2NhbGUsIG5ld1lTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGF4ZXNcclxuICAgICAgICAgICAgICAgIHhBeGlzLmNhbGwoZDMuYXhpc0JvdHRvbShuZXdYU2NhbGUpKTtcclxuICAgICAgICAgICAgICAgIHlBeGlzLmNhbGwoZDMuYXhpc0xlZnQobmV3WVNjYWxlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdyaWQgd2l0aCBuZXcgc2NhbGVzXHJcbiAgICAgICAgICAgICAgICBkcmF3R3JpZChuZXdYU2NhbGUsIG5ld1lTY2FsZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzdmcuY2FsbCh6b29tKTtcclxuXHJcbiAgICAgICAgLy8g4pyFIEFkZCBMZWdlbmRzIChCZWxvdyBBdXRvc2NhbGUgQnV0dG9uKVxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3dpZHRoIC0gMTIwfSwgODApYCk7IC8vIOKshyBNb3ZlcyBsZWdlbmQgbG93ZXIgdW5kZXIgYnV0dG9uXHJcblxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1zID0gW1xyXG4gICAgICAgICAgICB7IGNvbG9yOiAnYmx1ZScsIGxhYmVsOiAnU2luZ2xlJyB9LFxyXG4gICAgICAgICAgICB7IGNvbG9yOiAnZ3JlZW4nLCBsYWJlbDogJ0FPNScgfSxcclxuICAgICAgICAgICAgeyBjb2xvcjogJ3JlZCcsIGxhYmVsOiAnQU8xMicgfVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGxlZ2VuZEl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcclxuICAgICAgICAgICAgbGVnZW5kLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGkgKiAyMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDE1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDE1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBpdGVtLmNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAyMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaSAqIDIwICsgMTIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzEycHgnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoaXRlbS5sYWJlbCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGF1dG9zY2FsZShldmVudCkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBTdG9wIGRlZmF1bHQgem9vbSBiZWhhdmlvclxyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudCBmdXJ0aGVyIGV2ZW50IHByb3BhZ2F0aW9uXHJcblxyXG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxyXG4gICAgICAgICAgICAgICAgLmNhbGwoem9vbS50cmFuc2Zvcm0sIGQzLnpvb21JZGVudGl0eSk7IC8vIFJlc2V0IHRvIG9yaWdpbmFsIHpvb20gc3RhdGVcclxuICAgICAgICB9XHJcblxyXG4vLyBFbnN1cmUgZXZlbnQgaXMgcGFzc2VkIHRvIGF1dG9zY2FsZVxyXG4gICAgICAgIHN2Zy5vbignZGJsY2xpY2snLCAoZXZlbnQpID0+IGF1dG9zY2FsZShldmVudCkpO1xyXG5cclxuLy8gQWxzbyBleHBsaWNpdGx5IGRpc2FibGUgem9vbSBvbiBkb3VibGUtY2xpY2sgdG8gcHJldmVudCB6b29taW5nIGluXHJcbiAgICAgICAgc3ZnLmNhbGwoem9vbSkub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVQbG90KG5ld1hTY2FsZSwgbmV3WVNjYWxlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBVcGRhdGluZyBQbG90IHdpdGggTmV3IFNjYWxlczpcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+foiBOZXcgWCBTY2FsZSBEb21haW46XCIsIG5ld1hTY2FsZS5kb21haW4oKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+foiBOZXcgWSBTY2FsZSBEb21haW46XCIsIG5ld1lTY2FsZS5kb21haW4oKSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIHRoYXQgdGhlIEFPNSBhbmQgQU8xMiBwb2ludHMgYXJlIGNvcnJlY3RseSBib3VuZFxyXG4gICAgICAgICAgICBjb25zdCBhbzVTZWxlY3Rpb24gPSBzdmcuc2VsZWN0QWxsKCcucG9pbnQtYW81JylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGFvNS5tYXAoKHZhbCwgaSkgPT4gKHsgeDogaSwgeTogdmFsIH0pKSwgZCA9PiBkLngpOyAvLyBFbnN1cmUgdW5pcXVlIGtleSBiaW5kaW5nXHJcblxyXG4gICAgICAgICAgICBjb25zdCBhbzEyU2VsZWN0aW9uID0gc3ZnLnNlbGVjdEFsbCgnLnBvaW50LWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoYW8xMi5tYXAoKHZhbCwgaSkgPT4gKHsgeDogaSwgeTogdmFsIH0pKSwgZCA9PiBkLngpOyAvLyBFbnN1cmUgdW5pcXVlIGtleSBiaW5kaW5nXHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFRvdGFsIEFPNSBQb2ludHMgU2VsZWN0ZWQ6ICR7YW81U2VsZWN0aW9uLnNpemUoKX0gKEV4cGVjdGVkOiAke2FvNS5sZW5ndGh9KWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFRvdGFsIEFPMTIgUG9pbnRzIFNlbGVjdGVkOiAke2FvMTJTZWxlY3Rpb24uc2l6ZSgpfSAoRXhwZWN0ZWQ6ICR7YW8xMi5sZW5ndGh9KWApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFvNVNlbGVjdGlvbi5zaXplKCkgPT09IDApIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBBTzUgcG9pbnRzIGZvdW5kIGluIHVwZGF0ZVBsb3QhXCIpO1xyXG4gICAgICAgICAgICBpZiAoYW8xMlNlbGVjdGlvbi5zaXplKCkgPT09IDApIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBBTzEyIHBvaW50cyBmb3VuZCBpbiB1cGRhdGVQbG90IVwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgYWxsIEFPNSBwb2ludHNcclxuICAgICAgICAgICAgYW81U2VsZWN0aW9uLmF0dHIoJ2N4JywgZCA9PiBuZXdYU2NhbGUoZC54KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4gbmV3WVNjYWxlKGQueSkpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBhbGwgQU8xMiBwb2ludHNcclxuICAgICAgICAgICAgYW8xMlNlbGVjdGlvbi5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKGQueCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBEZWJ1Z2dpbmc6IEVuc3VyZSBsYXN0IEFPNSAmIEFPMTIgcG9pbnRzIHVwZGF0ZSBjb3JyZWN0bHlcclxuICAgICAgICAgICAgYW81U2VsZWN0aW9uLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGFvNS5sZW5ndGggLSA0KSB7IC8vIFVzZSBgYW81Lmxlbmd0aGAgdG8gY29ycmVjdGx5IGl0ZXJhdGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+foiBBTzUgUG9pbnQgJHtpfTogeD0ke25ld1hTY2FsZShkLngpfSwgeT0ke25ld1lTY2FsZShkLnkpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGFvMTJTZWxlY3Rpb24uZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYW8xMi5sZW5ndGggLSAxMikgeyAvLyBVc2UgYGFvMTIubGVuZ3RoYCB0byBjb3JyZWN0bHkgaXRlcmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5S0IEFPMTIgUG9pbnQgJHtpfTogeD0ke25ld1hTY2FsZShkLngpfSwgeT0ke25ld1lTY2FsZShkLnkpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgc2luZ2xlIHNvbHZlIHBvaW50c1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcucG9pbnQtc2luZ2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIChfLCBpKSA9PiBuZXdYU2NhbGUoaSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCAoXywgaSkgPT4gbmV3WVNjYWxlKHRpbWVzW2ldKSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIHNpbmdsZSBzb2x2ZSBsaW5lXHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLXNpbmdsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAueCgoXywgaSkgPT4gbmV3WFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiBuZXdZU2NhbGUodGltZXNbaV0pKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgQU81IGxpbmUgYWxpZ25zIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvNScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZCgoXywgaSkgPT4gaSA+PSA0ICYmIGFvNVtpXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAueCgoXywgaSkgPT4gbmV3WFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiBuZXdZU2NhbGUoYW81W2ldKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIEFPMTIgbGluZSBhbGlnbnMgZHluYW1pY2FsbHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtYW8xMicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZCgoXywgaSkgPT4gaSA+PSAxMSAmJiBhbzEyW2ldICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KChfLCBpKSA9PiBuZXdYU2NhbGUoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoKF8sIGkpID0+IG5ld1lTY2FsZShhbzEyW2ldKSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKHRpbWVzKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZSBsaW5lLXNpbmdsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmx1ZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XHJcblxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZGF0dW0oYW81KVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZSBsaW5lLWFvNScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnZ3JlZW4nKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKGFvMTIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lIGxpbmUtYW8xMicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAncmVkJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCkuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYWJzb2x1dGUgYmctd2hpdGUgcC0yIGJvcmRlciByb3VuZGVkIHNoYWRvdyB0ZXh0LXNtJylcclxuICAgICAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpXHJcbiAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZXZlbnQsIGkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2luZ2xlVGltZSA9IHRpbWVzW2ldPy50b0ZpeGVkKDIpO1xyXG4gICAgICAgICAgICBjb25zdCBhbzVUaW1lID0gYW81W2ldICE9PSBudWxsID8gYW81W2ldPy50b0ZpeGVkKDIpIDogJy0nO1xyXG4gICAgICAgICAgICBjb25zdCBhbzEyVGltZSA9IGFvMTJbaV0gIT09IG51bGwgPyBhbzEyW2ldPy50b0ZpeGVkKDIpIDogJy0nO1xyXG5cclxuICAgICAgICAgICAgdG9vbHRpcC5odG1sKGBcclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5TaW5nbGU6PC9zdHJvbmc+ICR7c2luZ2xlVGltZX1zPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+QU81Ojwvc3Ryb25nPiAke2FvNVRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPkFPMTI6PC9zdHJvbmc+ICR7YW8xMlRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICBgKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdmaXhlZCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nJywgJzZweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JvcmRlcicsICcxcHggc29saWQgI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JvcmRlci1yYWRpdXMnLCAnNXB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm94LXNoYWRvdycsICcycHggMnB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjEpJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnei1pbmRleCcsICcxMDAwJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAtNTAlKScpO1xyXG5cclxuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZSgnbGVmdCcsIGAke2V2ZW50LnBhZ2VYICsgMTJ9cHhgKS5zdHlsZSgndG9wJywgYCR7ZXZlbnQucGFnZVl9cHhgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwKCkge1xyXG4gICAgICAgICAgICB0b29sdGlwLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVBsb3QoeFNjYWxlLCB5U2NhbGUpOyAgLy8g4pyFIEZvcmNlIHJlbmRlciBhZnRlciBpbml0aWFsaXphdGlvblxyXG4gICAgICAgIH0sIDEwMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZFBvaW50cyhkYXRhLCBjb2xvciwgY2xhc3NOYW1lLCB2YWx1ZUFjY2Vzc29yLCBtaW5JbmRleCwgbGFiZWwpIHtcclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSB0aGF0IHdlIGNvcnJlY3RseSBpdGVyYXRlIG92ZXIgdGhlIGZ1bGwgZGF0YXNldFxyXG4gICAgICAgICAgICBjb25zdCB2YWxpZFBvaW50cyA9IGRhdGFcclxuICAgICAgICAgICAgICAgIC5tYXAoKHZhbCwgaSkgPT4gKHsgeDogaSwgeTogdmFsdWVBY2Nlc3NvcihpKSB9KSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkLnkgIT09IG51bGwgJiYgZC54ID49IG1pbkluZGV4KTsgLy8g4pyFIFJlbW92ZWQgeCA8IHRpbWVzLmxlbmd0aCBjb25zdHJhaW50XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+foiBBZGRpbmcgUG9pbnRzIGZvciAke2xhYmVsfSB8IENsYXNzOiAke2NsYXNzTmFtZX0gfCBNaW5JbmRleDogJHttaW5JbmRleH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBWYWxpZCBQb2ludHMgQ291bnQ6ICR7dmFsaWRQb2ludHMubGVuZ3RofWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjSBGaXJzdCA1IFBvaW50czpgLCB2YWxpZFBvaW50cy5zbGljZSgwLCA1KSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5ONIExhc3QgNSBQb2ludHM6YCwgdmFsaWRQb2ludHMuc2xpY2UoLTUpKTtcclxuXHJcbiAgICAgICAgICAgIHZhbGlkUG9pbnRzLmZvckVhY2goKHBvaW50LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICBg8J+UtSAke2xhYmVsfSBQb2ludCAke2kgKyBtaW5JbmRleH06IFJhd1g9JHtwb2ludC54fSwgU2NhbGVkWD0ke3hTY2FsZShwb2ludC54KX0sIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBSYXdZPSR7cG9pbnQueS50b0ZpeGVkKDMpfSwgU2NhbGVkWT0ke3lTY2FsZShwb2ludC55KS50b0ZpeGVkKDIpfWBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIGRhdGEgYmluZGluZyBpcyBkb25lIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKGAuJHtjbGFzc05hbWV9YClcclxuICAgICAgICAgICAgICAgIC5kYXRhKHZhbGlkUG9pbnRzLCBkID0+IGQueCkgLy8gRW5zdXJlIHVuaXF1ZSBrZXkgYmluZGluZ1xyXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJjaXJjbGVcIikgLy8gRW5zdXJlIHByb3BlciBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgcG9pbnQgJHtjbGFzc05hbWV9YClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4geFNjYWxlKGQueCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IHlTY2FsZShkLnkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb2xvcilcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgKGV2ZW50LCBkKSA9PiBzaG93VG9vbHRpcChldmVudCwgZC54KSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBoaWRlVG9vbHRpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuLy8g4pyFIEVuc3VyZSBBTzUgJiBBTzEyIHBvaW50cyBhcmUgZnVsbHkgYWRkZWQgYmVmb3JlIHVwZGF0aW5nXHJcbiAgICAgICAgYWRkUG9pbnRzKHRpbWVzLCAnYmx1ZScsICdwb2ludC1zaW5nbGUnLCAoaSkgPT4gdGltZXNbaV0sIDAsIFwiU2luZ2xlXCIpO1xyXG4gICAgICAgIGFkZFBvaW50cyhhbzUsICdncmVlbicsICdwb2ludC1hbzUnLCAoaSkgPT4gYW81W2ldLCA0LCBcIkFPNVwiKTtcclxuICAgICAgICBhZGRQb2ludHMoYW8xMiwgJ3JlZCcsICdwb2ludC1hbzEyJywgKGkpID0+IGFvMTJbaV0sIDExLCBcIkFPMTJcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdhYnNvbHV0ZSB0b3AtMiByaWdodC0yIGJnLXdoaXRlIHAtMiByb3VuZGVkIHNoYWRvdycpO1xyXG5cclxuICAgICAgICBjb250cm9scy5hcHBlbmQoJ2J1dHRvbicpXHJcbiAgICAgICAgICAgIC50ZXh0KCdBdXRvc2NhbGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmdpbi1yaWdodCcsICc1cHgnKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgYXV0b3NjYWxlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInctc2NyZWVuIGgtW2NhbGMoMTAwdmgtMTAwcHgpXSBiZy13aGl0ZSByZWxhdGl2ZVwiXHJcbiAgICAgICAgPjwvZGl2PlxyXG4gICAgKTtcclxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJkMyIsIlNvbHZlVGltZVRyZW5kIiwic29sdmVzIiwiY29udGFpbmVyUmVmIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiY3VycmVudCIsImRyYXdTb2x2ZVRpbWVUcmVuZCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVSZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29tcHV0ZVJvbGxpbmdBdmVyYWdlIiwiZGF0YSIsIndpbmRvd1NpemUiLCJyb2xsaW5nQXZnIiwibWFwIiwiXyIsImkiLCJhcnIiLCJzdWJzZXQiLCJzbGljZSIsInJlZHVjZSIsInN1bSIsInZhbCIsImNvbnNvbGUiLCJsb2ciLCJjb250YWluZXIiLCJzZWxlY3QiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic3ZnIiwiYXBwZW5kIiwiYXR0ciIsInRpbWVzIiwic29sdmUiLCJ0aW1lIiwiYW81IiwiYW8xMiIsInhTY2FsZSIsInNjYWxlTGluZWFyIiwiZG9tYWluIiwicmFuZ2UiLCJ5U2NhbGUiLCJtYXgiLCJtaW4iLCJ4QXhpcyIsImNhbGwiLCJheGlzQm90dG9tIiwieUF4aXMiLCJheGlzTGVmdCIsImdyaWRHcm91cCIsImRyYXdHcmlkIiwidGlja3MiLCJlbnRlciIsImQiLCJ6b29tIiwic2NhbGVFeHRlbnQiLCJ0cmFuc2xhdGVFeHRlbnQiLCJvbiIsImV2ZW50IiwidHJhbnNmb3JtIiwibmV3WFNjYWxlIiwicmVzY2FsZVgiLCJuZXdZU2NhbGUiLCJyZXNjYWxlWSIsInVwZGF0ZVBsb3QiLCJsZWdlbmQiLCJsZWdlbmRJdGVtcyIsImNvbG9yIiwibGFiZWwiLCJmb3JFYWNoIiwiaXRlbSIsInRleHQiLCJhdXRvc2NhbGUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsInpvb21JZGVudGl0eSIsImFvNVNlbGVjdGlvbiIsIngiLCJ5IiwiYW8xMlNlbGVjdGlvbiIsInNpemUiLCJ3YXJuIiwiZWFjaCIsImxpbmUiLCJjdXJ2ZSIsImN1cnZlTW9ub3RvbmVYIiwiZGVmaW5lZCIsImRhdHVtIiwidG9vbHRpcCIsInN0eWxlIiwic2hvd1Rvb2x0aXAiLCJzaW5nbGVUaW1lIiwidG9GaXhlZCIsImFvNVRpbWUiLCJhbzEyVGltZSIsImh0bWwiLCJwYWdlWCIsInBhZ2VZIiwiaGlkZVRvb2x0aXAiLCJzZXRUaW1lb3V0IiwiYWRkUG9pbnRzIiwiY2xhc3NOYW1lIiwidmFsdWVBY2Nlc3NvciIsIm1pbkluZGV4IiwidmFsaWRQb2ludHMiLCJmaWx0ZXIiLCJwb2ludCIsImpvaW4iLCJjb250cm9scyIsImRpdiIsInJlZiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js":
/*!*****************************************!*\
  !*** ./src/app/dataVis/TrendAnaTime.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrendAnaIndex */ \"(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__]);\n_TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n// import TrendAnaTime from './TrendAnaTime';\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [currentClusterIndex, setCurrentClusterIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [clusters, setClusters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [xDomain, setXDomain] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const xDomainRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            console.log(\"ðŸ”„ XDomain or window size updated:\", xDomain);\n            if (!solves || solves.length === 0) {\n                console.warn(\"âš ï¸ No solves data available!\");\n                return;\n            }\n            const container = containerRef.current;\n            if (!container) {\n                console.warn(\"âš ï¸ Container reference is null!\");\n                return;\n            }\n            console.log(\"ðŸ“ Updating chart dimensions after resize...\");\n            drawSolveTimeTrend(solves);\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        xDomain,\n        containerRef\n    ]); // ðŸ”¥ Ensure chart updates when xDomain or container size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return;\n            console.log(\"ðŸ” Running cluster detection...\");\n            const detectedClusters = findClusters(solves);\n            setClusters(detectedClusters);\n            if (detectedClusters.length > 0) {\n                const firstCluster = detectedClusters[0];\n                const newDomain = [\n                    new Date(firstCluster[0].timestamp),\n                    new Date(firstCluster.slice(-1)[0].timestamp)\n                ];\n                setXDomain(newDomain);\n                xDomainRef.current = newDomain; // âœ… Ensure ref is updated\n                // â— Log AFTER setting the state to reflect the correct value\n                console.log(\"âœ… X-Domain initialized to first cluster:\", newDomain);\n            }\n            // Attach resize event\n            window.addEventListener('resize', handleResize);\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]); // <-- Runs only on first load\n    function handleResize() {\n        console.log(\"ðŸ”„ Handling resize...\");\n        if (!solves || solves.length === 0) {\n            console.warn(\"âš ï¸ No solves available, skipping resize!\");\n            return;\n        }\n        let detectedClusters = clusters;\n        if (clusters.length === 0) {\n            console.warn(\"âš ï¸ No clusters available on resize! Refinding clusters...\");\n            detectedClusters = findClusters(solves);\n            setClusters(detectedClusters);\n        }\n        if (detectedClusters.length === 0) {\n            console.warn(\"âš ï¸ Still no clusters found after resize!\");\n            return;\n        }\n        const prevClusterIndex = currentClusterIndex;\n        const prevXDomain = xDomainRef.current;\n        console.log(\"\\uD83D\\uDCCC Preserving Cluster Index: \".concat(prevClusterIndex));\n        console.log(\"ðŸ” Preserving X-Domain before resize:\", prevXDomain);\n        // Ensure re-renders with correct states\n        setCurrentClusterIndex(prevClusterIndex);\n        setXDomain(prevXDomain);\n        xDomainRef.current = prevXDomain;\n        // âœ… Force state updates to re-enable buttons\n        setTimeout(()=>{\n            setClusters([\n                ...detectedClusters\n            ]);\n            setXDomain([\n                ...prevXDomain\n            ]);\n            setCurrentClusterIndex(prevClusterIndex);\n        }, 0);\n        // Redraw the chart after resize\n        drawSolveTimeTrend(solves);\n        console.log(\"âœ… Resize handled, restoring states.\");\n    }\n    function findClusters(data) {\n        console.log(\"ðŸ” Running findClusters...\");\n        let detectedClusters = [];\n        let currentCluster = [\n            data[0]\n        ];\n        for(let i = 1; i < data.length; i++){\n            if (new Date(data[i].timestamp) - new Date(data[i - 1].timestamp) > 15 * 60 * 1000) {\n                if (currentCluster.length > 1) {\n                    const uniqueXValues = new Set(currentCluster.map((d)=>d.timestamp));\n                    if (uniqueXValues.size > 1) {\n                        detectedClusters.push(currentCluster);\n                    } else {\n                        console.warn(\"âš ï¸ Ignoring cluster with same X-Axis values:\", currentCluster);\n                    }\n                }\n                currentCluster = [];\n            }\n            currentCluster.push(data[i]);\n        }\n        // Check last cluster before adding it\n        if (currentCluster.length > 1) {\n            const uniqueXValues = new Set(currentCluster.map((d)=>d.timestamp));\n            if (uniqueXValues.size > 1) {\n                detectedClusters.push(currentCluster);\n            } else {\n                console.warn(\"âš ï¸ Ignoring cluster with same X-Axis values:\", currentCluster);\n            }\n        }\n        console.log(\"ðŸ“Š Clusters identified (excluding single/same x-axis clusters):\", detectedClusters.length, detectedClusters);\n        return detectedClusters;\n    }\n    function computeRollingAverage(data, windowSize) {\n        return data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null; // âœ… Preserve nulls at the beginning\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n    }\n    function drawSolveTimeTrend(data) {\n        console.log(\"ðŸ” Current X-Domain in drawSolveTimeTrend:\", xDomainRef.current);\n        if (!containerRef.current) {\n            console.warn(\"âš ï¸ Container reference is null, cannot draw!\");\n            return;\n        }\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        console.log(\"ðŸ“ Chart dimensions:\", width, height);\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        // Ensure all data contains timestamps\n        const processedData = data.map((solve)=>{\n            if (!solve.timestamp) {\n                console.warn(\"âš ï¸ Skipping entry with missing timestamp:\", solve);\n                return null;\n            }\n            return {\n                timestamp: new Date(solve.timestamp),\n                time: solve.time / 1000\n            };\n        }).filter((d)=>d !== null); // Remove invalid entries\n        const timestamps = processedData.map((d)=>d.timestamp);\n        const times = processedData.map((d)=>d.time);\n        console.log(\"Processed timestamps:\", timestamps);\n        // ðŸ”¥ Find the first \"cluster\" (a short interval of data)\n        let clusterStartIndex = 0;\n        let clusterEndIndex = timestamps.length - 1;\n        for(let i = 1; i < timestamps.length; i++){\n            if (timestamps[i] - timestamps[0] > 15 * 60 * 1000) {\n                clusterEndIndex = i;\n                break;\n            }\n        }\n        // Extract the cluster time range\n        const initialXDomain = [\n            timestamps[clusterStartIndex],\n            timestamps[clusterEndIndex]\n        ];\n        console.log(\"â³ Initial Focus X Domain: \".concat(initialXDomain[0], \" to \").concat(initialXDomain[1]));\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        const ao5Data = timestamps.map((timestamp, i)=>({\n                timestamp: timestamp,\n                value: ao5[i] !== null ? ao5[i] : null\n            })).filter((d)=>d.value !== null); // Remove initial nulls\n        const ao12Data = timestamps.map((timestamp, i)=>({\n                timestamp: timestamp,\n                value: ao12[i] !== null ? ao12[i] : null\n            })).filter((d)=>d.value !== null); // Remove initial nulls\n        var _xDomainRef_current;\n        // X Scale: Start zoomed into the identified cluster\n        let xScale = d3.scaleTime().domain((_xDomainRef_current = xDomainRef.current) !== null && _xDomainRef_current !== void 0 ? _xDomainRef_current : [\n            timestamps[0],\n            timestamps[timestamps.length - 1]\n        ]) // âœ… Use ref as fallback\n        .range([\n            50,\n            width - 50\n        ]);\n        console.log(\"ðŸ“‰ Applying X Scale domain in drawSolveTimeTrend:\", xScale.domain());\n        console.log(\"xScale range:\", xScale.range());\n        const yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]).range([\n            50,\n            height - 50\n        ]);\n        // Add X and Y axes\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M:%S')));\n        // Filter unique days for displaying date below\n        let lastDate = null;\n        xAxis.selectAll('text').attr('dy', '1.2em') // Move time labels up slightly\n        .each(function(d, i, nodes) {\n            const currentText = d3.select(this);\n            const dateStr = d3.timeFormat('%b %d, %Y')(new Date(d));\n            if (dateStr !== lastDate) {\n                currentText.append('tspan').attr('x', 0).attr('dy', '1.2em').text(dateStr);\n                lastDate = dateStr;\n            }\n        });\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom()// .scaleExtent([0.5, 5])\n        // .translateExtent([[0, 0], [width, height]])\n        .on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            console.log(\"Updated xScale domain:\", newXScale.domain());\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale).tickFormat(d3.timeFormat('%H:%M:%S')));\n            let lastZoomDate = null;\n            xAxis.selectAll('text').attr('dy', '1.2em').each(function(d, i, nodes) {\n                const currentText = d3.select(this);\n                const dateStr = d3.timeFormat('%b %d, %Y')(new Date(d));\n                if (dateStr !== lastZoomDate) {\n                    currentText.append('tspan').attr('x', 0).attr('dy', '1.2em').text(dateStr);\n                    lastZoomDate = dateStr;\n                }\n            });\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // âœ… Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 80)\")); // â¬‡ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"ðŸ”„ Updating Plot with New Scales:\");\n            console.log(\"ðŸŸ¢ New X Scale Domain:\", newXScale.domain());\n            console.log(\"ðŸŸ¢ New Y Scale Domain:\", newYScale.domain());\n            // âœ… Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5Data, (d)=>d.timestamp).join('circle').attr('class', 'point-ao5').attr('cx', (d)=>xScale(new Date(d.timestamp))) // Align with timestamps\n            .attr('cy', (d)=>yScale(d.value)).attr('r', 5).attr('fill', 'green').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12Data, (d)=>d.timestamp).join('circle').attr('class', 'point-ao12').attr('cx', (d)=>xScale(new Date(d.timestamp))) // Align with timestamps\n            .attr('cy', (d)=>yScale(d.value)).attr('r', 5).attr('fill', 'red').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            console.log(\"âœ” Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"âœ” Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"âš ï¸ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"âš ï¸ No AO12 points found in updatePlot!\");\n            // âœ… Update all AO5 points correctly\n            ao5Selection.attr('cx', (d)=>newXScale(new Date(d.timestamp))).attr('cy', (d)=>newYScale(d.value)); // âœ… Use d.value for AO5\n            // âœ… Update all AO12 points correctly\n            ao12Selection.attr('cx', (d)=>newXScale(new Date(d.timestamp))).attr('cy', (d)=>newYScale(d.value)); // âœ… Use d.value for AO12\n            // âœ… Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // âœ… Update single solve points\n            svg.selectAll('.point-single').data(processedData, (d)=>d.timestamp).join('circle').attr('class', 'point-single').attr('cx', (d)=>newXScale(new Date(d.timestamp))) // FIX: Use newXScale\n            .attr('cy', (d)=>newYScale(d.time)) // FIX: Use newYScale\n            .attr('r', 5).attr('fill', 'blue').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            // âœ… Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.time)));\n            // âœ… Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').datum(ao5.map((val, i)=>({\n                    timestamp: timestamps[i],\n                    value: val\n                }))).attr('d', d3.line().curve(d3.curveMonotoneX).defined((d)=>d.value !== null).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.value)));\n            // âœ… Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').datum(ao12.map((val, i)=>({\n                    timestamp: timestamps[i],\n                    value: val\n                }))).attr('d', d3.line().curve(d3.curveMonotoneX).defined((d)=>d.value !== null).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.value)));\n        }\n        svg.append('path').datum(processedData).attr('class', 'line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).x((d)=>xScale(new Date(d.timestamp))).y((d)=>yScale(d.time)));\n        svg.selectAll('.line-ao5').data([\n            ao5\n        ]) // âœ… Use .data([]) instead of .datum()\n        .join(\"path\").attr('class', 'line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>xScale(new Date(timestamps[i]))) // âœ… Use timestamps\n        .y((_, i)=>yScale(ao5[i])));\n        svg.selectAll('.line-ao12').data([\n            ao12\n        ]) // âœ… Use .data([]) instead of .datum()\n        .join(\"path\").attr('class', 'line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>xScale(new Date(timestamps[i]))) // âœ… Use timestamps\n        .y((_, i)=>yScale(ao12[i])));\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, timestamp) {\n            if (!timestamp) {\n                console.warn(\"âš ï¸ showTooltip called with invalid timestamp:\", timestamp);\n                return;\n            }\n            // Find all data points with the same timestamp\n            const singleData = processedData.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const ao5DataPoint = ao5Data.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const ao12DataPoint = ao12Data.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const singleTime = singleData ? singleData.time.toFixed(2) : \"-\";\n            const ao5Time = ao5DataPoint ? ao5DataPoint.value.toFixed(2) : \"-\";\n            const ao12Time = ao12DataPoint ? ao12DataPoint.value.toFixed(2) : \"-\";\n            console.log(\"\\uD83D\\uDFE2 Showing tooltip for timestamp \".concat(timestamp, \": Single=\").concat(singleTime, \", AO5=\").concat(ao5Time, \", AO12=\").concat(ao12Time));\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // âœ… Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // âœ… Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // âœ… Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"âœ” Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color);\n        }\n        // âœ… Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n        const controls = d3.select(containerRef.current).append('div').attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow');\n        controls.append('button').text('Previous Cluster').style('margin-right', '5px').attr('disabled', clusters.length === 0 || currentClusterIndex === 0 ? 'disabled' : null).on('click', prevCluster);\n        controls.append('button').text('Next Cluster').style('margin-right', '5px').attr('disabled', clusters.length === 0 || currentClusterIndex >= clusters.length - 1 ? 'disabled' : null).on('click', nextCluster);\n        controls.append('button').text('Autoscale').style('margin-right', '5px').on('click', autoscale);\n        controls.append('button').text('Switch to Time View').style('margin-right', '5px').style('background-color', 'green').style('color', 'white').style('padding', '5px 10px').style('border-radius', '5px').style('cursor', 'pointer').on('click', ()=>window.location.href = '/TrendAnaIndex');\n        function autoscale() {\n            console.log(\"ðŸ” Autoscale triggered...\");\n            if (!clusters || clusters.length === 0) {\n                console.warn(\"âš ï¸ No clusters available for autoscale!\");\n                return;\n            }\n            console.log(\"ðŸ“Œ Autoscaling to first cluster...\");\n            setCurrentClusterIndex(0);\n            const firstCluster = clusters[0];\n            if (!firstCluster || firstCluster.length === 0) {\n                console.warn(\"âš ï¸ First cluster is empty, cannot autoscale!\");\n                return;\n            }\n            const newDomain = [\n                new Date(firstCluster[0].timestamp),\n                new Date(firstCluster.slice(-1)[0].timestamp)\n            ];\n            console.log(\"âœ… Setting autoscale X-Domain to:\", newDomain);\n            setXDomain(newDomain);\n            xDomainRef.current = newDomain;\n            // âœ… Force React to update UI state\n            setTimeout(()=>{\n                setClusters([\n                    ...clusters\n                ]); // Force re-evaluation of clusters state\n            }, 0);\n        }\n        function nextCluster() {\n            console.log(\"âž¡ï¸ Next cluster clicked...\");\n            if (currentClusterIndex < clusters.length - 1) {\n                const nextIndex = currentClusterIndex + 1;\n                console.log(\"ðŸ“Œ Moving to next cluster:\", nextIndex);\n                setCurrentClusterIndex(nextIndex);\n                const newDomain = [\n                    new Date(clusters[nextIndex][0].timestamp),\n                    new Date(clusters[nextIndex].slice(-1)[0].timestamp)\n                ];\n                setXDomain(newDomain);\n                xDomainRef.current = newDomain;\n            } else {\n                console.warn(\"âš ï¸ No next cluster available!\");\n            }\n        }\n        function prevCluster() {\n            console.log(\"â¬…ï¸ Previous cluster clicked...\");\n            if (currentClusterIndex > 0) {\n                const prevIndex = currentClusterIndex - 1;\n                console.log(\"ðŸ“Œ Moving to previous cluster:\", prevIndex);\n                setCurrentClusterIndex(prevIndex);\n                const newDomain = [\n                    new Date(clusters[prevIndex][0].timestamp),\n                    new Date(clusters[prevIndex].slice(-1)[0].timestamp)\n                ];\n                setXDomain(newDomain);\n                xDomainRef.current = newDomain;\n            } else {\n                console.warn(\"âš ï¸ No previous cluster available!\");\n            }\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n        lineNumber: 683,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"adcdkr8RD2QhqVd8aE5mpvkqpaU=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYVRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVvRDtBQUNSO0FBQzVDLDZDQUE2QztBQUM3QyxNQUFNSSxLQUFLLE1BQU0sNE1BQVk7QUFFZCxTQUFTQyxlQUFlLEtBQVU7UUFBVixFQUFFQyxNQUFNLEVBQUUsR0FBVjs7SUFDbkMsTUFBTUMsZUFBZU4sNkNBQU1BLENBQUM7SUFDNUIsTUFBTSxDQUFDTyxxQkFBcUJDLHVCQUF1QixHQUFHUCwrQ0FBUUEsQ0FBQztJQUMvRCxNQUFNLENBQUNRLFVBQVVDLFlBQVksR0FBR1QsK0NBQVFBLENBQUMsRUFBRTtJQUMzQyxNQUFNLENBQUNVLFNBQVNDLFdBQVcsR0FBR1gsK0NBQVFBLENBQUM7SUFDdkMsTUFBTVksYUFBYWIsNkNBQU1BLENBQUM7SUFFMUJELGdEQUFTQTtvQ0FBQztZQUNOZSxRQUFRQyxHQUFHLENBQUMsc0NBQXNDSjtZQUVsRCxJQUFJLENBQUNOLFVBQVVBLE9BQU9XLE1BQU0sS0FBSyxHQUFHO2dCQUNoQ0YsUUFBUUcsSUFBSSxDQUFDO2dCQUNiO1lBQ0o7WUFFQSxNQUFNQyxZQUFZWixhQUFhYSxPQUFPO1lBQ3RDLElBQUksQ0FBQ0QsV0FBVztnQkFDWkosUUFBUUcsSUFBSSxDQUFDO2dCQUNiO1lBQ0o7WUFFQUgsUUFBUUMsR0FBRyxDQUFDO1lBQ1pLLG1CQUFtQmY7UUFDdkI7bUNBQUc7UUFBQ007UUFBU0w7S0FBYSxHQUFJLGlFQUFpRTtJQUUvRlAsZ0RBQVNBO29DQUFDO1lBQ04sSUFBSSxDQUFDTSxVQUFVLENBQUNnQixNQUFNQyxPQUFPLENBQUNqQixXQUFXQSxPQUFPVyxNQUFNLEtBQUssR0FBRztZQUU5REYsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTVEsbUJBQW1CQyxhQUFhbkI7WUFDdENLLFlBQVlhO1lBRVosSUFBSUEsaUJBQWlCUCxNQUFNLEdBQUcsR0FBRztnQkFDN0IsTUFBTVMs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QXNCO2dCQUN4Q08sUUFBUUMsR0FBRyxDQUFDLDhCQUE4QjhJO2dCQUMxQ3JKLHVCQUF1QnFKO2dCQUN2QixNQUFNbkksWUFBWTtvQkFDZCxJQUFJQyxLQUFLbEIsUUFBUSxDQUFDb0osVUFBVSxDQUFDLEVBQUUsQ0FBQ2pJLFNBQVM7b0JBQ3pDLElBQUlELEtBQUtsQixRQUFRLENBQUNvSixVQUFVLENBQUNoSSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDRCxTQUFTO2lCQUN0RDtnQkFFRGhCLFdBQVdjO2dCQUNYYixXQUFXTSxPQUFPLEdBQUdPO1lBQ3pCLE9BQU87Z0JBQ0haLFFBQVFHLElBQUksQ0FBQztZQUNqQjtRQUNKO1FBRUEsU0FBU3dJO1lBQ0wzSSxRQUFRQyxHQUFHLENBQUM7WUFDWixJQUFJUixzQkFBc0IsR0FBRztnQkFDekIsTUFBTXVKLFlBQVl2SixzQkFBc0I7Z0JBQ3hDTyxRQUFRQyxHQUFHLENBQUMsa0NBQWtDK0k7Z0JBQzlDdEosdUJBQXVCc0o7Z0JBQ3ZCLE1BQU1wSSxZQUFZO29CQUNkLElBQUlDLEtBQUtsQixRQUFRLENBQUNxSixVQUFVLENBQUMsRUFBRSxDQUFDbEksU0FBUztvQkFDekMsSUFBSUQsS0FBS2xCLFFBQVEsQ0FBQ3FKLFVBQVUsQ0FBQ2pJLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUNELFNBQVM7aUJBQ3REO2dCQUVEaEIsV0FBV2M7Z0JBQ1hiLFdBQVdNLE9BQU8sR0FBR087WUFDekIsT0FBTztnQkFDSFosUUFBUUcsSUFBSSxDQUFDO1lBQ2pCO1FBQ0o7SUFDSjtJQUVBLHFCQUNJLDhEQUFDOEk7UUFDR0MsS0FBSzFKO1FBQ0w2SSxXQUFVOzs7Ozs7QUFHdEI7R0F4cUJ3Qi9JO0tBQUFBIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxkYXRhVmlzXFxUcmVuZEFuYVRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgVHJlbmRBbmFJbmRleCBmcm9tICcuL1RyZW5kQW5hSW5kZXgnO1xyXG4vLyBpbXBvcnQgVHJlbmRBbmFUaW1lIGZyb20gJy4vVHJlbmRBbmFUaW1lJztcclxuY29uc3QgZDMgPSBhd2FpdCBpbXBvcnQoJ2QzJyk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTb2x2ZVRpbWVUcmVuZCh7IHNvbHZlcyB9KSB7XHJcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBbY3VycmVudENsdXN0ZXJJbmRleCwgc2V0Q3VycmVudENsdXN0ZXJJbmRleF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtjbHVzdGVycywgc2V0Q2x1c3RlcnNdID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgW3hEb21haW4sIHNldFhEb21haW5dID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCB4RG9tYWluUmVmID0gdXNlUmVmKG51bGwpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SEIFhEb21haW4gb3Igd2luZG93IHNpemUgdXBkYXRlZDpcIiwgeERvbWFpbik7XHJcblxyXG4gICAgICAgIGlmICghc29sdmVzIHx8IHNvbHZlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIHNvbHZlcyBkYXRhIGF2YWlsYWJsZSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBDb250YWluZXIgcmVmZXJlbmNlIGlzIG51bGwhXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk48gVXBkYXRpbmcgY2hhcnQgZGltZW5zaW9ucyBhZnRlciByZXNpemUuLi5cIik7XHJcbiAgICAgICAgZHJhd1NvbHZlVGltZVRyZW5kKHNvbHZlcyk7XHJcbiAgICB9LCBbeERvbWFpbiwgY29udGFpbmVyUmVmXSk7ICAvLyDwn5SlIEVuc3VyZSBjaGFydCB1cGRhdGVzIHdoZW4geERvbWFpbiBvciBjb250YWluZXIgc2l6ZSBjaGFuZ2VzXHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIXNvbHZlcyB8fCAhQXJyYXkuaXNBcnJheShzb2x2ZXMpIHx8IHNvbHZlcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIFJ1bm5pbmcgY2x1c3RlciBkZXRlY3Rpb24uLi5cIik7XHJcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWRDbHVzdGVycyA9IGZpbmRDbHVzdGVycyhzb2x2ZXMpO1xyXG4gICAgICAgIHNldENsdXN0ZXJzKGRldGVjdGVkQ2x1c3RlcnMpO1xyXG5cclxuICAgICAgICBpZiAoZGV0ZWN0ZWRDbHVzdGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2x1c3RlciA9IGRldGVjdGVkQ2x1c3RlcnNbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0RvbWFpbiA9IFtcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGZpcnN0Q2x1c3RlclswXS50aW1lc3RhbXApLFxyXG4gICAgICAgICAgICAgICAgbmV3IERhdGUoZmlyc3RDbHVzdGVyLnNsaWNlKC0xKVswXS50aW1lc3RhbXApXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICBzZXRYRG9tYWluKG5ld0RvbWFpbik7XHJcbiAgICAgICAgICAgIHhEb21haW5SZWYuY3VycmVudCA9IG5ld0RvbWFpbjsgIC8vIOKchSBFbnN1cmUgcmVmIGlzIHVwZGF0ZWRcclxuXHJcbiAgICAgICAgICAgIC8vIOKdlyBMb2cgQUZURVIgc2V0dGluZyB0aGUgc3RhdGUgdG8gcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBYLURvbWFpbiBpbml0aWFsaXplZCB0byBmaXJzdCBjbHVzdGVyOlwiLCBuZXdEb21haW4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIHJlc2l6ZSBldmVudFxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgIH0sIFtzb2x2ZXNdKTsgIC8vIDwtLSBSdW5zIG9ubHkgb24gZmlyc3QgbG9hZFxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflIQgSGFuZGxpbmcgcmVzaXplLi4uXCIpO1xyXG5cclxuICAgICAgICBpZiAoIXNvbHZlcyB8fCBzb2x2ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBzb2x2ZXMgYXZhaWxhYmxlLCBza2lwcGluZyByZXNpemUhXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZGV0ZWN0ZWRDbHVzdGVycyA9IGNsdXN0ZXJzO1xyXG5cclxuICAgICAgICBpZiAoY2x1c3RlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBjbHVzdGVycyBhdmFpbGFibGUgb24gcmVzaXplISBSZWZpbmRpbmcgY2x1c3RlcnMuLi5cIik7XHJcbiAgICAgICAgICAgIGRldGVjdGVkQ2x1c3RlcnMgPSBmaW5kQ2x1c3RlcnMoc29sdmVzKTtcclxuICAgICAgICAgICAgc2V0Q2x1c3RlcnMoZGV0ZWN0ZWRDbHVzdGVycyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGV0ZWN0ZWRDbHVzdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIFN0aWxsIG5vIGNsdXN0ZXJzIGZvdW5kIGFmdGVyIHJlc2l6ZSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByZXZDbHVzdGVySW5kZXggPSBjdXJyZW50Q2x1c3RlckluZGV4O1xyXG4gICAgICAgIGNvbnN0IHByZXZYRG9tYWluID0geERvbWFpblJlZi5jdXJyZW50O1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TjCBQcmVzZXJ2aW5nIENsdXN0ZXIgSW5kZXg6ICR7cHJldkNsdXN0ZXJJbmRleH1gKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gUHJlc2VydmluZyBYLURvbWFpbiBiZWZvcmUgcmVzaXplOlwiLCBwcmV2WERvbWFpbik7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSByZS1yZW5kZXJzIHdpdGggY29ycmVjdCBzdGF0ZXNcclxuICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KHByZXZDbHVzdGVySW5kZXgpO1xyXG4gICAgICAgIHNldFhEb21haW4ocHJldlhEb21haW4pO1xyXG4gICAgICAgIHhEb21haW5SZWYuY3VycmVudCA9IHByZXZYRG9tYWluO1xyXG5cclxuICAgICAgICAvLyDinIUgRm9yY2Ugc3RhdGUgdXBkYXRlcyB0byByZS1lbmFibGUgYnV0dG9uc1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRDbHVzdGVycyhbLi4uZGV0ZWN0ZWRDbHVzdGVyc10pO1xyXG4gICAgICAgICAgICBzZXRYRG9tYWluKFsuLi5wcmV2WERvbWFpbl0pO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KHByZXZDbHVzdGVySW5kZXgpO1xyXG4gICAgICAgIH0sIDApO1xyXG5cclxuICAgICAgICAvLyBSZWRyYXcgdGhlIGNoYXJ0IGFmdGVyIHJlc2l6ZVxyXG4gICAgICAgIGRyYXdTb2x2ZVRpbWVUcmVuZChzb2x2ZXMpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBSZXNpemUgaGFuZGxlZCwgcmVzdG9yaW5nIHN0YXRlcy5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZENsdXN0ZXJzKGRhdGEpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gUnVubmluZyBmaW5kQ2x1c3RlcnMuLi5cIik7XHJcblxyXG4gICAgICAgIGxldCBkZXRlY3RlZENsdXN0ZXJzID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnRDbHVzdGVyID0gW2RhdGFbMF1dO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKGRhdGFbaV0udGltZXN0YW1wKSAtIG5ldyBEYXRlKGRhdGFbaSAtIDFdLnRpbWVzdGFtcCkgPiAxNSAqIDYwICogMTAwMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDbHVzdGVyLmxlbmd0aCA+IDEpIHsgIC8vIOKchSBJZ25vcmUgY2x1c3RlcnMgd2l0aCBhIHNpbmdsZSBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVhWYWx1ZXMgPSBuZXcgU2V0KGN1cnJlbnRDbHVzdGVyLm1hcChkID0+IGQudGltZXN0YW1wKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuaXF1ZVhWYWx1ZXMuc2l6ZSA+IDEpIHsgIC8vIOKchSBJZ25vcmUgY2x1c3RlcnMgd2l0aCB0aGUgc2FtZSBYLUF4aXMgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRDbHVzdGVycy5wdXNoKGN1cnJlbnRDbHVzdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gSWdub3JpbmcgY2x1c3RlciB3aXRoIHNhbWUgWC1BeGlzIHZhbHVlczpcIiwgY3VycmVudENsdXN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDbHVzdGVyID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudENsdXN0ZXIucHVzaChkYXRhW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGxhc3QgY2x1c3RlciBiZWZvcmUgYWRkaW5nIGl0XHJcbiAgICAgICAgaWYgKGN1cnJlbnRDbHVzdGVyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgdW5pcXVlWFZhbHVlcyA9IG5ldyBTZXQoY3VycmVudENsdXN0ZXIubWFwKGQgPT4gZC50aW1lc3RhbXApKTtcclxuICAgICAgICAgICAgaWYgKHVuaXF1ZVhWYWx1ZXMuc2l6ZSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGRldGVjdGVkQ2x1c3RlcnMucHVzaChjdXJyZW50Q2x1c3Rlcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gSWdub3JpbmcgY2x1c3RlciB3aXRoIHNhbWUgWC1BeGlzIHZhbHVlczpcIiwgY3VycmVudENsdXN0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4ogQ2x1c3RlcnMgaWRlbnRpZmllZCAoZXhjbHVkaW5nIHNpbmdsZS9zYW1lIHgtYXhpcyBjbHVzdGVycyk6XCIsIGRldGVjdGVkQ2x1c3RlcnMubGVuZ3RoLCBkZXRlY3RlZENsdXN0ZXJzKTtcclxuICAgICAgICByZXR1cm4gZGV0ZWN0ZWRDbHVzdGVycztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UoZGF0YSwgd2luZG93U2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLm1hcCgoXywgaSwgYXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgd2luZG93U2l6ZSAtIDEpIHJldHVybiBudWxsOyAgLy8g4pyFIFByZXNlcnZlIG51bGxzIGF0IHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgICAgY29uc3Qgc3Vic2V0ID0gYXJyLnNsaWNlKGkgLSAod2luZG93U2l6ZSAtIDEpLCBpICsgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdWJzZXQucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSAvIHN1YnNldC5sZW5ndGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NvbHZlVGltZVRyZW5kKGRhdGEpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gQ3VycmVudCBYLURvbWFpbiBpbiBkcmF3U29sdmVUaW1lVHJlbmQ6XCIsIHhEb21haW5SZWYuY3VycmVudCk7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBDb250YWluZXIgcmVmZXJlbmNlIGlzIG51bGwsIGNhbm5vdCBkcmF3IVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KTtcclxuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gY29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCB8fCA1MDA7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjyBDaGFydCBkaW1lbnNpb25zOlwiLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gY29udGFpbmVyLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzEwMCUnKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgJzEwMCUnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlld0JveCcsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YClcclxuICAgICAgICAgICAgLmF0dHIoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgYWxsIGRhdGEgY29udGFpbnMgdGltZXN0YW1wc1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBkYXRhXHJcbiAgICAgICAgICAgIC5tYXAoc29sdmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzb2x2ZS50aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gU2tpcHBpbmcgZW50cnkgd2l0aCBtaXNzaW5nIHRpbWVzdGFtcDpcIiwgc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHNvbHZlLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogc29sdmUudGltZSAvIDEwMDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkICE9PSBudWxsKTsgIC8vIFJlbW92ZSBpbnZhbGlkIGVudHJpZXNcclxuXHJcbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IHByb2Nlc3NlZERhdGEubWFwKGQgPT4gZC50aW1lc3RhbXApO1xyXG4gICAgICAgIGNvbnN0IHRpbWVzID0gcHJvY2Vzc2VkRGF0YS5tYXAoZCA9PiBkLnRpbWUpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlByb2Nlc3NlZCB0aW1lc3RhbXBzOlwiLCB0aW1lc3RhbXBzKTtcclxuXHJcbiAgICAgICAgLy8g8J+UpSBGaW5kIHRoZSBmaXJzdCBcImNsdXN0ZXJcIiAoYSBzaG9ydCBpbnRlcnZhbCBvZiBkYXRhKVxyXG4gICAgICAgIGxldCBjbHVzdGVyU3RhcnRJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IGNsdXN0ZXJFbmRJbmRleCA9IHRpbWVzdGFtcHMubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aW1lc3RhbXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzW2ldIC0gdGltZXN0YW1wc1swXSA+IDE1ICogNjAgKiAxMDAwKSB7IC8vIDE1LW1pbnV0ZSB3aW5kb3dcclxuICAgICAgICAgICAgICAgIGNsdXN0ZXJFbmRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgY2x1c3RlciB0aW1lIHJhbmdlXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFhEb21haW4gPSBbXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcHNbY2x1c3RlclN0YXJ0SW5kZXhdLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXBzW2NsdXN0ZXJFbmRJbmRleF1cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhg4o+zIEluaXRpYWwgRm9jdXMgWCBEb21haW46ICR7aW5pdGlhbFhEb21haW5bMF19IHRvICR7aW5pdGlhbFhEb21haW5bMV19YCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFvNSA9IGNvbXB1dGVSb2xsaW5nQXZlcmFnZSh0aW1lcywgNSk7XHJcbiAgICAgICAgY29uc3QgYW8xMiA9IGNvbXB1dGVSb2xsaW5nQXZlcmFnZSh0aW1lcywgMTIpO1xyXG5cclxuICAgICAgICBjb25zdCBhbzVEYXRhID0gdGltZXN0YW1wcy5tYXAoKHRpbWVzdGFtcCwgaSkgPT4gKHtcclxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIHZhbHVlOiBhbzVbaV0gIT09IG51bGwgPyBhbzVbaV0gOiBudWxsXHJcbiAgICAgICAgfSkpLmZpbHRlcihkID0+IGQudmFsdWUgIT09IG51bGwpOyAvLyBSZW1vdmUgaW5pdGlhbCBudWxsc1xyXG5cclxuICAgICAgICBjb25zdCBhbzEyRGF0YSA9IHRpbWVzdGFtcHMubWFwKCh0aW1lc3RhbXAsIGkpID0+ICh7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxyXG4gICAgICAgICAgICB2YWx1ZTogYW8xMltpXSAhPT0gbnVsbCA/IGFvMTJbaV0gOiBudWxsXHJcbiAgICAgICAgfSkpLmZpbHRlcihkID0+IGQudmFsdWUgIT09IG51bGwpOyAvLyBSZW1vdmUgaW5pdGlhbCBudWxsc1xyXG5cclxuICAgICAgICAvLyBYIFNjYWxlOiBTdGFydCB6b29tZWQgaW50byB0aGUgaWRlbnRpZmllZCBjbHVzdGVyXHJcbiAgICAgICAgbGV0IHhTY2FsZSA9IGQzLnNjYWxlVGltZSgpXHJcbiAgICAgICAgICAgIC5kb21haW4oeERvbWFpblJlZi5jdXJyZW50ID8/IFt0aW1lc3RhbXBzWzBdLCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV1dKSAgLy8g4pyFIFVzZSByZWYgYXMgZmFsbGJhY2tcclxuICAgICAgICAgICAgLnJhbmdlKFs1MCwgd2lkdGggLSA1MF0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4kgQXBwbHlpbmcgWCBTY2FsZSBkb21haW4gaW4gZHJhd1NvbHZlVGltZVRyZW5kOlwiLCB4U2NhbGUuZG9tYWluKCkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwieFNjYWxlIHJhbmdlOlwiLCB4U2NhbGUucmFuZ2UoKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHlTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLmRvbWFpbihbZDMubWF4KHRpbWVzKSwgZDMubWluKHRpbWVzKV0pXHJcbiAgICAgICAgICAgIC5yYW5nZShbNTAsIGhlaWdodCAtIDUwXSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBYIGFuZCBZIGF4ZXNcclxuICAgICAgICBjb25zdCB4QXhpcyA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneC1heGlzJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtoZWlnaHQgLSA1MH0pYClcclxuICAgICAgICAgICAgLmNhbGwoZDMuYXhpc0JvdHRvbSh4U2NhbGUpLnRpY2tGb3JtYXQoZDMudGltZUZvcm1hdCgnJUg6JU06JVMnKSkpO1xyXG5cclxuICAgICAgICAvLyBGaWx0ZXIgdW5pcXVlIGRheXMgZm9yIGRpc3BsYXlpbmcgZGF0ZSBiZWxvd1xyXG4gICAgICAgIGxldCBsYXN0RGF0ZSA9IG51bGw7XHJcbiAgICAgICAgeEF4aXMuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzEuMmVtJykgLy8gTW92ZSB0aW1lIGxhYmVscyB1cCBzbGlnaHRseVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkLCBpLCBub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlU3RyID0gZDMudGltZUZvcm1hdCgnJWIgJWQsICVZJykobmV3IERhdGUoZCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVTdHIgIT09IGxhc3REYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQuYXBwZW5kKCd0c3BhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzEuMmVtJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZGF0ZVN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdERhdGUgPSBkYXRlU3RyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgeUF4aXMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ktYXhpcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDUwLCAwKWApXHJcbiAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNMZWZ0KHlTY2FsZSkpO1xyXG5cclxuICAgICAgICBjb25zdCBncmlkR3JvdXAgPSBzdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZ3JpZCcpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBkcmF3R3JpZCh4U2NhbGUsIHlTY2FsZSkge1xyXG4gICAgICAgICAgICBncmlkR3JvdXAuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIGdyaWQgbGluZXNcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnLmhvcml6b250YWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh5U2NhbGUudGlja3MoMTApKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hvcml6b250YWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHdpZHRoIC0gNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBkID0+IHlTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGQgPT4geVNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjY2NjJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgJzQsNCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gVmVydGljYWwgZ3JpZCBsaW5lc1xyXG4gICAgICAgICAgICBncmlkR3JvdXAuc2VsZWN0QWxsKCcudmVydGljYWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh4U2NhbGUudGlja3MoMTApKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ZlcnRpY2FsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZCA9PiB4U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBkID0+IHhTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgaGVpZ2h0IC0gNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAnNCw0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkcmF3R3JpZCh4U2NhbGUsIHlTY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHpvb20gPSBkMy56b29tKClcclxuICAgICAgICAgICAgLy8gLnNjYWxlRXh0ZW50KFswLjUsIDVdKVxyXG4gICAgICAgICAgICAvLyAudHJhbnNsYXRlRXh0ZW50KFtbMCwgMF0sIFt3aWR0aCwgaGVpZ2h0XV0pXHJcbiAgICAgICAgICAgIC5vbignem9vbScsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZXZlbnQudHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3WFNjYWxlID0gdHJhbnNmb3JtLnJlc2NhbGVYKHhTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdZU2NhbGUgPSB0cmFuc2Zvcm0ucmVzY2FsZVkoeVNjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZWQgeFNjYWxlIGRvbWFpbjpcIiwgbmV3WFNjYWxlLmRvbWFpbigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHBsb3RzXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVQbG90KG5ld1hTY2FsZSwgbmV3WVNjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYXhlc1xyXG4gICAgICAgICAgICAgICAgeEF4aXMuY2FsbChkMy5heGlzQm90dG9tKG5ld1hTY2FsZSkudGlja0Zvcm1hdChkMy50aW1lRm9ybWF0KCclSDolTTolUycpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxhc3Rab29tRGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB4QXhpcy5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcxLjJlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCwgaSwgbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVTdHIgPSBkMy50aW1lRm9ybWF0KCclYiAlZCwgJVknKShuZXcgRGF0ZShkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRlU3RyICE9PSBsYXN0Wm9vbURhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0LmFwcGVuZCgndHNwYW4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMS4yZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGRhdGVTdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFpvb21EYXRlID0gZGF0ZVN0cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgeUF4aXMuY2FsbChkMy5heGlzTGVmdChuZXdZU2NhbGUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ3JpZCB3aXRoIG5ldyBzY2FsZXNcclxuICAgICAgICAgICAgICAgIGRyYXdHcmlkKG5ld1hTY2FsZSwgbmV3WVNjYWxlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHN2Zy5jYWxsKHpvb20pO1xyXG5cclxuICAgICAgICAvLyDinIUgQWRkIExlZ2VuZHMgKEJlbG93IEF1dG9zY2FsZSBCdXR0b24pXHJcbiAgICAgICAgY29uc3QgbGVnZW5kID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7d2lkdGggLSAxMjB9LCA4MClgKTsgLy8g4qyHIE1vdmVzIGxlZ2VuZCBsb3dlciB1bmRlciBidXR0b25cclxuXHJcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbXMgPSBbXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdibHVlJywgbGFiZWw6ICdTaW5nbGUnIH0sXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdncmVlbicsIGxhYmVsOiAnQU81JyB9LFxyXG4gICAgICAgICAgICB7IGNvbG9yOiAncmVkJywgbGFiZWw6ICdBTzEyJyB9XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgbGVnZW5kSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZWdlbmQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaSAqIDIwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGl0ZW0uY29sb3IpO1xyXG5cclxuICAgICAgICAgICAgbGVnZW5kLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDIwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBpICogMjAgKyAxMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnMTJweCcpXHJcbiAgICAgICAgICAgICAgICAudGV4dChpdGVtLmxhYmVsKTtcclxuICAgICAgICB9KTtcclxuXHJcbi8vIEVuc3VyZSBldmVudCBpcyBwYXNzZWQgdG8gYXV0b3NjYWxlXHJcbiAgICAgICAgc3ZnLm9uKCdkYmxjbGljaycsIChldmVudCkgPT4gYXV0b3NjYWxlKGV2ZW50KSk7XHJcblxyXG4vLyBBbHNvIGV4cGxpY2l0bHkgZGlzYWJsZSB6b29tIG9uIGRvdWJsZS1jbGljayB0byBwcmV2ZW50IHpvb21pbmcgaW5cclxuICAgICAgICBzdmcuY2FsbCh6b29tKS5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBsb3QobmV3WFNjYWxlLCBuZXdZU2NhbGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5SEIFVwZGF0aW5nIFBsb3Qgd2l0aCBOZXcgU2NhbGVzOlwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5+iIE5ldyBYIFNjYWxlIERvbWFpbjpcIiwgbmV3WFNjYWxlLmRvbWFpbigpKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5+iIE5ldyBZIFNjYWxlIERvbWFpbjpcIiwgbmV3WVNjYWxlLmRvbWFpbigpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgdGhhdCB0aGUgQU81IGFuZCBBTzEyIHBvaW50cyBhcmUgY29ycmVjdGx5IGJvdW5kXHJcbiAgICAgICAgICAgIGNvbnN0IGFvNVNlbGVjdGlvbiA9IHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1hbzUnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoYW81RGF0YSwgZCA9PiBkLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgICAgIC5qb2luKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50LWFvNScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IHhTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKSAgLy8gQWxpZ24gd2l0aCB0aW1lc3RhbXBzXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IHlTY2FsZShkLnZhbHVlKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2dyZWVuJylcclxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZXZlbnQsIGQpID0+IHNob3dUb29sdGlwKGV2ZW50LCBkLnRpbWVzdGFtcCkpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoKSA9PiB0b29sdGlwLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhbzEyU2VsZWN0aW9uID0gc3ZnLnNlbGVjdEFsbCgnLnBvaW50LWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoYW8xMkRhdGEsIGQgPT4gZC50aW1lc3RhbXApXHJcbiAgICAgICAgICAgICAgICAuam9pbignY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwb2ludC1hbzEyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4geFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpICAvLyBBbGlnbiB3aXRoIHRpbWVzdGFtcHNcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4geVNjYWxlKGQudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAncmVkJylcclxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZXZlbnQsIGQpID0+IHNob3dUb29sdGlwKGV2ZW50LCBkLnRpbWVzdGFtcCkpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoKSA9PiB0b29sdGlwLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFRvdGFsIEFPNSBQb2ludHMgU2VsZWN0ZWQ6ICR7YW81U2VsZWN0aW9uLnNpemUoKX0gKEV4cGVjdGVkOiAke2FvNS5sZW5ndGh9KWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFRvdGFsIEFPMTIgUG9pbnRzIFNlbGVjdGVkOiAke2FvMTJTZWxlY3Rpb24uc2l6ZSgpfSAoRXhwZWN0ZWQ6ICR7YW8xMi5sZW5ndGh9KWApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFvNVNlbGVjdGlvbi5zaXplKCkgPT09IDApIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBBTzUgcG9pbnRzIGZvdW5kIGluIHVwZGF0ZVBsb3QhXCIpO1xyXG4gICAgICAgICAgICBpZiAoYW8xMlNlbGVjdGlvbi5zaXplKCkgPT09IDApIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBBTzEyIHBvaW50cyBmb3VuZCBpbiB1cGRhdGVQbG90IVwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgYWxsIEFPNSBwb2ludHMgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGFvNVNlbGVjdGlvbi5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnZhbHVlKSk7IC8vIOKchSBVc2UgZC52YWx1ZSBmb3IgQU81XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIGFsbCBBTzEyIHBvaW50cyBjb3JyZWN0bHlcclxuICAgICAgICAgICAgYW8xMlNlbGVjdGlvbi5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnZhbHVlKSk7IC8vIOKchSBVc2UgZC52YWx1ZSBmb3IgQU8xMlxyXG5cclxuICAgICAgICAgICAgLy8g4pyFIERlYnVnZ2luZzogRW5zdXJlIGxhc3QgQU81ICYgQU8xMiBwb2ludHMgdXBkYXRlIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBhbzVTZWxlY3Rpb24uZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYW81Lmxlbmd0aCAtIDQpIHsgLy8gVXNlIGBhbzUubGVuZ3RoYCB0byBjb3JyZWN0bHkgaXRlcmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5+iIEFPNSBQb2ludCAke2l9OiB4PSR7bmV3WFNjYWxlKGQueCl9LCB5PSR7bmV3WVNjYWxlKGQueSl9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYW8xMlNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhbzEyLmxlbmd0aCAtIDEyKSB7IC8vIFVzZSBgYW8xMi5sZW5ndGhgIHRvIGNvcnJlY3RseSBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflLQgQU8xMiBQb2ludCAke2l9OiB4PSR7bmV3WFNjYWxlKGQueCl9LCB5PSR7bmV3WVNjYWxlKGQueSl9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBzaW5nbGUgc29sdmUgcG9pbnRzXHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1zaW5nbGUnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocHJvY2Vzc2VkRGF0YSwgZCA9PiBkLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgICAgIC5qb2luKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50LXNpbmdsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IG5ld1hTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKSAvLyBGSVg6IFVzZSBuZXdYU2NhbGVcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4gbmV3WVNjYWxlKGQudGltZSkpIC8vIEZJWDogVXNlIG5ld1lTY2FsZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmx1ZScpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGV2ZW50LCBkKSA9PiBzaG93VG9vbHRpcChldmVudCwgZC50aW1lc3RhbXApKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKCkgPT4gdG9vbHRpcC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBzaW5nbGUgc29sdmUgbGluZVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1zaW5nbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoZCA9PiBuZXdYU2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSlcclxuICAgICAgICAgICAgICAgICAgICAueShkID0+IG5ld1lTY2FsZShkLnRpbWUpKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgQU81IGxpbmUgYWxpZ25zIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvNScpXHJcbiAgICAgICAgICAgICAgICAuZGF0dW0oYW81Lm1hcCgodmFsLCBpKSA9PiAoeyB0aW1lc3RhbXA6IHRpbWVzdGFtcHNbaV0sIHZhbHVlOiB2YWwgfSkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoZCA9PiBkLnZhbHVlICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoZCA9PiBuZXdZU2NhbGUoZC52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSBBTzEyIGxpbmUgYWxpZ25zIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmRhdHVtKGFvMTIubWFwKCh2YWwsIGkpID0+ICh7IHRpbWVzdGFtcDogdGltZXN0YW1wc1tpXSwgdmFsdWU6IHZhbCB9KSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZChkID0+IGQudmFsdWUgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoZCA9PiBuZXdYU2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSlcclxuICAgICAgICAgICAgICAgICAgICAueShkID0+IG5ld1lTY2FsZShkLnZhbHVlKSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKHByb2Nlc3NlZERhdGEpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lLXNpbmdsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmx1ZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMilcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgIC54KGQgPT4geFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAueShkID0+IHlTY2FsZShkLnRpbWUpKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1hbzUnKVxyXG4gICAgICAgICAgICAuZGF0YShbYW81XSkgIC8vIOKchSBVc2UgLmRhdGEoW10pIGluc3RlYWQgb2YgLmRhdHVtKClcclxuICAgICAgICAgICAgLmpvaW4oXCJwYXRoXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lLWFvNScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnZ3JlZW4nKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAuZGVmaW5lZCgoXywgaSkgPT4gaSA+PSA0ICYmIGFvNVtpXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIC54KChfLCBpKSA9PiB4U2NhbGUobmV3IERhdGUodGltZXN0YW1wc1tpXSkpKSAgLy8g4pyFIFVzZSB0aW1lc3RhbXBzXHJcbiAgICAgICAgICAgICAgICAueSgoXywgaSkgPT4geVNjYWxlKGFvNVtpXSkpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvMTInKVxyXG4gICAgICAgICAgICAuZGF0YShbYW8xMl0pICAvLyDinIUgVXNlIC5kYXRhKFtdKSBpbnN0ZWFkIG9mIC5kYXR1bSgpXHJcbiAgICAgICAgICAgIC5qb2luKFwicGF0aFwiKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZS1hbzEyJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdyZWQnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAuZGVmaW5lZCgoXywgaSkgPT4gaSA+PSAxMSAmJiBhbzEyW2ldICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgLngoKF8sIGkpID0+IHhTY2FsZShuZXcgRGF0ZSh0aW1lc3RhbXBzW2ldKSkpICAvLyDinIUgVXNlIHRpbWVzdGFtcHNcclxuICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiB5U2NhbGUoYW8xMltpXSkpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Fic29sdXRlIGJnLXdoaXRlIHAtMiBib3JkZXIgcm91bmRlZCBzaGFkb3cgdGV4dC1zbScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKGV2ZW50LCB0aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgaWYgKCF0aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBzaG93VG9vbHRpcCBjYWxsZWQgd2l0aCBpbnZhbGlkIHRpbWVzdGFtcDpcIiwgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmluZCBhbGwgZGF0YSBwb2ludHMgd2l0aCB0aGUgc2FtZSB0aW1lc3RhbXBcclxuICAgICAgICAgICAgY29uc3Qgc2luZ2xlRGF0YSA9IHByb2Nlc3NlZERhdGEuZmluZChkID0+IGQudGltZXN0YW1wLmdldFRpbWUoKSA9PT0gdGltZXN0YW1wLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvNURhdGFQb2ludCA9IGFvNURhdGEuZmluZChkID0+IGQudGltZXN0YW1wLmdldFRpbWUoKSA9PT0gdGltZXN0YW1wLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvMTJEYXRhUG9pbnQgPSBhbzEyRGF0YS5maW5kKGQgPT4gZC50aW1lc3RhbXAuZ2V0VGltZSgpID09PSB0aW1lc3RhbXAuZ2V0VGltZSgpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVRpbWUgPSBzaW5nbGVEYXRhID8gc2luZ2xlRGF0YS50aW1lLnRvRml4ZWQoMikgOiBcIi1cIjtcclxuICAgICAgICAgICAgY29uc3QgYW81VGltZSA9IGFvNURhdGFQb2ludCA/IGFvNURhdGFQb2ludC52YWx1ZS50b0ZpeGVkKDIpIDogXCItXCI7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvMTJUaW1lID0gYW8xMkRhdGFQb2ludCA/IGFvMTJEYXRhUG9pbnQudmFsdWUudG9GaXhlZCgyKSA6IFwiLVwiO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfn6IgU2hvd2luZyB0b29sdGlwIGZvciB0aW1lc3RhbXAgJHt0aW1lc3RhbXB9OiBTaW5nbGU9JHtzaW5nbGVUaW1lfSwgQU81PSR7YW81VGltZX0sIEFPMTI9JHthbzEyVGltZX1gKTtcclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuaHRtbChgXHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+U2luZ2xlOjwvc3Ryb25nPiAke3NpbmdsZVRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPkFPNTo8L3N0cm9uZz4gJHthbzVUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5BTzEyOjwvc3Ryb25nPiAke2FvMTJUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgYClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnZml4ZWQnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgJ3doaXRlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncGFkZGluZycsICc2cHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXInLCAnMXB4IHNvbGlkICNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXItcmFkaXVzJywgJzVweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JveC1zaGFkb3cnLCAnMnB4IDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3otaW5kZXgnLCAnMTAwMCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgLTUwJSknKTtcclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ2xlZnQnLCBgJHtldmVudC5wYWdlWCArIDEyfXB4YCkuc3R5bGUoJ3RvcCcsIGAke2V2ZW50LnBhZ2VZfXB4YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcclxuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB1cGRhdGVQbG90KHhTY2FsZSwgeVNjYWxlKTsgIC8vIOKchSBGb3JjZSByZW5kZXIgYWZ0ZXIgaW5pdGlhbGl6YXRpb25cclxuICAgICAgICB9LCAxMDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRQb2ludHMoZGF0YSwgY29sb3IsIGNsYXNzTmFtZSwgdmFsdWVBY2Nlc3NvciwgbWluSW5kZXgsIGxhYmVsKSB7XHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgdGhhdCB3ZSBjb3JyZWN0bHkgaXRlcmF0ZSBvdmVyIHRoZSBmdWxsIGRhdGFzZXRcclxuICAgICAgICAgICAgY29uc3QgdmFsaWRQb2ludHMgPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAubWFwKCh2YWwsIGkpID0+ICh7IHg6IGksIHk6IHZhbHVlQWNjZXNzb3IoaSkgfSkpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGQgPT4gZC55ICE9PSBudWxsICYmIGQueCA+PSBtaW5JbmRleCk7IC8vIOKchSBSZW1vdmVkIHggPCB0aW1lcy5sZW5ndGggY29uc3RyYWludFxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfn6IgQWRkaW5nIFBvaW50cyBmb3IgJHtsYWJlbH0gfCBDbGFzczogJHtjbGFzc05hbWV9IHwgTWluSW5kZXg6ICR7bWluSW5kZXh9YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJQgVmFsaWQgUG9pbnRzIENvdW50OiAke3ZhbGlkUG9pbnRzLmxlbmd0aH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk40gRmlyc3QgNSBQb2ludHM6YCwgdmFsaWRQb2ludHMuc2xpY2UoMCwgNSkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjSBMYXN0IDUgUG9pbnRzOmAsIHZhbGlkUG9pbnRzLnNsaWNlKC01KSk7XHJcblxyXG4gICAgICAgICAgICB2YWxpZFBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICAgICAgYPCflLUgJHtsYWJlbH0gUG9pbnQgJHtpICsgbWluSW5kZXh9OiBSYXdYPSR7cG9pbnQueH0sIFNjYWxlZFg9JHt4U2NhbGUocG9pbnQueCl9LCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUmF3WT0ke3BvaW50LnkudG9GaXhlZCgzKX0sIFNjYWxlZFk9JHt5U2NhbGUocG9pbnQueSkudG9GaXhlZCgyKX1gXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSBkYXRhIGJpbmRpbmcgaXMgZG9uZSBjb3JyZWN0bHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbChgLiR7Y2xhc3NOYW1lfWApXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh2YWxpZFBvaW50cywgZCA9PiBkLngpIC8vIEVuc3VyZSB1bmlxdWUga2V5IGJpbmRpbmdcclxuICAgICAgICAgICAgICAgIC5qb2luKFwiY2lyY2xlXCIpIC8vIEVuc3VyZSBwcm9wZXIgYmluZGluZ1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYHBvaW50ICR7Y2xhc3NOYW1lfWApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IHhTY2FsZShkLngpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC55KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY29sb3IpXHJcbiAgICAgICAgfVxyXG5cclxuLy8g4pyFIEVuc3VyZSBBTzUgJiBBTzEyIHBvaW50cyBhcmUgZnVsbHkgYWRkZWQgYmVmb3JlIHVwZGF0aW5nXHJcbiAgICAgICAgYWRkUG9pbnRzKHRpbWVzLCAnYmx1ZScsICdwb2ludC1zaW5nbGUnLCAoaSkgPT4gdGltZXNbaV0sIDAsIFwiU2luZ2xlXCIpO1xyXG4gICAgICAgIGFkZFBvaW50cyhhbzUsICdncmVlbicsICdwb2ludC1hbzUnLCAoaSkgPT4gYW81W2ldLCA0LCBcIkFPNVwiKTtcclxuICAgICAgICBhZGRQb2ludHMoYW8xMiwgJ3JlZCcsICdwb2ludC1hbzEyJywgKGkpID0+IGFvMTJbaV0sIDExLCBcIkFPMTJcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdhYnNvbHV0ZSB0b3AtMiByaWdodC0yIGJnLXdoaXRlIHAtMiByb3VuZGVkIHNoYWRvdycpO1xyXG5cclxuICAgICAgICBjb250cm9scy5hcHBlbmQoJ2J1dHRvbicpXHJcbiAgICAgICAgICAgIC50ZXh0KCdQcmV2aW91cyBDbHVzdGVyJylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tcmlnaHQnLCAnNXB4JylcclxuICAgICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgY2x1c3RlcnMubGVuZ3RoID09PSAwIHx8IGN1cnJlbnRDbHVzdGVySW5kZXggPT09IDAgPyAnZGlzYWJsZWQnIDogbnVsbClcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIHByZXZDbHVzdGVyKTtcclxuXHJcbiAgICAgICAgY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgICAgICAudGV4dCgnTmV4dCBDbHVzdGVyJylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tcmlnaHQnLCAnNXB4JylcclxuICAgICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgY2x1c3RlcnMubGVuZ3RoID09PSAwIHx8IGN1cnJlbnRDbHVzdGVySW5kZXggPj0gY2x1c3RlcnMubGVuZ3RoIC0gMSA/ICdkaXNhYmxlZCcgOiBudWxsKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgbmV4dENsdXN0ZXIpO1xyXG5cclxuICAgICAgICBjb250cm9scy5hcHBlbmQoJ2J1dHRvbicpXHJcbiAgICAgICAgICAgIC50ZXh0KCdBdXRvc2NhbGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmdpbi1yaWdodCcsICc1cHgnKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgYXV0b3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgICAgICAudGV4dCgnU3dpdGNoIHRvIFRpbWUgVmlldycpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLXJpZ2h0JywgJzVweCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICdncmVlbicpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnY29sb3InLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3BhZGRpbmcnLCAnNXB4IDEwcHgnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2JvcmRlci1yYWRpdXMnLCAnNXB4JylcclxuICAgICAgICAgICAgLnN0eWxlKCdjdXJzb3InLCAncG9pbnRlcicpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvVHJlbmRBbmFJbmRleCcpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhdXRvc2NhbGUoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBBdXRvc2NhbGUgdHJpZ2dlcmVkLi4uXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjbHVzdGVycyB8fCBjbHVzdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBjbHVzdGVycyBhdmFpbGFibGUgZm9yIGF1dG9zY2FsZSFcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjCBBdXRvc2NhbGluZyB0byBmaXJzdCBjbHVzdGVyLi4uXCIpO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KDApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZmlyc3RDbHVzdGVyID0gY2x1c3RlcnNbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZpcnN0Q2x1c3RlciB8fCBmaXJzdENsdXN0ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gRmlyc3QgY2x1c3RlciBpcyBlbXB0eSwgY2Fubm90IGF1dG9zY2FsZSFcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0RvbWFpbiA9IFtcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGZpcnN0Q2x1c3RlclswXS50aW1lc3RhbXApLFxyXG4gICAgICAgICAgICAgICAgbmV3IERhdGUoZmlyc3RDbHVzdGVyLnNsaWNlKC0xKVswXS50aW1lc3RhbXApXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBTZXR0aW5nIGF1dG9zY2FsZSBYLURvbWFpbiB0bzpcIiwgbmV3RG9tYWluKTtcclxuICAgICAgICAgICAgc2V0WERvbWFpbihuZXdEb21haW4pO1xyXG4gICAgICAgICAgICB4RG9tYWluUmVmLmN1cnJlbnQgPSBuZXdEb21haW47XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRm9yY2UgUmVhY3QgdG8gdXBkYXRlIFVJIHN0YXRlXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0Q2x1c3RlcnMoWy4uLmNsdXN0ZXJzXSk7IC8vIEZvcmNlIHJlLWV2YWx1YXRpb24gb2YgY2x1c3RlcnMgc3RhdGVcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBuZXh0Q2x1c3RlcigpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLinqHvuI8gTmV4dCBjbHVzdGVyIGNsaWNrZWQuLi5cIik7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2x1c3RlckluZGV4IDwgY2x1c3RlcnMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gY3VycmVudENsdXN0ZXJJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4wgTW92aW5nIHRvIG5leHQgY2x1c3RlcjpcIiwgbmV4dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDbHVzdGVySW5kZXgobmV4dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RvbWFpbiA9IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShjbHVzdGVyc1tuZXh0SW5kZXhdWzBdLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoY2x1c3RlcnNbbmV4dEluZGV4XS5zbGljZSgtMSlbMF0udGltZXN0YW1wKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRYRG9tYWluKG5ld0RvbWFpbik7XHJcbiAgICAgICAgICAgICAgICB4RG9tYWluUmVmLmN1cnJlbnQgPSBuZXdEb21haW47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gbmV4dCBjbHVzdGVyIGF2YWlsYWJsZSFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHByZXZDbHVzdGVyKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKshe+4jyBQcmV2aW91cyBjbHVzdGVyIGNsaWNrZWQuLi5cIik7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2x1c3RlckluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkluZGV4ID0gY3VycmVudENsdXN0ZXJJbmRleCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4wgTW92aW5nIHRvIHByZXZpb3VzIGNsdXN0ZXI6XCIsIHByZXZJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KHByZXZJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEb21haW4gPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoY2x1c3RlcnNbcHJldkluZGV4XVswXS50aW1lc3RhbXApLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKGNsdXN0ZXJzW3ByZXZJbmRleF0uc2xpY2UoLTEpWzBdLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0WERvbWFpbihuZXdEb21haW4pO1xyXG4gICAgICAgICAgICAgICAgeERvbWFpblJlZi5jdXJyZW50ID0gbmV3RG9tYWluO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIHByZXZpb3VzIGNsdXN0ZXIgYXZhaWxhYmxlIVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInctc2NyZWVuIGgtW2NhbGMoMTAwdmgtMTAwcHgpXSBiZy13aGl0ZSByZWxhdGl2ZVwiXHJcbiAgICAgICAgPjwvZGl2PlxyXG4gICAgKTtcclxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlRyZW5kQW5hSW5kZXgiLCJkMyIsIlNvbHZlVGltZVRyZW5kIiwic29sdmVzIiwiY29udGFpbmVyUmVmIiwiY3VycmVudENsdXN0ZXJJbmRleCIsInNldEN1cnJlbnRDbHVzdGVySW5kZXgiLCJjbHVzdGVycyIsInNldENsdXN0ZXJzIiwieERvbWFpbiIsInNldFhEb21haW4iLCJ4RG9tYWluUmVmIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsIndhcm4iLCJjb250YWluZXIiLCJjdXJyZW50IiwiZHJhd1NvbHZlVGltZVRyZW5kIiwiQXJyYXkiLCJpc0FycmF5IiwiZGV0ZWN0ZWRDbHVzdGVycyIsImZpbmRDbHVzdGVycyIsImZpcnN0Q2x1c3RlciIsIm5ld0RvbWFpbiIsIkRhdGUiLCJ0aW1lc3RhbXAiLCJzbGljZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVSZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicHJldkNsdXN0ZXJJbmRleCIsInByZXZYRG9tYWluIiwic2V0VGltZW91dCIsImRhdGEiLCJjdXJyZW50Q2x1c3RlciIsImkiLCJ1bmlxdWVYVmFsdWVzIiwiU2V0IiwibWFwIiwiZCIsInNpemUiLCJwdXNoIiwiY29tcHV0ZVJvbGxpbmdBdmVyYWdlIiwid2luZG93U2l6ZSIsIl8iLCJhcnIiLCJzdWJzZXQiLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJzZWxlY3QiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic3ZnIiwiYXBwZW5kIiwiYXR0ciIsInByb2Nlc3NlZERhdGEiLCJzb2x2ZSIsInRpbWUiLCJmaWx0ZXIiLCJ0aW1lc3RhbXBzIiwidGltZXMiLCJjbHVzdGVyU3RhcnRJbmRleCIsImNsdXN0ZXJFbmRJbmRleCIsImluaXRpYWxYRG9tYWluIiwiYW81IiwiYW8xMiIsImFvNURhdGEiLCJ2YWx1ZSIsImFvMTJEYXRhIiwieFNjYWxlIiwic2NhbGVUaW1lIiwiZG9tYWluIiwicmFuZ2UiLCJ5U2NhbGUiLCJzY2FsZUxpbmVhciIsIm1heCIsIm1pbiIsInhBeGlzIiwiY2FsbCIsImF4aXNCb3R0b20iLCJ0aWNrRm9ybWF0IiwidGltZUZvcm1hdCIsImxhc3REYXRlIiwiZWFjaCIsIm5vZGVzIiwiY3VycmVudFRleHQiLCJkYXRlU3RyIiwidGV4dCIsInlBeGlzIiwiYXhpc0xlZnQiLCJncmlkR3JvdXAiLCJkcmF3R3JpZCIsInRpY2tzIiwiZW50ZXIiLCJ6b29tIiwib24iLCJldmVudCIsInRyYW5zZm9ybSIsIm5ld1hTY2FsZSIsInJlc2NhbGVYIiwibmV3WVNjYWxlIiwicmVzY2FsZVkiLCJ1cGRhdGVQbG90IiwibGFzdFpvb21EYXRlIiwibGVnZW5kIiwibGVnZW5kSXRlbXMiLCJjb2xvciIsImxhYmVsIiwiZm9yRWFjaCIsIml0ZW0iLCJhdXRvc2NhbGUiLCJhbzVTZWxlY3Rpb24iLCJqb2luIiwic2hvd1Rvb2x0aXAiLCJ0b29sdGlwIiwic3R5bGUiLCJhbzEyU2VsZWN0aW9uIiwieCIsInkiLCJsaW5lIiwiY3VydmUiLCJjdXJ2ZU1vbm90b25lWCIsImRhdHVtIiwiZGVmaW5lZCIsInNpbmdsZURhdGEiLCJmaW5kIiwiZ2V0VGltZSIsImFvNURhdGFQb2ludCIsImFvMTJEYXRhUG9pbnQiLCJzaW5nbGVUaW1lIiwidG9GaXhlZCIsImFvNVRpbWUiLCJhbzEyVGltZSIsImh0bWwiLCJwYWdlWCIsInBhZ2VZIiwiaGlkZVRvb2x0aXAiLCJhZGRQb2ludHMiLCJjbGFzc05hbWUiLCJ2YWx1ZUFjY2Vzc29yIiwibWluSW5kZXgiLCJ2YWxpZFBvaW50cyIsInBvaW50IiwiY29udHJvbHMiLCJwcmV2Q2x1c3RlciIsIm5leHRDbHVzdGVyIiwibG9jYXRpb24iLCJocmVmIiwibmV4dEluZGV4IiwicHJldkluZGV4IiwiZGl2IiwicmVmIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\n"));

/***/ })

});