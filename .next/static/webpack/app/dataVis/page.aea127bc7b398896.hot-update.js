"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dataVis/page",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"7ce1050fe9c4\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjdjZTEwNTBmZTljNFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js":
/*!******************************************!*\
  !*** ./src/app/dataVis/TrendAnaIndex.js ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrendAnaTime */ \"(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__]);\n_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\n\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [showIndexView, setShowIndexView] = useState(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return; // ðŸ”¥ Ensure solves is valid\n            if (containerRef.current) {\n                drawSolveTimeTrend(solves);\n                window.addEventListener('resize', handleResize);\n            }\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]);\n    if (showIndexView) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(SolveTimeTrend, {\n            solves: solves\n        }, void 0, false, {\n            fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaIndex.js\",\n            lineNumber: 23,\n            columnNumber: 16\n        }, this);\n    }\n    function handleResize() {\n        if (containerRef.current) {\n            drawSolveTimeTrend(solves);\n        }\n    }\n    function computeRollingAverage(data, windowSize) {\n        const rollingAvg = data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null;\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n        console.log(\"Window Size: \".concat(windowSize));\n        console.log(\"Original Data Length: \".concat(data.length));\n        console.log(\"Rolling Average (\".concat(windowSize, \") Length: \").concat(rollingAvg.length));\n        console.log(\"First Values:\", rollingAvg.slice(0, 15)); // Check first few values\n        console.log(\"Last Values:\", rollingAvg.slice(-15)); // Check last few values\n        return rollingAvg;\n    }\n    function drawSolveTimeTrend(data) {\n        if (!containerRef.current) return;\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        const times = data.map((solve)=>solve.time / 1000);\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        let xScale = d3.scaleLinear().domain([\n            0,\n            times.length - 1\n        ]).range([\n            50,\n            width - 50\n        ]);\n        let yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]) // Flip domain to match SVG coords\n        .range([\n            50,\n            height - 50\n        ]); // Ensure bottom is lower on the screen\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale));\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom().scaleExtent([\n            0.5,\n            5\n        ]).translateExtent([\n            [\n                0,\n                0\n            ],\n            [\n                width,\n                height\n            ]\n        ]).on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale));\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // âœ… Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 80)\")); // â¬‡ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        function autoscale(event) {\n            event.preventDefault(); // Stop default zoom behavior\n            event.stopPropagation(); // Prevent further event propagation\n            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity); // Reset to original zoom state\n        }\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"ðŸ”„ Updating Plot with New Scales:\");\n            console.log(\"ðŸŸ¢ New X Scale Domain:\", newXScale.domain());\n            console.log(\"ðŸŸ¢ New Y Scale Domain:\", newYScale.domain());\n            // âœ… Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            console.log(\"âœ” Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"âœ” Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"âš ï¸ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"âš ï¸ No AO12 points found in updatePlot!\");\n            // âœ… Update all AO5 points\n            ao5Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // âœ… Update all AO12 points\n            ao12Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // âœ… Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // âœ… Update single solve points\n            svg.selectAll('.point-single').attr('cx', (_, i)=>newXScale(i)).attr('cy', (_, i)=>newYScale(times[i]));\n            // âœ… Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(times[i])));\n            // âœ… Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao5[i])));\n            // âœ… Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao12[i])));\n        }\n        svg.append('path').datum(times).attr('class', 'line line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao5).attr('class', 'line line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao12).attr('class', 'line line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2);\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, i) {\n            var _times_i, _ao5_i, _ao12_i;\n            const singleTime = (_times_i = times[i]) === null || _times_i === void 0 ? void 0 : _times_i.toFixed(2);\n            const ao5Time = ao5[i] !== null ? (_ao5_i = ao5[i]) === null || _ao5_i === void 0 ? void 0 : _ao5_i.toFixed(2) : '-';\n            const ao12Time = ao12[i] !== null ? (_ao12_i = ao12[i]) === null || _ao12_i === void 0 ? void 0 : _ao12_i.toFixed(2) : '-';\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // âœ… Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // âœ… Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // âœ… Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"âœ” Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color).on('mouseover', (event, d)=>showTooltip(event, d.x)).on('mouseout', hideTooltip);\n        }\n        // âœ… Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n        const controls = d3.select(containerRef.current).append('div').attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow');\n        controls.append('button').text('Autoscale').style('margin-right', '5px').on('click', autoscale);\n        controls.append('button').text('Switch to Time View').style('margin-right', '5px').on('click', ()=>setShowIndexView(true));\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaIndex.js\",\n        lineNumber: 362,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"cb8EW0/KlcsXOY9aljtB9hyEhOs=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYUluZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFMEM7QUFDMUMsTUFBTUUsS0FBSyxNQUFNLDRNQUFZO0FBQ2E7QUFFM0IsU0FBU0UsZUFBZSxLQUFVO1FBQVYsRUFBRUMsTUFBTSxFQUFFLEdBQVY7O0lBQ25DLE1BQU1DLGVBQWVMLDZDQUFNQSxDQUFDO0lBRTVCLE1BQU0sQ0FBQ00sZUFBZUMsaUJBQWlCLEdBQUdDLFNBQVM7SUFFbkRULGdEQUFTQTtvQ0FBQztZQUNOLElBQUksQ0FBQ0ssVUFBVSxDQUFDSyxNQUFNQyxPQUFPLENBQUNOLFdBQVdBLE9BQU9PLE1BQU0sS0FBSyxHQUFHLFFBQVEsNEJBQTRCO1lBQ2xHLElBQUlOLGFBQWFPLE9BQU8sRUFBRTtnQkFDdEJDLG1CQUFtQlQ7Z0JBQ25CVSxPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVQztZQUN0QztZQUVBOzRDQUFPLElBQU1GLE9BQU9HLG1CQUFtQixDQUFDLFVBQVVEOztRQUN0RDttQ0FBRztRQUFDWjtLQUFPO0lBRVgsSUFBSUUsZUFBZTtRQUNmLHFCQUFPLDhEQUFDSDtZQUFlQyxRQUFRQTs7Ozs7O0lBQ25DO0lBRUEsU0FBU1k7UUFDTCxJQUFJWCxhQUFhTyxPQUFPLEVBQUU7WUFDdEJDLG1CQUFtQlQ7UUFDdkI7SUFDSjtJQUVBLFNBQVNjLHNCQUFzQkMsSUFBSSxFQUFFQyxVQUFVO1FBQzNDLE1BQU1DLGFBQWFGLEtBQUtHLEdBQUcsQ0FBQyxDQUFDQyxHQUFHQyxHQUFHQztZQUMvQixJQUFJRCxJQUFJSixhQUFhLEdBQUcsT0FBTztZQUMvQixNQUFNTSxTQUFTRCxJQUFJRSxLQUFLLENBQUNILElBQUtKLENBQUFBLGFBQWEsSUFBSUksSUFBSTtZQUNuRCxPQUFPRSxPQUFPRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsTUFBUUQsTUFBTUMsS0FBSyxLQUFLSixPQUFPZixNQUFNO1FBQ3BFO1FBRUFv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TTlELGlCQUFpQjtJQUM1QztJQUVBLHFCQUNJLDhEQUFDb0g7UUFDR0MsS0FBS3ZIO1FBQ0w4RyxXQUFVOzs7Ozs7QUFHdEI7R0F4V3dCaEg7S0FBQUEiLCJzb3VyY2VzIjpbIkU6XFxXcGlcXFJlZ3VsYXJseVxcQ291cnNlc1xcU3JcXDIwMjRfQ19UZXJtXFxDUzQyNDFcXEhXXFxmaW5hbC1wcm9qZWN0LWtlcm1pdC10aGUtZnJvZ1xcc3JjXFxhcHBcXGRhdGFWaXNcXFRyZW5kQW5hSW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmNvbnN0IGQzID0gYXdhaXQgaW1wb3J0KCdkMycpO1xyXG5pbXBvcnQgVHJlbmRBbmFUaW1lIGZyb20gJy4vVHJlbmRBbmFUaW1lJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNvbHZlVGltZVRyZW5kKHsgc29sdmVzIH0pIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcclxuXHJcbiAgICBjb25zdCBbc2hvd0luZGV4Vmlldywgc2V0U2hvd0luZGV4Vmlld10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIXNvbHZlcyB8fCAhQXJyYXkuaXNBcnJheShzb2x2ZXMpIHx8IHNvbHZlcy5sZW5ndGggPT09IDApIHJldHVybjsgLy8g8J+UpSBFbnN1cmUgc29sdmVzIGlzIHZhbGlkXHJcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGRyYXdTb2x2ZVRpbWVUcmVuZChzb2x2ZXMpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgIH0sIFtzb2x2ZXNdKTtcclxuXHJcbiAgICBpZiAoc2hvd0luZGV4Vmlldykge1xyXG4gICAgICAgIHJldHVybiA8U29sdmVUaW1lVHJlbmQgc29sdmVzPXtzb2x2ZXN9IC8+O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcclxuICAgICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgZHJhd1NvbHZlVGltZVRyZW5kKHNvbHZlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVSb2xsaW5nQXZlcmFnZShkYXRhLCB3aW5kb3dTaXplKSB7XHJcbiAgICAgICAgY29uc3Qgcm9sbGluZ0F2ZyA9IGRhdGEubWFwKChfLCBpLCBhcnIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGkgPCB3aW5kb3dTaXplIC0gMSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnNldCA9IGFyci5zbGljZShpIC0gKHdpbmRvd1NpemUgLSAxKSwgaSArIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3Vic2V0LnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkgLyBzdWJzZXQubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgV2luZG93IFNpemU6ICR7d2luZG93U2l6ZX1gKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgT3JpZ2luYWwgRGF0YSBMZW5ndGg6ICR7ZGF0YS5sZW5ndGh9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFJvbGxpbmcgQXZlcmFnZSAoJHt3aW5kb3dTaXplfSkgTGVuZ3RoOiAke3JvbGxpbmdBdmcubGVuZ3RofWApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBGaXJzdCBWYWx1ZXM6YCwgcm9sbGluZ0F2Zy5zbGljZSgwLCAxNSkpOyAvLyBDaGVjayBmaXJzdCBmZXcgdmFsdWVzXHJcbiAgICAgICAgY29uc29sZS5sb2coYExhc3QgVmFsdWVzOmAsIHJvbGxpbmdBdmcuc2xpY2UoLTE1KSk7IC8vIENoZWNrIGxhc3QgZmV3IHZhbHVlc1xyXG5cclxuICAgICAgICByZXR1cm4gcm9sbGluZ0F2ZztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U29sdmVUaW1lVHJlbmQoZGF0YSkge1xyXG4gICAgICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KTtcclxuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gY29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCB8fCA1MDA7XHJcblxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IGNvbnRhaW5lci5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICcxMDAlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsICcxMDAlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApXHJcbiAgICAgICAgICAgIC5hdHRyKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaWRZTWlkIG1lZXQnKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGltZXMgPSBkYXRhLm1hcCgoc29sdmUpID0+IHNvbHZlLnRpbWUgLyAxMDAwKTtcclxuICAgICAgICBjb25zdCBhbzUgPSBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UodGltZXMsIDUpO1xyXG4gICAgICAgIGNvbnN0IGFvMTIgPSBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UodGltZXMsIDEyKTtcclxuXHJcbiAgICAgICAgbGV0IHhTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLmRvbWFpbihbMCwgdGltZXMubGVuZ3RoIC0gMV0pXHJcbiAgICAgICAgICAgIC5yYW5nZShbNTAsIHdpZHRoIC0gNTBdKTtcclxuXHJcbiAgICAgICAgbGV0IHlTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLmRvbWFpbihbZDMubWF4KHRpbWVzKSwgZDMubWluKHRpbWVzKV0pICAvLyBGbGlwIGRvbWFpbiB0byBtYXRjaCBTVkcgY29vcmRzXHJcbiAgICAgICAgICAgIC5yYW5nZShbNTAsIGhlaWdodCAtIDUwXSk7IC8vIEVuc3VyZSBib3R0b20gaXMgbG93ZXIgb24gdGhlIHNjcmVlblxyXG5cclxuICAgICAgICBjb25zdCB4QXhpcyA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneC1heGlzJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtoZWlnaHQgLSA1MH0pYClcclxuICAgICAgICAgICAgLmNhbGwoZDMuYXhpc0JvdHRvbSh4U2NhbGUpKTtcclxuXHJcbiAgICAgICAgY29uc3QgeUF4aXMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ktYXhpcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDUwLCAwKWApXHJcbiAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNMZWZ0KHlTY2FsZSkpO1xyXG5cclxuICAgICAgICBjb25zdCBncmlkR3JvdXAgPSBzdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnZ3JpZCcpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBkcmF3R3JpZCh4U2NhbGUsIHlTY2FsZSkge1xyXG4gICAgICAgICAgICBncmlkR3JvdXAuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIGdyaWQgbGluZXNcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnLmhvcml6b250YWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh5U2NhbGUudGlja3MoMTApKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hvcml6b250YWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHdpZHRoIC0gNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBkID0+IHlTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGQgPT4geVNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjY2NjJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgJzQsNCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gVmVydGljYWwgZ3JpZCBsaW5lc1xyXG4gICAgICAgICAgICBncmlkR3JvdXAuc2VsZWN0QWxsKCcudmVydGljYWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh4U2NhbGUudGlja3MoMTApKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ZlcnRpY2FsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZCA9PiB4U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBkID0+IHhTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgaGVpZ2h0IC0gNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAnNCw0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkcmF3R3JpZCh4U2NhbGUsIHlTY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHpvb20gPSBkMy56b29tKClcclxuICAgICAgICAgICAgLnNjYWxlRXh0ZW50KFswLjUsIDVdKVxyXG4gICAgICAgICAgICAudHJhbnNsYXRlRXh0ZW50KFtbMCwgMF0sIFt3aWR0aCwgaGVpZ2h0XV0pXHJcbiAgICAgICAgICAgIC5vbignem9vbScsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZXZlbnQudHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3WFNjYWxlID0gdHJhbnNmb3JtLnJlc2NhbGVYKHhTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdZU2NhbGUgPSB0cmFuc2Zvcm0ucmVzY2FsZVkoeVNjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHBsb3RzXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVQbG90KG5ld1hTY2FsZSwgbmV3WVNjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYXhlc1xyXG4gICAgICAgICAgICAgICAgeEF4aXMuY2FsbChkMy5heGlzQm90dG9tKG5ld1hTY2FsZSkpO1xyXG4gICAgICAgICAgICAgICAgeUF4aXMuY2FsbChkMy5heGlzTGVmdChuZXdZU2NhbGUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ3JpZCB3aXRoIG5ldyBzY2FsZXNcclxuICAgICAgICAgICAgICAgIGRyYXdHcmlkKG5ld1hTY2FsZSwgbmV3WVNjYWxlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHN2Zy5jYWxsKHpvb20pO1xyXG5cclxuICAgICAgICAvLyDinIUgQWRkIExlZ2VuZHMgKEJlbG93IEF1dG9zY2FsZSBCdXR0b24pXHJcbiAgICAgICAgY29uc3QgbGVnZW5kID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7d2lkdGggLSAxMjB9LCA4MClgKTsgLy8g4qyHIE1vdmVzIGxlZ2VuZCBsb3dlciB1bmRlciBidXR0b25cclxuXHJcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbXMgPSBbXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdibHVlJywgbGFiZWw6ICdTaW5nbGUnIH0sXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdncmVlbicsIGxhYmVsOiAnQU81JyB9LFxyXG4gICAgICAgICAgICB7IGNvbG9yOiAncmVkJywgbGFiZWw6ICdBTzEyJyB9XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgbGVnZW5kSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZWdlbmQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaSAqIDIwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGl0ZW0uY29sb3IpO1xyXG5cclxuICAgICAgICAgICAgbGVnZW5kLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDIwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBpICogMjAgKyAxMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnMTJweCcpXHJcbiAgICAgICAgICAgICAgICAudGV4dChpdGVtLmxhYmVsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYXV0b3NjYWxlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFN0b3AgZGVmYXVsdCB6b29tIGJlaGF2aW9yXHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50IGZ1cnRoZXIgZXZlbnQgcHJvcGFnYXRpb25cclxuXHJcbiAgICAgICAgICAgIHN2Zy50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXHJcbiAgICAgICAgICAgICAgICAuY2FsbCh6b29tLnRyYW5zZm9ybSwgZDMuem9vbUlkZW50aXR5KTsgLy8gUmVzZXQgdG8gb3JpZ2luYWwgem9vbSBzdGF0ZVxyXG4gICAgICAgIH1cclxuXHJcbi8vIEVuc3VyZSBldmVudCBpcyBwYXNzZWQgdG8gYXV0b3NjYWxlXHJcbiAgICAgICAgc3ZnLm9uKCdkYmxjbGljaycsIChldmVudCkgPT4gYXV0b3NjYWxlKGV2ZW50KSk7XHJcblxyXG4vLyBBbHNvIGV4cGxpY2l0bHkgZGlzYWJsZSB6b29tIG9uIGRvdWJsZS1jbGljayB0byBwcmV2ZW50IHpvb21pbmcgaW5cclxuICAgICAgICBzdmcuY2FsbCh6b29tKS5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBsb3QobmV3WFNjYWxlLCBuZXdZU2NhbGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5SEIFVwZGF0aW5nIFBsb3Qgd2l0aCBOZXcgU2NhbGVzOlwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5+iIE5ldyBYIFNjYWxlIERvbWFpbjpcIiwgbmV3WFNjYWxlLmRvbWFpbigpKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5+iIE5ldyBZIFNjYWxlIERvbWFpbjpcIiwgbmV3WVNjYWxlLmRvbWFpbigpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgdGhhdCB0aGUgQU81IGFuZCBBTzEyIHBvaW50cyBhcmUgY29ycmVjdGx5IGJvdW5kXHJcbiAgICAgICAgICAgIGNvbnN0IGFvNVNlbGVjdGlvbiA9IHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1hbzUnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoYW81Lm1hcCgodmFsLCBpKSA9PiAoeyB4OiBpLCB5OiB2YWwgfSkpLCBkID0+IGQueCk7IC8vIEVuc3VyZSB1bmlxdWUga2V5IGJpbmRpbmdcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFvMTJTZWxlY3Rpb24gPSBzdmcuc2VsZWN0QWxsKCcucG9pbnQtYW8xMicpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShhbzEyLm1hcCgodmFsLCBpKSA9PiAoeyB4OiBpLCB5OiB2YWwgfSkpLCBkID0+IGQueCk7IC8vIEVuc3VyZSB1bmlxdWUga2V5IGJpbmRpbmdcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJQgVG90YWwgQU81IFBvaW50cyBTZWxlY3RlZDogJHthbzVTZWxlY3Rpb24uc2l6ZSgpfSAoRXhwZWN0ZWQ6ICR7YW81Lmxlbmd0aH0pYCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJQgVG90YWwgQU8xMiBQb2ludHMgU2VsZWN0ZWQ6ICR7YW8xMlNlbGVjdGlvbi5zaXplKCl9IChFeHBlY3RlZDogJHthbzEyLmxlbmd0aH0pYCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYW81U2VsZWN0aW9uLnNpemUoKSA9PT0gMCkgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIEFPNSBwb2ludHMgZm91bmQgaW4gdXBkYXRlUGxvdCFcIik7XHJcbiAgICAgICAgICAgIGlmIChhbzEyU2VsZWN0aW9uLnNpemUoKSA9PT0gMCkgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIEFPMTIgcG9pbnRzIGZvdW5kIGluIHVwZGF0ZVBsb3QhXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBhbGwgQU81IHBvaW50c1xyXG4gICAgICAgICAgICBhbzVTZWxlY3Rpb24uYXR0cignY3gnLCBkID0+IG5ld1hTY2FsZShkLngpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBuZXdZU2NhbGUoZC55KSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIGFsbCBBTzEyIHBvaW50c1xyXG4gICAgICAgICAgICBhbzEyU2VsZWN0aW9uLmF0dHIoJ2N4JywgZCA9PiBuZXdYU2NhbGUoZC54KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4gbmV3WVNjYWxlKGQueSkpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIERlYnVnZ2luZzogRW5zdXJlIGxhc3QgQU81ICYgQU8xMiBwb2ludHMgdXBkYXRlIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBhbzVTZWxlY3Rpb24uZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYW81Lmxlbmd0aCAtIDQpIHsgLy8gVXNlIGBhbzUubGVuZ3RoYCB0byBjb3JyZWN0bHkgaXRlcmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5+iIEFPNSBQb2ludCAke2l9OiB4PSR7bmV3WFNjYWxlKGQueCl9LCB5PSR7bmV3WVNjYWxlKGQueSl9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYW8xMlNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhbzEyLmxlbmd0aCAtIDEyKSB7IC8vIFVzZSBgYW8xMi5sZW5ndGhgIHRvIGNvcnJlY3RseSBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflLQgQU8xMiBQb2ludCAke2l9OiB4PSR7bmV3WFNjYWxlKGQueCl9LCB5PSR7bmV3WVNjYWxlKGQueSl9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBzaW5nbGUgc29sdmUgcG9pbnRzXHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1zaW5nbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgKF8sIGkpID0+IG5ld1hTY2FsZShpKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIChfLCBpKSA9PiBuZXdZU2NhbGUodGltZXNbaV0pKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgc2luZ2xlIHNvbHZlIGxpbmVcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtc2luZ2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KChfLCBpKSA9PiBuZXdYU2NhbGUoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoKF8sIGkpID0+IG5ld1lTY2FsZSh0aW1lc1tpXSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSBBTzUgbGluZSBhbGlnbnMgZHluYW1pY2FsbHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtYW81JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKChfLCBpKSA9PiBpID49IDQgJiYgYW81W2ldICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KChfLCBpKSA9PiBuZXdYU2NhbGUoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoKF8sIGkpID0+IG5ld1lTY2FsZShhbzVbaV0pKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgQU8xMiBsaW5lIGFsaWducyBkeW5hbWljYWxseVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1hbzEyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKChfLCBpKSA9PiBpID49IDExICYmIGFvMTJbaV0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoKF8sIGkpID0+IG5ld1hTY2FsZShpKSlcclxuICAgICAgICAgICAgICAgICAgICAueSgoXywgaSkgPT4gbmV3WVNjYWxlKGFvMTJbaV0pKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZGF0dW0odGltZXMpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lIGxpbmUtc2luZ2xlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibHVlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXR1bShhbzUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lIGxpbmUtYW81JylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdncmVlbicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XHJcblxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZGF0dW0oYW8xMilcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUgbGluZS1hbzEyJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdyZWQnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xyXG5cclxuICAgICAgICBjb25zdCB0b29sdGlwID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdhYnNvbHV0ZSBiZy13aGl0ZSBwLTIgYm9yZGVyIHJvdW5kZWQgc2hhZG93IHRleHQtc20nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJylcclxuICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBzaG93VG9vbHRpcChldmVudCwgaSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaW5nbGVUaW1lID0gdGltZXNbaV0/LnRvRml4ZWQoMik7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvNVRpbWUgPSBhbzVbaV0gIT09IG51bGwgPyBhbzVbaV0/LnRvRml4ZWQoMikgOiAnLSc7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvMTJUaW1lID0gYW8xMltpXSAhPT0gbnVsbCA/IGFvMTJbaV0/LnRvRml4ZWQoMikgOiAnLSc7XHJcblxyXG4gICAgICAgICAgICB0b29sdGlwLmh0bWwoYFxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPlNpbmdsZTo8L3N0cm9uZz4gJHtzaW5nbGVUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5BTzU6PC9zdHJvbmc+ICR7YW81VGltZX1zPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+QU8xMjo8L3N0cm9uZz4gJHthbzEyVGltZX1zPC9kaXY+XHJcbiAgICAgICAgICAgIGApXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2ZpeGVkJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsICd3aGl0ZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BhZGRpbmcnLCAnNnB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm9yZGVyJywgJzFweCBzb2xpZCAjY2NjJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm9yZGVyLXJhZGl1cycsICc1cHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3gtc2hhZG93JywgJzJweCAycHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMSknKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCAnMTJweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd6LWluZGV4JywgJzEwMDAnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIC01MCUpJyk7XHJcblxyXG4gICAgICAgICAgICB0b29sdGlwLnN0eWxlKCdsZWZ0JywgYCR7ZXZlbnQucGFnZVggKyAxMn1weGApLnN0eWxlKCd0b3AnLCBgJHtldmVudC5wYWdlWX1weGApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaGlkZVRvb2x0aXAoKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdXBkYXRlUGxvdCh4U2NhbGUsIHlTY2FsZSk7ICAvLyDinIUgRm9yY2UgcmVuZGVyIGFmdGVyIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgfSwgMTAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkUG9pbnRzKGRhdGEsIGNvbG9yLCBjbGFzc05hbWUsIHZhbHVlQWNjZXNzb3IsIG1pbkluZGV4LCBsYWJlbCkge1xyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIHRoYXQgd2UgY29ycmVjdGx5IGl0ZXJhdGUgb3ZlciB0aGUgZnVsbCBkYXRhc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkUG9pbnRzID0gZGF0YVxyXG4gICAgICAgICAgICAgICAgLm1hcCgodmFsLCBpKSA9PiAoeyB4OiBpLCB5OiB2YWx1ZUFjY2Vzc29yKGkpIH0pKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihkID0+IGQueSAhPT0gbnVsbCAmJiBkLnggPj0gbWluSW5kZXgpOyAvLyDinIUgUmVtb3ZlZCB4IDwgdGltZXMubGVuZ3RoIGNvbnN0cmFpbnRcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBcXG7wn5+iIEFkZGluZyBQb2ludHMgZm9yICR7bGFiZWx9IHwgQ2xhc3M6ICR7Y2xhc3NOYW1lfSB8IE1pbkluZGV4OiAke21pbkluZGV4fWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFZhbGlkIFBvaW50cyBDb3VudDogJHt2YWxpZFBvaW50cy5sZW5ndGh9YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5ONIEZpcnN0IDUgUG9pbnRzOmAsIHZhbGlkUG9pbnRzLnNsaWNlKDAsIDUpKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk40gTGFzdCA1IFBvaW50czpgLCB2YWxpZFBvaW50cy5zbGljZSgtNSkpO1xyXG5cclxuICAgICAgICAgICAgdmFsaWRQb2ludHMuZm9yRWFjaCgocG9pbnQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgICAgIGDwn5S1ICR7bGFiZWx9IFBvaW50ICR7aSArIG1pbkluZGV4fTogUmF3WD0ke3BvaW50Lnh9LCBTY2FsZWRYPSR7eFNjYWxlKHBvaW50LngpfSwgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFJhd1k9JHtwb2ludC55LnRvRml4ZWQoMyl9LCBTY2FsZWRZPSR7eVNjYWxlKHBvaW50LnkpLnRvRml4ZWQoMil9YFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgZGF0YSBiaW5kaW5nIGlzIGRvbmUgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoYC4ke2NsYXNzTmFtZX1gKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodmFsaWRQb2ludHMsIGQgPT4gZC54KSAvLyBFbnN1cmUgdW5pcXVlIGtleSBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICAuam9pbihcImNpcmNsZVwiKSAvLyBFbnN1cmUgcHJvcGVyIGJpbmRpbmdcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBwb2ludCAke2NsYXNzTmFtZX1gKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiB4U2NhbGUoZC54KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4geVNjYWxlKGQueSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGNvbG9yKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCAoZXZlbnQsIGQpID0+IHNob3dUb29sdGlwKGV2ZW50LCBkLngpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGhpZGVUb29sdGlwKTtcclxuICAgICAgICB9XHJcblxyXG4vLyDinIUgRW5zdXJlIEFPNSAmIEFPMTIgcG9pbnRzIGFyZSBmdWxseSBhZGRlZCBiZWZvcmUgdXBkYXRpbmdcclxuICAgICAgICBhZGRQb2ludHModGltZXMsICdibHVlJywgJ3BvaW50LXNpbmdsZScsIChpKSA9PiB0aW1lc1tpXSwgMCwgXCJTaW5nbGVcIik7XHJcbiAgICAgICAgYWRkUG9pbnRzKGFvNSwgJ2dyZWVuJywgJ3BvaW50LWFvNScsIChpKSA9PiBhbzVbaV0sIDQsIFwiQU81XCIpO1xyXG4gICAgICAgIGFkZFBvaW50cyhhbzEyLCAncmVkJywgJ3BvaW50LWFvMTInLCAoaSkgPT4gYW8xMltpXSwgMTEsIFwiQU8xMlwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbHMgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Fic29sdXRlIHRvcC0yIHJpZ2h0LTIgYmctd2hpdGUgcC0yIHJvdW5kZWQgc2hhZG93Jyk7XHJcblxyXG4gICAgICAgIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcclxuICAgICAgICAgICAgLnRleHQoJ0F1dG9zY2FsZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLXJpZ2h0JywgJzVweCcpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBhdXRvc2NhbGUpO1xyXG5cclxuICAgICAgICBjb250cm9scy5hcHBlbmQoJ2J1dHRvbicpXHJcbiAgICAgICAgICAgIC50ZXh0KCdTd2l0Y2ggdG8gVGltZSBWaWV3JylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tcmlnaHQnLCAnNXB4JylcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHNldFNob3dJbmRleFZpZXcodHJ1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICByZWY9e2NvbnRhaW5lclJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC1bY2FsYygxMDB2aC0xMDBweCldIGJnLXdoaXRlIHJlbGF0aXZlXCJcclxuICAgICAgICA+PC9kaXY+XHJcbiAgICApO1xyXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsImQzIiwiVHJlbmRBbmFUaW1lIiwiU29sdmVUaW1lVHJlbmQiLCJzb2x2ZXMiLCJjb250YWluZXJSZWYiLCJzaG93SW5kZXhWaWV3Iiwic2V0U2hvd0luZGV4VmlldyIsInVzZVN0YXRlIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiY3VycmVudCIsImRyYXdTb2x2ZVRpbWVUcmVuZCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVSZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29tcHV0ZVJvbGxpbmdBdmVyYWdlIiwiZGF0YSIsIndpbmRvd1NpemUiLCJyb2xsaW5nQXZnIiwibWFwIiwiXyIsImkiLCJhcnIiLCJzdWJzZXQiLCJzbGljZSIsInJlZHVjZSIsInN1bSIsInZhbCIsImNvbnNvbGUiLCJsb2ciLCJjb250YWluZXIiLCJzZWxlY3QiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic3ZnIiwiYXBwZW5kIiwiYXR0ciIsInRpbWVzIiwic29sdmUiLCJ0aW1lIiwiYW81IiwiYW8xMiIsInhTY2FsZSIsInNjYWxlTGluZWFyIiwiZG9tYWluIiwicmFuZ2UiLCJ5U2NhbGUiLCJtYXgiLCJtaW4iLCJ4QXhpcyIsImNhbGwiLCJheGlzQm90dG9tIiwieUF4aXMiLCJheGlzTGVmdCIsImdyaWRHcm91cCIsImRyYXdHcmlkIiwidGlja3MiLCJlbnRlciIsImQiLCJ6b29tIiwic2NhbGVFeHRlbnQiLCJ0cmFuc2xhdGVFeHRlbnQiLCJvbiIsImV2ZW50IiwidHJhbnNmb3JtIiwibmV3WFNjYWxlIiwicmVzY2FsZVgiLCJuZXdZU2NhbGUiLCJyZXNjYWxlWSIsInVwZGF0ZVBsb3QiLCJsZWdlbmQiLCJsZWdlbmRJdGVtcyIsImNvbG9yIiwibGFiZWwiLCJmb3JFYWNoIiwiaXRlbSIsInRleHQiLCJhdXRvc2NhbGUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsInpvb21JZGVudGl0eSIsImFvNVNlbGVjdGlvbiIsIngiLCJ5IiwiYW8xMlNlbGVjdGlvbiIsInNpemUiLCJ3YXJuIiwiZWFjaCIsImxpbmUiLCJjdXJ2ZSIsImN1cnZlTW9ub3RvbmVYIiwiZGVmaW5lZCIsImRhdHVtIiwidG9vbHRpcCIsInN0eWxlIiwic2hvd1Rvb2x0aXAiLCJzaW5nbGVUaW1lIiwidG9GaXhlZCIsImFvNVRpbWUiLCJhbzEyVGltZSIsImh0bWwiLCJwYWdlWCIsInBhZ2VZIiwiaGlkZVRvb2x0aXAiLCJzZXRUaW1lb3V0IiwiYWRkUG9pbnRzIiwiY2xhc3NOYW1lIiwidmFsdWVBY2Nlc3NvciIsIm1pbkluZGV4IiwidmFsaWRQb2ludHMiLCJmaWx0ZXIiLCJwb2ludCIsImpvaW4iLCJjb250cm9scyIsImRpdiIsInJlZiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js\n"));

/***/ })

});