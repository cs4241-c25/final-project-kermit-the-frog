"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dataVis/page",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"82e7a87ae099\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjgyZTdhODdhZTA5OVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js":
/*!*****************************************!*\
  !*** ./src/app/dataVis/TrendAnaTime.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n// import TrendAnaIndex from './TrendAnaIndex';\n// import TrendAnaTime from './TrendAnaTime';\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [currentClusterIndex, setCurrentClusterIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [clusters, setClusters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [xDomain, setXDomain] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const xDomainRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // const [currentPage, setCurrentPage] = useState('time');  // 'time' or 'index'\n    //\n    // function switchPage() {\n    //     setCurrentPage(prevPage => (prevPage === 'time' ? 'index' : 'time'));\n    // }\n    const [currentView, setCurrentView] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('TrendAnaTime'); // Default to TrendAnaTime\n    function switchView() {\n        setCurrentView((prevView)=>prevView === 'TrendAna' ? 'TrendAnaTime' : 'TrendAna');\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            console.log(\"🔄 XDomain or window size updated:\", xDomain);\n            if (!solves || solves.length === 0) {\n                console.warn(\"⚠️ No solves data available!\");\n                return;\n            }\n            const container = containerRef.current;\n            if (!container) {\n                console.warn(\"⚠️ Container reference is null!\");\n                return;\n            }\n            console.log(\"📏 Updating chart dimensions after resize...\");\n            drawSolveTimeTrend(solves);\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        xDomain,\n        containerRef\n    ]); // 🔥 Ensure chart updates when xDomain or container size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return;\n            console.log(\"🔍 Running cluster detection...\");\n            const detectedClusters = findClusters(solves);\n            setClusters(detectedClusters);\n            if (detectedClusters.length > 0) {\n                const firstCluster = detectedClusters[0];\n                const newDomain = [\n                    new Date(firstCluster[0].timestamp),\n                    new Date(firstCluster.slice(-1)[0].timestamp)\n                ];\n                setXDomain(newDomain);\n                xDomainRef.current = newDomain; // ✅ Ensure ref is updated\n                // ❗ Log AFTER setting the state to reflect the correct value\n                console.log(\"✅ X-Domain initialized to first cluster:\", newDomain);\n            }\n            // Attach resize event\n            window.addEventListener('resize', handleResize);\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]); // <-- Runs only on first load\n    function handleResize() {\n        console.log(\"🔄 Handling resize...\");\n        if (!solves || solves.length === 0) {\n            console.warn(\"⚠️ No solves available, skipping resize!\");\n            return;\n        }\n        let detectedClusters = clusters;\n        if (clusters.length === 0) {\n            console.warn(\"⚠️ No clusters available on resize! Refinding clusters...\");\n            detectedClusters = findClusters(solves);\n            setClusters(detectedClusters);\n        }\n        if (detectedClusters.length === 0) {\n            console.warn(\"⚠️ Still no clusters found after resize!\");\n            return;\n        }\n        const prevClusterIndex = currentClusterIndex;\n        const prevXDomain = xDomainRef.current;\n        console.log(\"\\uD83D\\uDCCC Preserving Cluster Index: \".concat(prevClusterIndex));\n        console.log(\"🔍 Preserving X-Domain before resize:\", prevXDomain);\n        // Ensure re-renders with correct states\n        setCurrentClusterIndex(prevClusterIndex);\n        setXDomain(prevXDomain);\n        xDomainRef.current = prevXDomain;\n        // ✅ Force state updates to re-enable buttons\n        setTimeout(()=>{\n            setClusters([\n                ...detectedClusters\n            ]);\n            setXDomain([\n                ...prevXDomain\n            ]);\n            setCurrentClusterIndex(prevClusterIndex);\n        }, 0);\n        // Redraw the chart after resize\n        drawSolveTimeTrend(solves);\n        console.log(\"✅ Resize handled, restoring states.\");\n    }\n    function findClusters(data) {\n        console.log(\"🔍 Running findClusters...\");\n        let detectedClusters = [];\n        let currentCluster = [\n            data[0]\n        ];\n        for(let i = 1; i < data.length; i++){\n            if (new Date(data[i].timestamp) - new Date(data[i - 1].timestamp) > 15 * 60 * 1000) {\n                if (currentCluster.length > 1) {\n                    const uniqueXValues = new Set(currentCluster.map((d)=>d.timestamp));\n                    if (uniqueXValues.size > 1) {\n                        detectedClusters.push(currentCluster);\n                    } else {\n                        console.warn(\"⚠️ Ignoring cluster with same X-Axis values:\", currentCluster);\n                    }\n                }\n                currentCluster = [];\n            }\n            currentCluster.push(data[i]);\n        }\n        // Check last cluster before adding it\n        if (currentCluster.length > 1) {\n            const uniqueXValues = new Set(currentCluster.map((d)=>d.timestamp));\n            if (uniqueXValues.size > 1) {\n                detectedClusters.push(currentCluster);\n            } else {\n                console.warn(\"⚠️ Ignoring cluster with same X-Axis values:\", currentCluster);\n            }\n        }\n        console.log(\"📊 Clusters identified (excluding single/same x-axis clusters):\", detectedClusters.length, detectedClusters);\n        return detectedClusters;\n    }\n    function computeRollingAverage(data, windowSize) {\n        return data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null; // ✅ Preserve nulls at the beginning\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n    }\n    function drawSolveTimeTrend(data) {\n        console.log(\"🔍 Current X-Domain in drawSolveTimeTrend:\", xDomainRef.current);\n        if (!containerRef.current) {\n            console.warn(\"⚠️ Container reference is null, cannot draw!\");\n            return;\n        }\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        console.log(\"📏 Chart dimensions:\", width, height);\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        // Ensure all data contains timestamps\n        const processedData = data.map((solve)=>{\n            if (!solve.timestamp) {\n                console.warn(\"⚠️ Skipping entry with missing timestamp:\", solve);\n                return null;\n            }\n            return {\n                timestamp: new Date(solve.timestamp),\n                time: solve.time / 1000\n            };\n        }).filter((d)=>d !== null); // Remove invalid entries\n        const timestamps = processedData.map((d)=>d.timestamp);\n        const times = processedData.map((d)=>d.time);\n        console.log(\"Processed timestamps:\", timestamps);\n        // 🔥 Find the first \"cluster\" (a short interval of data)\n        let clusterStartIndex = 0;\n        let clusterEndIndex = timestamps.length - 1;\n        for(let i = 1; i < timestamps.length; i++){\n            if (timestamps[i] - timestamps[0] > 15 * 60 * 1000) {\n                clusterEndIndex = i;\n                break;\n            }\n        }\n        // Extract the cluster time range\n        const initialXDomain = [\n            timestamps[clusterStartIndex],\n            timestamps[clusterEndIndex]\n        ];\n        console.log(\"⏳ Initial Focus X Domain: \".concat(initialXDomain[0], \" to \").concat(initialXDomain[1]));\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        const ao5Data = timestamps.map((timestamp, i)=>({\n                timestamp: timestamp,\n                value: ao5[i] !== null ? ao5[i] : null\n            })).filter((d)=>d.value !== null); // Remove initial nulls\n        const ao12Data = timestamps.map((timestamp, i)=>({\n                timestamp: timestamp,\n                value: ao12[i] !== null ? ao12[i] : null\n            })).filter((d)=>d.value !== null); // Remove initial nulls\n        var _xDomainRef_current;\n        // X Scale: Start zoomed into the identified cluster\n        let xScale = d3.scaleTime().domain((_xDomainRef_current = xDomainRef.current) !== null && _xDomainRef_current !== void 0 ? _xDomainRef_current : [\n            timestamps[0],\n            timestamps[timestamps.length - 1]\n        ]) // ✅ Use ref as fallback\n        .range([\n            50,\n            width - 50\n        ]);\n        console.log(\"📉 Applying X Scale domain in drawSolveTimeTrend:\", xScale.domain());\n        console.log(\"xScale range:\", xScale.range());\n        const yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]).range([\n            50,\n            height - 50\n        ]);\n        // Add X and Y axes\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M:%S')));\n        // Filter unique days for displaying date below\n        let lastDate = null;\n        xAxis.selectAll('text').attr('dy', '1.2em') // Move time labels up slightly\n        .each(function(d, i, nodes) {\n            const currentText = d3.select(this);\n            const dateStr = d3.timeFormat('%b %d, %Y')(new Date(d));\n            if (dateStr !== lastDate) {\n                currentText.append('tspan').attr('x', 0).attr('dy', '1.2em').text(dateStr);\n                lastDate = dateStr;\n            }\n        });\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom()// .scaleExtent([0.5, 5])\n        // .translateExtent([[0, 0], [width, height]])\n        .on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            console.log(\"Updated xScale domain:\", newXScale.domain());\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale).tickFormat(d3.timeFormat('%H:%M:%S')));\n            let lastZoomDate = null;\n            xAxis.selectAll('text').attr('dy', '1.2em').each(function(d, i, nodes) {\n                const currentText = d3.select(this);\n                const dateStr = d3.timeFormat('%b %d, %Y')(new Date(d));\n                if (dateStr !== lastZoomDate) {\n                    currentText.append('tspan').attr('x', 0).attr('dy', '1.2em').text(dateStr);\n                    lastZoomDate = dateStr;\n                }\n            });\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // ✅ Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 80)\")); // ⬇ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"🔄 Updating Plot with New Scales:\");\n            console.log(\"🟢 New X Scale Domain:\", newXScale.domain());\n            console.log(\"🟢 New Y Scale Domain:\", newYScale.domain());\n            // ✅ Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5Data, (d)=>d.timestamp).join('circle').attr('class', 'point-ao5').attr('cx', (d)=>xScale(new Date(d.timestamp))) // Align with timestamps\n            .attr('cy', (d)=>yScale(d.value)).attr('r', 5).attr('fill', 'green').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12Data, (d)=>d.timestamp).join('circle').attr('class', 'point-ao12').attr('cx', (d)=>xScale(new Date(d.timestamp))) // Align with timestamps\n            .attr('cy', (d)=>yScale(d.value)).attr('r', 5).attr('fill', 'red').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            console.log(\"✔ Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"✔ Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"⚠️ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"⚠️ No AO12 points found in updatePlot!\");\n            // ✅ Update all AO5 points correctly\n            ao5Selection.attr('cx', (d)=>newXScale(new Date(d.timestamp))).attr('cy', (d)=>newYScale(d.value)); // ✅ Use d.value for AO5\n            // ✅ Update all AO12 points correctly\n            ao12Selection.attr('cx', (d)=>newXScale(new Date(d.timestamp))).attr('cy', (d)=>newYScale(d.value)); // ✅ Use d.value for AO12\n            // ✅ Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // ✅ Update single solve points\n            svg.selectAll('.point-single').data(processedData, (d)=>d.timestamp).join('circle').attr('class', 'point-single').attr('cx', (d)=>newXScale(new Date(d.timestamp))) // FIX: Use newXScale\n            .attr('cy', (d)=>newYScale(d.time)) // FIX: Use newYScale\n            .attr('r', 5).attr('fill', 'blue').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            // ✅ Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.time)));\n            // ✅ Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').datum(ao5.map((val, i)=>({\n                    timestamp: timestamps[i],\n                    value: val\n                }))).attr('d', d3.line().curve(d3.curveMonotoneX).defined((d)=>d.value !== null).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.value)));\n            // ✅ Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').datum(ao12.map((val, i)=>({\n                    timestamp: timestamps[i],\n                    value: val\n                }))).attr('d', d3.line().curve(d3.curveMonotoneX).defined((d)=>d.value !== null).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.value)));\n        }\n        svg.append('path').datum(processedData).attr('class', 'line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).x((d)=>xScale(new Date(d.timestamp))).y((d)=>yScale(d.time)));\n        svg.selectAll('.line-ao5').data([\n            ao5\n        ]) // ✅ Use .data([]) instead of .datum()\n        .join(\"path\").attr('class', 'line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>xScale(new Date(timestamps[i]))) // ✅ Use timestamps\n        .y((_, i)=>yScale(ao5[i])));\n        svg.selectAll('.line-ao12').data([\n            ao12\n        ]) // ✅ Use .data([]) instead of .datum()\n        .join(\"path\").attr('class', 'line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>xScale(new Date(timestamps[i]))) // ✅ Use timestamps\n        .y((_, i)=>yScale(ao12[i])));\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, timestamp) {\n            if (!timestamp) {\n                console.warn(\"⚠️ showTooltip called with invalid timestamp:\", timestamp);\n                return;\n            }\n            // Find all data points with the same timestamp\n            const singleData = processedData.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const ao5DataPoint = ao5Data.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const ao12DataPoint = ao12Data.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const singleTime = singleData ? singleData.time.toFixed(2) : \"-\";\n            const ao5Time = ao5DataPoint ? ao5DataPoint.value.toFixed(2) : \"-\";\n            const ao12Time = ao12DataPoint ? ao12DataPoint.value.toFixed(2) : \"-\";\n            console.log(\"\\uD83D\\uDFE2 Showing tooltip for timestamp \".concat(timestamp, \": Single=\").concat(singleTime, \", AO5=\").concat(ao5Time, \", AO12=\").concat(ao12Time));\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // ✅ Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // ✅ Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // ✅ Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"✔ Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color);\n        }\n        // ✅ Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n        const controls = d3.select(containerRef.current).append('div').attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow');\n        controls.append('button').text('Previous Cluster').style('margin-right', '5px').attr('disabled', clusters.length === 0 || currentClusterIndex === 0 ? 'disabled' : null).on('click', prevCluster);\n        controls.append('button').text('Next Cluster').style('margin-right', '5px').attr('disabled', clusters.length === 0 || currentClusterIndex >= clusters.length - 1 ? 'disabled' : null).on('click', nextCluster);\n        controls.append('button').text('Autoscale').style('margin-right', '5px').on('click', autoscale);\n        function autoscale() {\n            console.log(\"🔍 Autoscale triggered...\");\n            if (!clusters || clusters.length === 0) {\n                console.warn(\"⚠️ No clusters available for autoscale!\");\n                return;\n            }\n            console.log(\"📌 Autoscaling to first cluster...\");\n            setCurrentClusterIndex(0);\n            const firstCluster = clusters[0];\n            if (!firstCluster || firstCluster.length === 0) {\n                console.warn(\"⚠️ First cluster is empty, cannot autoscale!\");\n                return;\n            }\n            const newDomain = [\n                new Date(firstCluster[0].timestamp),\n                new Date(firstCluster.slice(-1)[0].timestamp)\n            ];\n            console.log(\"✅ Setting autoscale X-Domain to:\", newDomain);\n            setXDomain(newDomain);\n            xDomainRef.current = newDomain;\n            // ✅ Force React to update UI state\n            setTimeout(()=>{\n                setClusters([\n                    ...clusters\n                ]); // Force re-evaluation of clusters state\n            }, 0);\n        }\n        function nextCluster() {\n            console.log(\"➡️ Next cluster clicked...\");\n            if (currentClusterIndex < clusters.length - 1) {\n                const nextIndex = currentClusterIndex + 1;\n                console.log(\"📌 Moving to next cluster:\", nextIndex);\n                setCurrentClusterIndex(nextIndex);\n                const newDomain = [\n                    new Date(clusters[nextIndex][0].timestamp),\n                    new Date(clusters[nextIndex].slice(-1)[0].timestamp)\n                ];\n                setXDomain(newDomain);\n                xDomainRef.current = newDomain;\n            } else {\n                console.warn(\"⚠️ No next cluster available!\");\n            }\n        }\n        function prevCluster() {\n            console.log(\"⬅️ Previous cluster clicked...\");\n            if (currentClusterIndex > 0) {\n                const prevIndex = currentClusterIndex - 1;\n                console.log(\"📌 Moving to previous cluster:\", prevIndex);\n                setCurrentClusterIndex(prevIndex);\n                const newDomain = [\n                    new Date(clusters[prevIndex][0].timestamp),\n                    new Date(clusters[prevIndex].slice(-1)[0].timestamp)\n                ];\n                setXDomain(newDomain);\n                xDomainRef.current = newDomain;\n            } else {\n                console.warn(\"⚠️ No previous cluster available!\");\n            }\n        }\n    }\n    // return (\n    //     <div className=\"w-screen h-[calc(100vh-100px)] bg-white relative\">\n    //         {/* 🔘 Switch Button */}\n    //         <div className=\"absolute top-2 right-2 bg-white p-2 rounded shadow\">\n    //             <button\n    //                 className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-700 transition\"\n    //                 onClick={switchPage}\n    //             >\n    //                 Switch\n    //             </button>\n    //         </div>\n    //\n    //         {/* Render the selected page dynamically */}\n    //         {currentPage === 'time' ? <TrendAnaTime solves={solves} /> : <TrendAnaIndex solves={solves} />}\n    //     </div>\n    // );\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n        lineNumber: 700,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"yPMTfML/buc14h71CiUtCDB7PZA=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYVRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUVvRDtBQUNwRCwrQ0FBK0M7QUFDL0MsNkNBQTZDO0FBQzdDLE1BQU1HLEtBQUssTUFBTSw0TUFBWTtBQUVkLFNBQVNDLGVBQWUsS0FBVTtRQUFWLEVBQUVDLE1BQU0sRUFBRSxHQUFWOztJQUNuQyxNQUFNQyxlQUFlTCw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNLENBQUNNLHFCQUFxQkMsdUJBQXVCLEdBQUdOLCtDQUFRQSxDQUFDO0lBQy9ELE1BQU0sQ0FBQ08sVUFBVUMsWUFBWSxHQUFHUiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQzNDLE1BQU0sQ0FBQ1MsU0FBU0MsV0FBVyxHQUFHViwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNVyxhQUFhWiw2Q0FBTUEsQ0FBQztJQUMxQixnRkFBZ0Y7SUFDaEYsRUFBRTtJQUNGLDBCQUEwQjtJQUMxQiw0RUFBNEU7SUFDNUUsSUFBSTtJQUNKLE1BQU0sQ0FBQ2EsYUFBYUMsZUFBZSxHQUFHYiwrQ0FBUUEsQ0FBQyxpQkFBaUIsMEJBQTBCO0lBRTFGLFNBQVNjO1FBQ0xELGVBQWVFLENBQUFBLFdBQWFBLGFBQWEsYUFBYSxpQkFBaUI7SUFDM0U7SUFFQWpCLGdEQUFTQTtvQ0FBQztZQUNOa0IsUUFBUUMsR0FBRyxDQUFDLHNDQUFzQ1I7WUFFbEQsSUFBSSxDQUFDTixVQUFVQSxPQUFPZSxNQUFNLEtBQUssR0FBRztnQkFDaENGLFFBQVFHLElBQUksQ0FBQztnQkFDYjtZQUNKO1lBRUEsTUFBTUMsWUFBWWhCLGFBQWFpQixPQUFPO1lBQ3RDLElBQUksQ0FBQ0QsV0FBVztnQkFDWkosUUFBUUcsSUFBSSxDQUFDO2dCQUNiO1lBQ0o7WUFFQUgsUUFBUUMsR0FBRyxDQUFDO1lBQ1pLLG1CQUFtQm5CO1FBQ3ZCO21DQUFHO1FBQUNNO1FBQVNMO0tBQWEsR0FBSSxpRUFBaUU7SUFFL0ZOLGdEQUFTQTtv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QUNMaUosV0FBVTs7Ozs7O0FBR3RCO0dBenJCd0JuSjtLQUFBQSIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxTclxcMjAyNF9DX1Rlcm1cXENTNDI0MVxcSFdcXGZpbmFsLXByb2plY3Qta2VybWl0LXRoZS1mcm9nXFxzcmNcXGFwcFxcZGF0YVZpc1xcVHJlbmRBbmFUaW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuLy8gaW1wb3J0IFRyZW5kQW5hSW5kZXggZnJvbSAnLi9UcmVuZEFuYUluZGV4JztcclxuLy8gaW1wb3J0IFRyZW5kQW5hVGltZSBmcm9tICcuL1RyZW5kQW5hVGltZSc7XHJcbmNvbnN0IGQzID0gYXdhaXQgaW1wb3J0KCdkMycpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU29sdmVUaW1lVHJlbmQoeyBzb2x2ZXMgfSkge1xyXG4gICAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3QgW2N1cnJlbnRDbHVzdGVySW5kZXgsIHNldEN1cnJlbnRDbHVzdGVySW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbY2x1c3RlcnMsIHNldENsdXN0ZXJzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIGNvbnN0IFt4RG9tYWluLCBzZXRYRG9tYWluXSA9IHVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgeERvbWFpblJlZiA9IHVzZVJlZihudWxsKTtcclxuICAgIC8vIGNvbnN0IFtjdXJyZW50UGFnZSwgc2V0Q3VycmVudFBhZ2VdID0gdXNlU3RhdGUoJ3RpbWUnKTsgIC8vICd0aW1lJyBvciAnaW5kZXgnXHJcbiAgICAvL1xyXG4gICAgLy8gZnVuY3Rpb24gc3dpdGNoUGFnZSgpIHtcclxuICAgIC8vICAgICBzZXRDdXJyZW50UGFnZShwcmV2UGFnZSA9PiAocHJldlBhZ2UgPT09ICd0aW1lJyA/ICdpbmRleCcgOiAndGltZScpKTtcclxuICAgIC8vIH1cclxuICAgIGNvbnN0IFtjdXJyZW50Vmlldywgc2V0Q3VycmVudFZpZXddID0gdXNlU3RhdGUoJ1RyZW5kQW5hVGltZScpOyAvLyBEZWZhdWx0IHRvIFRyZW5kQW5hVGltZVxyXG5cclxuICAgIGZ1bmN0aW9uIHN3aXRjaFZpZXcoKSB7XHJcbiAgICAgICAgc2V0Q3VycmVudFZpZXcocHJldlZpZXcgPT4gKHByZXZWaWV3ID09PSAnVHJlbmRBbmEnID8gJ1RyZW5kQW5hVGltZScgOiAnVHJlbmRBbmEnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflIQgWERvbWFpbiBvciB3aW5kb3cgc2l6ZSB1cGRhdGVkOlwiLCB4RG9tYWluKTtcclxuXHJcbiAgICAgICAgaWYgKCFzb2x2ZXMgfHwgc29sdmVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gc29sdmVzIGRhdGEgYXZhaWxhYmxlIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIENvbnRhaW5lciByZWZlcmVuY2UgaXMgbnVsbCFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjyBVcGRhdGluZyBjaGFydCBkaW1lbnNpb25zIGFmdGVyIHJlc2l6ZS4uLlwiKTtcclxuICAgICAgICBkcmF3U29sdmVUaW1lVHJlbmQoc29sdmVzKTtcclxuICAgIH0sIFt4RG9tYWluLCBjb250YWluZXJSZWZdKTsgIC8vIPCflKUgRW5zdXJlIGNoYXJ0IHVwZGF0ZXMgd2hlbiB4RG9tYWluIG9yIGNvbnRhaW5lciBzaXplIGNoYW5nZXNcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICghc29sdmVzIHx8ICFBcnJheS5pc0FycmF5KHNvbHZlcykgfHwgc29sdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gUnVubmluZyBjbHVzdGVyIGRldGVjdGlvbi4uLlwiKTtcclxuICAgICAgICBjb25zdCBkZXRlY3RlZENsdXN0ZXJzID0gZmluZENsdXN0ZXJzKHNvbHZlcyk7XHJcbiAgICAgICAgc2V0Q2x1c3RlcnMoZGV0ZWN0ZWRDbHVzdGVycyk7XHJcblxyXG4gICAgICAgIGlmIChkZXRlY3RlZENsdXN0ZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RDbHVzdGVyID0gZGV0ZWN0ZWRDbHVzdGVyc1swXTtcclxuICAgICAgICAgICAgY29uc3QgbmV3RG9tYWluID0gW1xyXG4gICAgICAgICAgICAgICAgbmV3IERhdGUoZmlyc3RDbHVzdGVyWzBdLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShmaXJzdENsdXN0ZXIuc2xpY2UoLTEpWzBdLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIHNldFhEb21haW4obmV3RG9tYWluKTtcclxuICAgICAgICAgICAgeERvbWFpblJlZi5jdXJyZW50ID0gbmV3RG9tYWluOyAgLy8g4pyFIEVuc3VyZSByZWYgaXMgdXBkYXRlZFxyXG5cclxuICAgICAgICAgICAgLy8g4p2XIExvZyBBRlRFUiBzZXR0aW5nIHRoZSBzdGF0ZSB0byByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFgtRG9tYWluIGluaXRpYWxpemVkIHRvIGZpcnN0IGNsdXN0ZXI6XCIsIG5ld0RvbWFpbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdHRhY2ggcmVzaXplIGV2ZW50XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgfSwgW3NvbHZlc10pOyAgLy8gPC0tIFJ1bnMgb25seSBvbiBmaXJzdCBsb2FkXHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBIYW5kbGluZyByZXNpemUuLi5cIik7XHJcblxyXG4gICAgICAgIGlmICghc29sdmVzIHx8IHNvbHZlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIHNvbHZlcyBhdmFpbGFibGUsIHNraXBwaW5nIHJlc2l6ZSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkZXRlY3RlZENsdXN0ZXJzID0gY2x1c3RlcnM7XHJcblxyXG4gICAgICAgIGlmIChjbHVzdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIGNsdXN0ZXJzIGF2YWlsYWJsZSBvbiByZXNpemUhIFJlZmluZGluZyBjbHVzdGVycy4uLlwiKTtcclxuICAgICAgICAgICAgZGV0ZWN0ZWRDbHVzdGVycyA9IGZpbmRDbHVzdGVycyhzb2x2ZXMpO1xyXG4gICAgICAgICAgICBzZXRDbHVzdGVycyhkZXRlY3RlZENsdXN0ZXJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZXRlY3RlZENsdXN0ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gU3RpbGwgbm8gY2x1c3RlcnMgZm91bmQgYWZ0ZXIgcmVzaXplIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJldkNsdXN0ZXJJbmRleCA9IGN1cnJlbnRDbHVzdGVySW5kZXg7XHJcbiAgICAgICAgY29uc3QgcHJldlhEb21haW4gPSB4RG9tYWluUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OMIFByZXNlcnZpbmcgQ2x1c3RlciBJbmRleDogJHtwcmV2Q2x1c3RlckluZGV4fWApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBQcmVzZXJ2aW5nIFgtRG9tYWluIGJlZm9yZSByZXNpemU6XCIsIHByZXZYRG9tYWluKTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIHJlLXJlbmRlcnMgd2l0aCBjb3JyZWN0IHN0YXRlc1xyXG4gICAgICAgIHNldEN1cnJlbnRDbHVzdGVySW5kZXgocHJldkNsdXN0ZXJJbmRleCk7XHJcbiAgICAgICAgc2V0WERvbWFpbihwcmV2WERvbWFpbik7XHJcbiAgICAgICAgeERvbWFpblJlZi5jdXJyZW50ID0gcHJldlhEb21haW47XHJcblxyXG4gICAgICAgIC8vIOKchSBGb3JjZSBzdGF0ZSB1cGRhdGVzIHRvIHJlLWVuYWJsZSBidXR0b25zXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldENsdXN0ZXJzKFsuLi5kZXRlY3RlZENsdXN0ZXJzXSk7XHJcbiAgICAgICAgICAgIHNldFhEb21haW4oWy4uLnByZXZYRG9tYWluXSk7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRDbHVzdGVySW5kZXgocHJldkNsdXN0ZXJJbmRleCk7XHJcbiAgICAgICAgfSwgMCk7XHJcblxyXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgY2hhcnQgYWZ0ZXIgcmVzaXplXHJcbiAgICAgICAgZHJhd1NvbHZlVGltZVRyZW5kKHNvbHZlcyk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFJlc2l6ZSBoYW5kbGVkLCByZXN0b3Jpbmcgc3RhdGVzLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaW5kQ2x1c3RlcnMoZGF0YSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBSdW5uaW5nIGZpbmRDbHVzdGVycy4uLlwiKTtcclxuXHJcbiAgICAgICAgbGV0IGRldGVjdGVkQ2x1c3RlcnMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudENsdXN0ZXIgPSBbZGF0YVswXV07XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobmV3IERhdGUoZGF0YVtpXS50aW1lc3RhbXApIC0gbmV3IERhdGUoZGF0YVtpIC0gMV0udGltZXN0YW1wKSA+IDE1ICogNjAgKiAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENsdXN0ZXIubGVuZ3RoID4gMSkgeyAgLy8g4pyFIElnbm9yZSBjbHVzdGVycyB3aXRoIGEgc2luZ2xlIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlWFZhbHVlcyA9IG5ldyBTZXQoY3VycmVudENsdXN0ZXIubWFwKGQgPT4gZC50aW1lc3RhbXApKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodW5pcXVlWFZhbHVlcy5zaXplID4gMSkgeyAgLy8g4pyFIElnbm9yZSBjbHVzdGVycyB3aXRoIHRoZSBzYW1lIFgtQXhpcyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZENsdXN0ZXJzLnB1c2goY3VycmVudENsdXN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBJZ25vcmluZyBjbHVzdGVyIHdpdGggc2FtZSBYLUF4aXMgdmFsdWVzOlwiLCBjdXJyZW50Q2x1c3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudENsdXN0ZXIgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50Q2x1c3Rlci5wdXNoKGRhdGFbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgbGFzdCBjbHVzdGVyIGJlZm9yZSBhZGRpbmcgaXRcclxuICAgICAgICBpZiAoY3VycmVudENsdXN0ZXIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVYVmFsdWVzID0gbmV3IFNldChjdXJyZW50Q2x1c3Rlci5tYXAoZCA9PiBkLnRpbWVzdGFtcCkpO1xyXG4gICAgICAgICAgICBpZiAodW5pcXVlWFZhbHVlcy5zaXplID4gMSkge1xyXG4gICAgICAgICAgICAgICAgZGV0ZWN0ZWRDbHVzdGVycy5wdXNoKGN1cnJlbnRDbHVzdGVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBJZ25vcmluZyBjbHVzdGVyIHdpdGggc2FtZSBYLUF4aXMgdmFsdWVzOlwiLCBjdXJyZW50Q2x1c3Rlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TiiBDbHVzdGVycyBpZGVudGlmaWVkIChleGNsdWRpbmcgc2luZ2xlL3NhbWUgeC1heGlzIGNsdXN0ZXJzKTpcIiwgZGV0ZWN0ZWRDbHVzdGVycy5sZW5ndGgsIGRldGVjdGVkQ2x1c3RlcnMpO1xyXG4gICAgICAgIHJldHVybiBkZXRlY3RlZENsdXN0ZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVSb2xsaW5nQXZlcmFnZShkYXRhLCB3aW5kb3dTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChfLCBpLCBhcnIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGkgPCB3aW5kb3dTaXplIC0gMSkgcmV0dXJuIG51bGw7ICAvLyDinIUgUHJlc2VydmUgbnVsbHMgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICBjb25zdCBzdWJzZXQgPSBhcnIuc2xpY2UoaSAtICh3aW5kb3dTaXplIC0gMSksIGkgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnNldC5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gc3Vic2V0Lmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U29sdmVUaW1lVHJlbmQoZGF0YSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBDdXJyZW50IFgtRG9tYWluIGluIGRyYXdTb2x2ZVRpbWVUcmVuZDpcIiwgeERvbWFpblJlZi5jdXJyZW50KTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KXtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIENvbnRhaW5lciByZWZlcmVuY2UgaXMgbnVsbCwgY2Fubm90IGRyYXchXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0IHx8IDUwMDtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OPIENoYXJ0IGRpbWVuc2lvbnM6XCIsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXIuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKVxyXG4gICAgICAgICAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBhbGwgZGF0YSBjb250YWlucyB0aW1lc3RhbXBzXHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IGRhdGFcclxuICAgICAgICAgICAgLm1hcChzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNvbHZlLnRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBTa2lwcGluZyBlbnRyeSB3aXRoIG1pc3NpbmcgdGltZXN0YW1wOlwiLCBzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoc29sdmUudGltZXN0YW1wKSxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBzb2x2ZS50aW1lIC8gMTAwMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihkID0+IGQgIT09IG51bGwpOyAgLy8gUmVtb3ZlIGludmFsaWQgZW50cmllc1xyXG5cclxuICAgICAgICBjb25zdCB0aW1lc3RhbXBzID0gcHJvY2Vzc2VkRGF0YS5tYXAoZCA9PiBkLnRpbWVzdGFtcCk7XHJcbiAgICAgICAgY29uc3QgdGltZXMgPSBwcm9jZXNzZWREYXRhLm1hcChkID0+IGQudGltZSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2VkIHRpbWVzdGFtcHM6XCIsIHRpbWVzdGFtcHMpO1xyXG5cclxuICAgICAgICAvLyDwn5SlIEZpbmQgdGhlIGZpcnN0IFwiY2x1c3RlclwiIChhIHNob3J0IGludGVydmFsIG9mIGRhdGEpXHJcbiAgICAgICAgbGV0IGNsdXN0ZXJTdGFydEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgY2x1c3RlckVuZEluZGV4ID0gdGltZXN0YW1wcy5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbaV0gLSB0aW1lc3RhbXBzWzBdID4gMTUgKiA2MCAqIDEwMDApIHsgLy8gMTUtbWludXRlIHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgY2x1c3RlckVuZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBjbHVzdGVyIHRpbWUgcmFuZ2VcclxuICAgICAgICBjb25zdCBpbml0aWFsWERvbWFpbiA9IFtcclxuICAgICAgICAgICAgdGltZXN0YW1wc1tjbHVzdGVyU3RhcnRJbmRleF0sXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcHNbY2x1c3RlckVuZEluZGV4XVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDij7MgSW5pdGlhbCBGb2N1cyBYIERvbWFpbjogJHtpbml0aWFsWERvbWFpblswXX0gdG8gJHtpbml0aWFsWERvbWFpblsxXX1gKTtcclxuXHJcbiAgICAgICAgY29uc3QgYW81ID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCA1KTtcclxuICAgICAgICBjb25zdCBhbzEyID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCAxMik7XHJcblxyXG4gICAgICAgIGNvbnN0IGFvNURhdGEgPSB0aW1lc3RhbXBzLm1hcCgodGltZXN0YW1wLCBpKSA9PiAoe1xyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgdmFsdWU6IGFvNVtpXSAhPT0gbnVsbCA/IGFvNVtpXSA6IG51bGxcclxuICAgICAgICB9KSkuZmlsdGVyKGQgPT4gZC52YWx1ZSAhPT0gbnVsbCk7IC8vIFJlbW92ZSBpbml0aWFsIG51bGxzXHJcblxyXG4gICAgICAgIGNvbnN0IGFvMTJEYXRhID0gdGltZXN0YW1wcy5tYXAoKHRpbWVzdGFtcCwgaSkgPT4gKHtcclxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIHZhbHVlOiBhbzEyW2ldICE9PSBudWxsID8gYW8xMltpXSA6IG51bGxcclxuICAgICAgICB9KSkuZmlsdGVyKGQgPT4gZC52YWx1ZSAhPT0gbnVsbCk7IC8vIFJlbW92ZSBpbml0aWFsIG51bGxzXHJcblxyXG4gICAgICAgIC8vIFggU2NhbGU6IFN0YXJ0IHpvb21lZCBpbnRvIHRoZSBpZGVudGlmaWVkIGNsdXN0ZXJcclxuICAgICAgICBsZXQgeFNjYWxlID0gZDMuc2NhbGVUaW1lKClcclxuICAgICAgICAgICAgLmRvbWFpbih4RG9tYWluUmVmLmN1cnJlbnQgPz8gW3RpbWVzdGFtcHNbMF0sIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXV0pICAvLyDinIUgVXNlIHJlZiBhcyBmYWxsYmFja1xyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCB3aWR0aCAtIDUwXSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TiSBBcHBseWluZyBYIFNjYWxlIGRvbWFpbiBpbiBkcmF3U29sdmVUaW1lVHJlbmQ6XCIsIHhTY2FsZS5kb21haW4oKSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJ4U2NhbGUgcmFuZ2U6XCIsIHhTY2FsZS5yYW5nZSgpKTtcclxuXHJcbiAgICAgICAgY29uc3QgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFtkMy5tYXgodGltZXMpLCBkMy5taW4odGltZXMpXSlcclxuICAgICAgICAgICAgLnJhbmdlKFs1MCwgaGVpZ2h0IC0gNTBdKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIFggYW5kIFkgYXhlc1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd4LWF4aXMnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke2hlaWdodCAtIDUwfSlgKVxyXG4gICAgICAgICAgICAuY2FsbChkMy5heGlzQm90dG9tKHhTY2FsZSkudGlja0Zvcm1hdChkMy50aW1lRm9ybWF0KCclSDolTTolUycpKSk7XHJcblxyXG4gICAgICAgIC8vIEZpbHRlciB1bmlxdWUgZGF5cyBmb3IgZGlzcGxheWluZyBkYXRlIGJlbG93XHJcbiAgICAgICAgbGV0IGxhc3REYXRlID0gbnVsbDtcclxuICAgICAgICB4QXhpcy5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMS4yZW0nKSAvLyBNb3ZlIHRpbWUgbGFiZWxzIHVwIHNsaWdodGx5XHJcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsIGksIG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVTdHIgPSBkMy50aW1lRm9ybWF0KCclYiAlZCwgJVknKShuZXcgRGF0ZShkKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVN0ciAhPT0gbGFzdERhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dC5hcHBlbmQoJ3RzcGFuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMS4yZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dChkYXRlU3RyKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RGF0ZSA9IGRhdGVTdHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB5QXhpcyA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneS1heGlzJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoNTAsIDApYClcclxuICAgICAgICAgICAgLmNhbGwoZDMuYXhpc0xlZnQoeVNjYWxlKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGdyaWRHcm91cCA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdncmlkJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdHcmlkKHhTY2FsZSwgeVNjYWxlKSB7XHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgZ3JpZCBsaW5lc1xyXG4gICAgICAgICAgICBncmlkR3JvdXAuc2VsZWN0QWxsKCcuaG9yaXpvbnRhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHlTY2FsZS50aWNrcygxMCkpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaG9yaXpvbnRhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGggLSA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGQgPT4geVNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgZCA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAnNCw0Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJ0aWNhbCBncmlkIGxpbmVzXHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJy52ZXJ0aWNhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHhTY2FsZS50aWNrcygxMCkpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndmVydGljYWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBkID0+IHhTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGQgPT4geFNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBoZWlnaHQgLSA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICc0LDQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRyYXdHcmlkKHhTY2FsZSwgeVNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgem9vbSA9IGQzLnpvb20oKVxyXG4gICAgICAgICAgICAvLyAuc2NhbGVFeHRlbnQoWzAuNSwgNV0pXHJcbiAgICAgICAgICAgIC8vIC50cmFuc2xhdGVFeHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcclxuICAgICAgICAgICAgLm9uKCd6b29tJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdYU2NhbGUgPSB0cmFuc2Zvcm0ucmVzY2FsZVgoeFNjYWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1lTY2FsZSA9IHRyYW5zZm9ybS5yZXNjYWxlWSh5U2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRlZCB4U2NhbGUgZG9tYWluOlwiLCBuZXdYU2NhbGUuZG9tYWluKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgcGxvdHNcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVBsb3QobmV3WFNjYWxlLCBuZXdZU2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBheGVzXHJcbiAgICAgICAgICAgICAgICB4QXhpcy5jYWxsKGQzLmF4aXNCb3R0b20obmV3WFNjYWxlKS50aWNrRm9ybWF0KGQzLnRpbWVGb3JtYXQoJyVIOiVNOiVTJykpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFpvb21EYXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHhBeGlzLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzEuMmVtJylcclxuICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkLCBpLCBub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IGQzLnRpbWVGb3JtYXQoJyViICVkLCAlWScpKG5ldyBEYXRlKGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVTdHIgIT09IGxhc3Rab29tRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQuYXBwZW5kKCd0c3BhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcxLjJlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZGF0ZVN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Wm9vbURhdGUgPSBkYXRlU3RyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB5QXhpcy5jYWxsKGQzLmF4aXNMZWZ0KG5ld1lTY2FsZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBncmlkIHdpdGggbmV3IHNjYWxlc1xyXG4gICAgICAgICAgICAgICAgZHJhd0dyaWQobmV3WFNjYWxlLCBuZXdZU2NhbGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc3ZnLmNhbGwoem9vbSk7XHJcblxyXG4gICAgICAgIC8vIOKchSBBZGQgTGVnZW5kcyAoQmVsb3cgQXV0b3NjYWxlIEJ1dHRvbilcclxuICAgICAgICBjb25zdCBsZWdlbmQgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt3aWR0aCAtIDEyMH0sIDgwKWApOyAvLyDirIcgTW92ZXMgbGVnZW5kIGxvd2VyIHVuZGVyIGJ1dHRvblxyXG5cclxuICAgICAgICBjb25zdCBsZWdlbmRJdGVtcyA9IFtcclxuICAgICAgICAgICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ1NpbmdsZScgfSxcclxuICAgICAgICAgICAgeyBjb2xvcjogJ2dyZWVuJywgbGFiZWw6ICdBTzUnIH0sXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdyZWQnLCBsYWJlbDogJ0FPMTInIH1cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBsZWdlbmRJdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBpICogMjApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgaXRlbS5jb2xvcik7XHJcblxyXG4gICAgICAgICAgICBsZWdlbmQuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMjApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGkgKiAyMCArIDEyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgICAgICAgICAgICAgIC50ZXh0KGl0ZW0ubGFiZWwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuLy8gRW5zdXJlIGV2ZW50IGlzIHBhc3NlZCB0byBhdXRvc2NhbGVcclxuICAgICAgICBzdmcub24oJ2RibGNsaWNrJywgKGV2ZW50KSA9PiBhdXRvc2NhbGUoZXZlbnQpKTtcclxuXHJcbi8vIEFsc28gZXhwbGljaXRseSBkaXNhYmxlIHpvb20gb24gZG91YmxlLWNsaWNrIHRvIHByZXZlbnQgem9vbWluZyBpblxyXG4gICAgICAgIHN2Zy5jYWxsKHpvb20pLm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUGxvdChuZXdYU2NhbGUsIG5ld1lTY2FsZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflIQgVXBkYXRpbmcgUGxvdCB3aXRoIE5ldyBTY2FsZXM6XCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfn6IgTmV3IFggU2NhbGUgRG9tYWluOlwiLCBuZXdYU2NhbGUuZG9tYWluKCkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfn6IgTmV3IFkgU2NhbGUgRG9tYWluOlwiLCBuZXdZU2NhbGUuZG9tYWluKCkpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSB0aGF0IHRoZSBBTzUgYW5kIEFPMTIgcG9pbnRzIGFyZSBjb3JyZWN0bHkgYm91bmRcclxuICAgICAgICAgICAgY29uc3QgYW81U2VsZWN0aW9uID0gc3ZnLnNlbGVjdEFsbCgnLnBvaW50LWFvNScpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShhbzVEYXRhLCBkID0+IGQudGltZXN0YW1wKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncG9pbnQtYW81JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4geFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpICAvLyBBbGlnbiB3aXRoIHRpbWVzdGFtcHNcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4geVNjYWxlKGQudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnZ3JlZW4nKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChldmVudCwgZCkgPT4gc2hvd1Rvb2x0aXAoZXZlbnQsIGQudGltZXN0YW1wKSlcclxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsICgpID0+IHRvb2x0aXAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFvMTJTZWxlY3Rpb24gPSBzdmcuc2VsZWN0QWxsKCcucG9pbnQtYW8xMicpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShhbzEyRGF0YSwgZCA9PiBkLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgICAgIC5qb2luKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50LWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiB4U2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSkgIC8vIEFsaWduIHdpdGggdGltZXN0YW1wc1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdyZWQnKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChldmVudCwgZCkgPT4gc2hvd1Rvb2x0aXAoZXZlbnQsIGQudGltZXN0YW1wKSlcclxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsICgpID0+IHRvb2x0aXAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJQgVG90YWwgQU81IFBvaW50cyBTZWxlY3RlZDogJHthbzVTZWxlY3Rpb24uc2l6ZSgpfSAoRXhwZWN0ZWQ6ICR7YW81Lmxlbmd0aH0pYCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJQgVG90YWwgQU8xMiBQb2ludHMgU2VsZWN0ZWQ6ICR7YW8xMlNlbGVjdGlvbi5zaXplKCl9IChFeHBlY3RlZDogJHthbzEyLmxlbmd0aH0pYCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYW81U2VsZWN0aW9uLnNpemUoKSA9PT0gMCkgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIEFPNSBwb2ludHMgZm91bmQgaW4gdXBkYXRlUGxvdCFcIik7XHJcbiAgICAgICAgICAgIGlmIChhbzEyU2VsZWN0aW9uLnNpemUoKSA9PT0gMCkgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIEFPMTIgcG9pbnRzIGZvdW5kIGluIHVwZGF0ZVBsb3QhXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBhbGwgQU81IHBvaW50cyBjb3JyZWN0bHlcclxuICAgICAgICAgICAgYW81U2VsZWN0aW9uLmF0dHIoJ2N4JywgZCA9PiBuZXdYU2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4gbmV3WVNjYWxlKGQudmFsdWUpKTsgLy8g4pyFIFVzZSBkLnZhbHVlIGZvciBBTzVcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgYWxsIEFPMTIgcG9pbnRzIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBhbzEyU2VsZWN0aW9uLmF0dHIoJ2N4JywgZCA9PiBuZXdYU2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4gbmV3WVNjYWxlKGQudmFsdWUpKTsgLy8g4pyFIFVzZSBkLnZhbHVlIGZvciBBTzEyXHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRGVidWdnaW5nOiBFbnN1cmUgbGFzdCBBTzUgJiBBTzEyIHBvaW50cyB1cGRhdGUgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGFvNVNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhbzUubGVuZ3RoIC0gNCkgeyAvLyBVc2UgYGFvNS5sZW5ndGhgIHRvIGNvcnJlY3RseSBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfn6IgQU81IFBvaW50ICR7aX06IHg9JHtuZXdYU2NhbGUoZC54KX0sIHk9JHtuZXdZU2NhbGUoZC55KX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBhbzEyU2VsZWN0aW9uLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGFvMTIubGVuZ3RoIC0gMTIpIHsgLy8gVXNlIGBhbzEyLmxlbmd0aGAgdG8gY29ycmVjdGx5IGl0ZXJhdGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtCBBTzEyIFBvaW50ICR7aX06IHg9JHtuZXdYU2NhbGUoZC54KX0sIHk9JHtuZXdZU2NhbGUoZC55KX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIHNpbmdsZSBzb2x2ZSBwb2ludHNcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLnBvaW50LXNpbmdsZScpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShwcm9jZXNzZWREYXRhLCBkID0+IGQudGltZXN0YW1wKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncG9pbnQtc2luZ2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpIC8vIEZJWDogVXNlIG5ld1hTY2FsZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBuZXdZU2NhbGUoZC50aW1lKSkgLy8gRklYOiBVc2UgbmV3WVNjYWxlXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdibHVlJylcclxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZXZlbnQsIGQpID0+IHNob3dUb29sdGlwKGV2ZW50LCBkLnRpbWVzdGFtcCkpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoKSA9PiB0b29sdGlwLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIHNpbmdsZSBzb2x2ZSBsaW5lXHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLXNpbmdsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAueChkID0+IG5ld1hTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KGQgPT4gbmV3WVNjYWxlKGQudGltZSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSBBTzUgbGluZSBhbGlnbnMgZHluYW1pY2FsbHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtYW81JylcclxuICAgICAgICAgICAgICAgIC5kYXR1bShhbzUubWFwKCh2YWwsIGkpID0+ICh7IHRpbWVzdGFtcDogdGltZXN0YW1wc1tpXSwgdmFsdWU6IHZhbCB9KSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZChkID0+IGQudmFsdWUgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoZCA9PiBuZXdYU2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSlcclxuICAgICAgICAgICAgICAgICAgICAueShkID0+IG5ld1lTY2FsZShkLnZhbHVlKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIEFPMTIgbGluZSBhbGlnbnMgZHluYW1pY2FsbHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtYW8xMicpXHJcbiAgICAgICAgICAgICAgICAuZGF0dW0oYW8xMi5tYXAoKHZhbCwgaSkgPT4gKHsgdGltZXN0YW1wOiB0aW1lc3RhbXBzW2ldLCB2YWx1ZTogdmFsIH0pKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKGQgPT4gZC52YWx1ZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAueChkID0+IG5ld1hTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KGQgPT4gbmV3WVNjYWxlKGQudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuZGF0dW0ocHJvY2Vzc2VkRGF0YSlcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUtc2luZ2xlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibHVlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG4gICAgICAgICAgICAgICAgLngoZCA9PiB4U2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSlcclxuICAgICAgICAgICAgICAgIC55KGQgPT4geVNjYWxlKGQudGltZSkpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvNScpXHJcbiAgICAgICAgICAgIC5kYXRhKFthbzVdKSAgLy8g4pyFIFVzZSAuZGF0YShbXSkgaW5zdGVhZCBvZiAuZGF0dW0oKVxyXG4gICAgICAgICAgICAuam9pbihcInBhdGhcIilcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUtYW81JylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdncmVlbicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMilcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgIC5kZWZpbmVkKChfLCBpKSA9PiBpID49IDQgJiYgYW81W2ldICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgLngoKF8sIGkpID0+IHhTY2FsZShuZXcgRGF0ZSh0aW1lc3RhbXBzW2ldKSkpICAvLyDinIUgVXNlIHRpbWVzdGFtcHNcclxuICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiB5U2NhbGUoYW81W2ldKSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxpbmUtYW8xMicpXHJcbiAgICAgICAgICAgIC5kYXRhKFthbzEyXSkgIC8vIOKchSBVc2UgLmRhdGEoW10pIGluc3RlYWQgb2YgLmRhdHVtKClcclxuICAgICAgICAgICAgLmpvaW4oXCJwYXRoXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lLWFvMTInKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ3JlZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMilcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgIC5kZWZpbmVkKChfLCBpKSA9PiBpID49IDExICYmIGFvMTJbaV0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAueCgoXywgaSkgPT4geFNjYWxlKG5ldyBEYXRlKHRpbWVzdGFtcHNbaV0pKSkgIC8vIOKchSBVc2UgdGltZXN0YW1wc1xyXG4gICAgICAgICAgICAgICAgLnkoKF8sIGkpID0+IHlTY2FsZShhbzEyW2ldKSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCkuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYWJzb2x1dGUgYmctd2hpdGUgcC0yIGJvcmRlciByb3VuZGVkIHNoYWRvdyB0ZXh0LXNtJylcclxuICAgICAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpXHJcbiAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZXZlbnQsIHRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICBpZiAoIXRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIHNob3dUb29sdGlwIGNhbGxlZCB3aXRoIGludmFsaWQgdGltZXN0YW1wOlwiLCB0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBkYXRhIHBvaW50cyB3aXRoIHRoZSBzYW1lIHRpbWVzdGFtcFxyXG4gICAgICAgICAgICBjb25zdCBzaW5nbGVEYXRhID0gcHJvY2Vzc2VkRGF0YS5maW5kKGQgPT4gZC50aW1lc3RhbXAuZ2V0VGltZSgpID09PSB0aW1lc3RhbXAuZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgY29uc3QgYW81RGF0YVBvaW50ID0gYW81RGF0YS5maW5kKGQgPT4gZC50aW1lc3RhbXAuZ2V0VGltZSgpID09PSB0aW1lc3RhbXAuZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgY29uc3QgYW8xMkRhdGFQb2ludCA9IGFvMTJEYXRhLmZpbmQoZCA9PiBkLnRpbWVzdGFtcC5nZXRUaW1lKCkgPT09IHRpbWVzdGFtcC5nZXRUaW1lKCkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc2luZ2xlVGltZSA9IHNpbmdsZURhdGEgPyBzaW5nbGVEYXRhLnRpbWUudG9GaXhlZCgyKSA6IFwiLVwiO1xyXG4gICAgICAgICAgICBjb25zdCBhbzVUaW1lID0gYW81RGF0YVBvaW50ID8gYW81RGF0YVBvaW50LnZhbHVlLnRvRml4ZWQoMikgOiBcIi1cIjtcclxuICAgICAgICAgICAgY29uc3QgYW8xMlRpbWUgPSBhbzEyRGF0YVBvaW50ID8gYW8xMkRhdGFQb2ludC52YWx1ZS50b0ZpeGVkKDIpIDogXCItXCI7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+foiBTaG93aW5nIHRvb2x0aXAgZm9yIHRpbWVzdGFtcCAke3RpbWVzdGFtcH06IFNpbmdsZT0ke3NpbmdsZVRpbWV9LCBBTzU9JHthbzVUaW1lfSwgQU8xMj0ke2FvMTJUaW1lfWApO1xyXG5cclxuICAgICAgICAgICAgdG9vbHRpcC5odG1sKGBcclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5TaW5nbGU6PC9zdHJvbmc+ICR7c2luZ2xlVGltZX1zPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+QU81Ojwvc3Ryb25nPiAke2FvNVRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPkFPMTI6PC9zdHJvbmc+ICR7YW8xMlRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICBgKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdmaXhlZCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nJywgJzZweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JvcmRlcicsICcxcHggc29saWQgI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JvcmRlci1yYWRpdXMnLCAnNXB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm94LXNoYWRvdycsICcycHggMnB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjEpJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnei1pbmRleCcsICcxMDAwJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAtNTAlKScpO1xyXG5cclxuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZSgnbGVmdCcsIGAke2V2ZW50LnBhZ2VYICsgMTJ9cHhgKS5zdHlsZSgndG9wJywgYCR7ZXZlbnQucGFnZVl9cHhgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwKCkge1xyXG4gICAgICAgICAgICB0b29sdGlwLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVBsb3QoeFNjYWxlLCB5U2NhbGUpOyAgLy8g4pyFIEZvcmNlIHJlbmRlciBhZnRlciBpbml0aWFsaXphdGlvblxyXG4gICAgICAgIH0sIDEwMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZFBvaW50cyhkYXRhLCBjb2xvciwgY2xhc3NOYW1lLCB2YWx1ZUFjY2Vzc29yLCBtaW5JbmRleCwgbGFiZWwpIHtcclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSB0aGF0IHdlIGNvcnJlY3RseSBpdGVyYXRlIG92ZXIgdGhlIGZ1bGwgZGF0YXNldFxyXG4gICAgICAgICAgICBjb25zdCB2YWxpZFBvaW50cyA9IGRhdGFcclxuICAgICAgICAgICAgICAgIC5tYXAoKHZhbCwgaSkgPT4gKHsgeDogaSwgeTogdmFsdWVBY2Nlc3NvcihpKSB9KSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkLnkgIT09IG51bGwgJiYgZC54ID49IG1pbkluZGV4KTsgLy8g4pyFIFJlbW92ZWQgeCA8IHRpbWVzLmxlbmd0aCBjb25zdHJhaW50XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+foiBBZGRpbmcgUG9pbnRzIGZvciAke2xhYmVsfSB8IENsYXNzOiAke2NsYXNzTmFtZX0gfCBNaW5JbmRleDogJHttaW5JbmRleH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBWYWxpZCBQb2ludHMgQ291bnQ6ICR7dmFsaWRQb2ludHMubGVuZ3RofWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjSBGaXJzdCA1IFBvaW50czpgLCB2YWxpZFBvaW50cy5zbGljZSgwLCA1KSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5ONIExhc3QgNSBQb2ludHM6YCwgdmFsaWRQb2ludHMuc2xpY2UoLTUpKTtcclxuXHJcbiAgICAgICAgICAgIHZhbGlkUG9pbnRzLmZvckVhY2goKHBvaW50LCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICBg8J+UtSAke2xhYmVsfSBQb2ludCAke2kgKyBtaW5JbmRleH06IFJhd1g9JHtwb2ludC54fSwgU2NhbGVkWD0ke3hTY2FsZShwb2ludC54KX0sIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBSYXdZPSR7cG9pbnQueS50b0ZpeGVkKDMpfSwgU2NhbGVkWT0ke3lTY2FsZShwb2ludC55KS50b0ZpeGVkKDIpfWBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIGRhdGEgYmluZGluZyBpcyBkb25lIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKGAuJHtjbGFzc05hbWV9YClcclxuICAgICAgICAgICAgICAgIC5kYXRhKHZhbGlkUG9pbnRzLCBkID0+IGQueCkgLy8gRW5zdXJlIHVuaXF1ZSBrZXkgYmluZGluZ1xyXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJjaXJjbGVcIikgLy8gRW5zdXJlIHByb3BlciBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgcG9pbnQgJHtjbGFzc05hbWV9YClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4geFNjYWxlKGQueCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IHlTY2FsZShkLnkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb2xvcilcclxuICAgICAgICB9XHJcblxyXG4vLyDinIUgRW5zdXJlIEFPNSAmIEFPMTIgcG9pbnRzIGFyZSBmdWxseSBhZGRlZCBiZWZvcmUgdXBkYXRpbmdcclxuICAgICAgICBhZGRQb2ludHModGltZXMsICdibHVlJywgJ3BvaW50LXNpbmdsZScsIChpKSA9PiB0aW1lc1tpXSwgMCwgXCJTaW5nbGVcIik7XHJcbiAgICAgICAgYWRkUG9pbnRzKGFvNSwgJ2dyZWVuJywgJ3BvaW50LWFvNScsIChpKSA9PiBhbzVbaV0sIDQsIFwiQU81XCIpO1xyXG4gICAgICAgIGFkZFBvaW50cyhhbzEyLCAncmVkJywgJ3BvaW50LWFvMTInLCAoaSkgPT4gYW8xMltpXSwgMTEsIFwiQU8xMlwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbHMgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Fic29sdXRlIHRvcC0yIHJpZ2h0LTIgYmctd2hpdGUgcC0yIHJvdW5kZWQgc2hhZG93Jyk7XHJcblxyXG4gICAgICAgIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcclxuICAgICAgICAgICAgLnRleHQoJ1ByZXZpb3VzIENsdXN0ZXInKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmdpbi1yaWdodCcsICc1cHgnKVxyXG4gICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCBjbHVzdGVycy5sZW5ndGggPT09IDAgfHwgY3VycmVudENsdXN0ZXJJbmRleCA9PT0gMCA/ICdkaXNhYmxlZCcgOiBudWxsKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgcHJldkNsdXN0ZXIpO1xyXG5cclxuICAgICAgICBjb250cm9scy5hcHBlbmQoJ2J1dHRvbicpXHJcbiAgICAgICAgICAgIC50ZXh0KCdOZXh0IENsdXN0ZXInKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmdpbi1yaWdodCcsICc1cHgnKVxyXG4gICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCBjbHVzdGVycy5sZW5ndGggPT09IDAgfHwgY3VycmVudENsdXN0ZXJJbmRleCA+PSBjbHVzdGVycy5sZW5ndGggLSAxID8gJ2Rpc2FibGVkJyA6IG51bGwpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBuZXh0Q2x1c3Rlcik7XHJcblxyXG4gICAgICAgIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcclxuICAgICAgICAgICAgLnRleHQoJ0F1dG9zY2FsZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLXJpZ2h0JywgJzVweCcpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBhdXRvc2NhbGUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhdXRvc2NhbGUoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBBdXRvc2NhbGUgdHJpZ2dlcmVkLi4uXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjbHVzdGVycyB8fCBjbHVzdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBjbHVzdGVycyBhdmFpbGFibGUgZm9yIGF1dG9zY2FsZSFcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjCBBdXRvc2NhbGluZyB0byBmaXJzdCBjbHVzdGVyLi4uXCIpO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KDApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZmlyc3RDbHVzdGVyID0gY2x1c3RlcnNbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZpcnN0Q2x1c3RlciB8fCBmaXJzdENsdXN0ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gRmlyc3QgY2x1c3RlciBpcyBlbXB0eSwgY2Fubm90IGF1dG9zY2FsZSFcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0RvbWFpbiA9IFtcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGZpcnN0Q2x1c3RlclswXS50aW1lc3RhbXApLFxyXG4gICAgICAgICAgICAgICAgbmV3IERhdGUoZmlyc3RDbHVzdGVyLnNsaWNlKC0xKVswXS50aW1lc3RhbXApXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBTZXR0aW5nIGF1dG9zY2FsZSBYLURvbWFpbiB0bzpcIiwgbmV3RG9tYWluKTtcclxuICAgICAgICAgICAgc2V0WERvbWFpbihuZXdEb21haW4pO1xyXG4gICAgICAgICAgICB4RG9tYWluUmVmLmN1cnJlbnQgPSBuZXdEb21haW47XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRm9yY2UgUmVhY3QgdG8gdXBkYXRlIFVJIHN0YXRlXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0Q2x1c3RlcnMoWy4uLmNsdXN0ZXJzXSk7IC8vIEZvcmNlIHJlLWV2YWx1YXRpb24gb2YgY2x1c3RlcnMgc3RhdGVcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBuZXh0Q2x1c3RlcigpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLinqHvuI8gTmV4dCBjbHVzdGVyIGNsaWNrZWQuLi5cIik7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2x1c3RlckluZGV4IDwgY2x1c3RlcnMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gY3VycmVudENsdXN0ZXJJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4wgTW92aW5nIHRvIG5leHQgY2x1c3RlcjpcIiwgbmV4dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDbHVzdGVySW5kZXgobmV4dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RvbWFpbiA9IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShjbHVzdGVyc1tuZXh0SW5kZXhdWzBdLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoY2x1c3RlcnNbbmV4dEluZGV4XS5zbGljZSgtMSlbMF0udGltZXN0YW1wKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRYRG9tYWluKG5ld0RvbWFpbik7XHJcbiAgICAgICAgICAgICAgICB4RG9tYWluUmVmLmN1cnJlbnQgPSBuZXdEb21haW47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gbmV4dCBjbHVzdGVyIGF2YWlsYWJsZSFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHByZXZDbHVzdGVyKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKshe+4jyBQcmV2aW91cyBjbHVzdGVyIGNsaWNrZWQuLi5cIik7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2x1c3RlckluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkluZGV4ID0gY3VycmVudENsdXN0ZXJJbmRleCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4wgTW92aW5nIHRvIHByZXZpb3VzIGNsdXN0ZXI6XCIsIHByZXZJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Q2x1c3RlckluZGV4KHByZXZJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEb21haW4gPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoY2x1c3RlcnNbcHJldkluZGV4XVswXS50aW1lc3RhbXApLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKGNsdXN0ZXJzW3ByZXZJbmRleF0uc2xpY2UoLTEpWzBdLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0WERvbWFpbihuZXdEb21haW4pO1xyXG4gICAgICAgICAgICAgICAgeERvbWFpblJlZi5jdXJyZW50ID0gbmV3RG9tYWluO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIHByZXZpb3VzIGNsdXN0ZXIgYXZhaWxhYmxlIVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm4gKFxyXG4gICAgLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC1bY2FsYygxMDB2aC0xMDBweCldIGJnLXdoaXRlIHJlbGF0aXZlXCI+XHJcbiAgICAvLyAgICAgICAgIHsvKiDwn5SYIFN3aXRjaCBCdXR0b24gKi99XHJcbiAgICAvLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTIgcmlnaHQtMiBiZy13aGl0ZSBwLTIgcm91bmRlZCBzaGFkb3dcIj5cclxuICAgIC8vICAgICAgICAgICAgIDxidXR0b25cclxuICAgIC8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctYmx1ZS01MDAgdGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLWJsdWUtNzAwIHRyYW5zaXRpb25cIlxyXG4gICAgLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3N3aXRjaFBhZ2V9XHJcbiAgICAvLyAgICAgICAgICAgICA+XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgU3dpdGNoXHJcbiAgICAvLyAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgIC8vICAgICAgICAgPC9kaXY+XHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAgICB7LyogUmVuZGVyIHRoZSBzZWxlY3RlZCBwYWdlIGR5bmFtaWNhbGx5ICovfVxyXG4gICAgLy8gICAgICAgICB7Y3VycmVudFBhZ2UgPT09ICd0aW1lJyA/IDxUcmVuZEFuYVRpbWUgc29sdmVzPXtzb2x2ZXN9IC8+IDogPFRyZW5kQW5hSW5kZXggc29sdmVzPXtzb2x2ZXN9IC8+fVxyXG4gICAgLy8gICAgIDwvZGl2PlxyXG4gICAgLy8gKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInctc2NyZWVuIGgtW2NhbGMoMTAwdmgtMTAwcHgpXSBiZy13aGl0ZSByZWxhdGl2ZVwiXHJcbiAgICAgICAgPjwvZGl2PlxyXG4gICAgKTtcclxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImQzIiwiU29sdmVUaW1lVHJlbmQiLCJzb2x2ZXMiLCJjb250YWluZXJSZWYiLCJjdXJyZW50Q2x1c3RlckluZGV4Iiwic2V0Q3VycmVudENsdXN0ZXJJbmRleCIsImNsdXN0ZXJzIiwic2V0Q2x1c3RlcnMiLCJ4RG9tYWluIiwic2V0WERvbWFpbiIsInhEb21haW5SZWYiLCJjdXJyZW50VmlldyIsInNldEN1cnJlbnRWaWV3Iiwic3dpdGNoVmlldyIsInByZXZWaWV3IiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsIndhcm4iLCJjb250YWluZXIiLCJjdXJyZW50IiwiZHJhd1NvbHZlVGltZVRyZW5kIiwiQXJyYXkiLCJpc0FycmF5IiwiZGV0ZWN0ZWRDbHVzdGVycyIsImZpbmRDbHVzdGVycyIsImZpcnN0Q2x1c3RlciIsIm5ld0RvbWFpbiIsIkRhdGUiLCJ0aW1lc3RhbXAiLCJzbGljZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVSZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicHJldkNsdXN0ZXJJbmRleCIsInByZXZYRG9tYWluIiwic2V0VGltZW91dCIsImRhdGEiLCJjdXJyZW50Q2x1c3RlciIsImkiLCJ1bmlxdWVYVmFsdWVzIiwiU2V0IiwibWFwIiwiZCIsInNpemUiLCJwdXNoIiwiY29tcHV0ZVJvbGxpbmdBdmVyYWdlIiwid2luZG93U2l6ZSIsIl8iLCJhcnIiLCJzdWJzZXQiLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJzZWxlY3QiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic3ZnIiwiYXBwZW5kIiwiYXR0ciIsInByb2Nlc3NlZERhdGEiLCJzb2x2ZSIsInRpbWUiLCJmaWx0ZXIiLCJ0aW1lc3RhbXBzIiwidGltZXMiLCJjbHVzdGVyU3RhcnRJbmRleCIsImNsdXN0ZXJFbmRJbmRleCIsImluaXRpYWxYRG9tYWluIiwiYW81IiwiYW8xMiIsImFvNURhdGEiLCJ2YWx1ZSIsImFvMTJEYXRhIiwieFNjYWxlIiwic2NhbGVUaW1lIiwiZG9tYWluIiwicmFuZ2UiLCJ5U2NhbGUiLCJzY2FsZUxpbmVhciIsIm1heCIsIm1pbiIsInhBeGlzIiwiY2FsbCIsImF4aXNCb3R0b20iLCJ0aWNrRm9ybWF0IiwidGltZUZvcm1hdCIsImxhc3REYXRlIiwiZWFjaCIsIm5vZGVzIiwiY3VycmVudFRleHQiLCJkYXRlU3RyIiwidGV4dCIsInlBeGlzIiwiYXhpc0xlZnQiLCJncmlkR3JvdXAiLCJkcmF3R3JpZCIsInRpY2tzIiwiZW50ZXIiLCJ6b29tIiwib24iLCJldmVudCIsInRyYW5zZm9ybSIsIm5ld1hTY2FsZSIsInJlc2NhbGVYIiwibmV3WVNjYWxlIiwicmVzY2FsZVkiLCJ1cGRhdGVQbG90IiwibGFzdFpvb21EYXRlIiwibGVnZW5kIiwibGVnZW5kSXRlbXMiLCJjb2xvciIsImxhYmVsIiwiZm9yRWFjaCIsIml0ZW0iLCJhdXRvc2NhbGUiLCJhbzVTZWxlY3Rpb24iLCJqb2luIiwic2hvd1Rvb2x0aXAiLCJ0b29sdGlwIiwic3R5bGUiLCJhbzEyU2VsZWN0aW9uIiwieCIsInkiLCJsaW5lIiwiY3VydmUiLCJjdXJ2ZU1vbm90b25lWCIsImRhdHVtIiwiZGVmaW5lZCIsInNpbmdsZURhdGEiLCJmaW5kIiwiZ2V0VGltZSIsImFvNURhdGFQb2ludCIsImFvMTJEYXRhUG9pbnQiLCJzaW5nbGVUaW1lIiwidG9GaXhlZCIsImFvNVRpbWUiLCJhbzEyVGltZSIsImh0bWwiLCJwYWdlWCIsInBhZ2VZIiwiaGlkZVRvb2x0aXAiLCJhZGRQb2ludHMiLCJjbGFzc05hbWUiLCJ2YWx1ZUFjY2Vzc29yIiwibWluSW5kZXgiLCJ2YWxpZFBvaW50cyIsInBvaW50IiwiY29udHJvbHMiLCJwcmV2Q2x1c3RlciIsIm5leHRDbHVzdGVyIiwibmV4dEluZGV4IiwicHJldkluZGV4IiwiZGl2IiwicmVmIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\n"));

/***/ })

});