/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/dataVis/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22E%3A%5C%5CWpi%5C%5CRegularly%5C%5CCourses%5C%5CSr%5C%5C2024_C_Term%5C%5CCS4241%5C%5CHW%5C%5Cfinal-project-kermit-the-frog%5C%5Csrc%5C%5Capp%5C%5CdataVis%5C%5Cpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22E%3A%5C%5CWpi%5C%5CRegularly%5C%5CCourses%5C%5CSr%5C%5C2024_C_Term%5C%5CCS4241%5C%5CHW%5C%5Cfinal-project-kermit-the-frog%5C%5Csrc%5C%5Capp%5C%5CdataVis%5C%5Cpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/dataVis/page.js */ \"(app-pages-browser)/./src/app/dataVis/page.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRSUzQSU1QyU1Q1dwaSU1QyU1Q1JlZ3VsYXJseSU1QyU1Q0NvdXJzZXMlNUMlNUNTciU1QyU1QzIwMjRfQ19UZXJtJTVDJTVDQ1M0MjQxJTVDJTVDSFclNUMlNUNmaW5hbC1wcm9qZWN0LWtlcm1pdC10aGUtZnJvZyU1QyU1Q3NyYyU1QyU1Q2FwcCU1QyU1Q2RhdGFWaXMlNUMlNUNwYWdlLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsNEtBQXdKIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJFOlxcXFxXcGlcXFxcUmVndWxhcmx5XFxcXENvdXJzZXNcXFxcU3JcXFxcMjAyNF9DX1Rlcm1cXFxcQ1M0MjQxXFxcXEhXXFxcXGZpbmFsLXByb2plY3Qta2VybWl0LXRoZS1mcm9nXFxcXHNyY1xcXFxhcHBcXFxcZGF0YVZpc1xcXFxwYWdlLmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22E%3A%5C%5CWpi%5C%5CRegularly%5C%5CCourses%5C%5CSr%5C%5C2024_C_Term%5C%5CCS4241%5C%5CHW%5C%5Cfinal-project-kermit-the-frog%5C%5Csrc%5C%5Capp%5C%5CdataVis%5C%5Cpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"5007c4ceca29\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjUwMDdjNGNlY2EyOVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/app-dir/link.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _formaturl = __webpack_require__(/*! ../../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ../use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _usemergedref = __webpack_require__(/*! ../use-merged-ref */ \"(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\nconst _utils = __webpack_require__(/*! ../../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _warnonce = __webpack_require__(/*! ../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction prefetch(router, href, options) {\n    if (typeof window === 'undefined') {\n        return;\n    }\n    const doPrefetch = async ()=>{\n        // note that `appRouter.prefetch()` is currently sync,\n        // so we have to wrap this call in an async function to be able to catch() errors below.\n        return router.prefetch(href, options);\n    };\n    // Prefetch the page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n    if (isAnchorNodeName && isModifiedEvent(e)) {\n        // ignore click for browserâ€™s default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if ('beforePopState' in router) {\n            router[replace ? 'replace' : 'push'](href, as, {\n                shallow,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? 'replace' : 'push'](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    _react.default.startTransition(navigate);\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation between routes.\n *\n * It is the primary way to navigate between routes in Next.js.\n *\n * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + (typeof window !== 'undefined' ? \"\\nOpen your browser's console to view the Component stack trace.\" : ''));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch' || key === 'legacyBehavior') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n    }\n    if (true) {\n        if (props.locale) {\n            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');\n        }\n        if (!asProp) {\n            let href;\n            if (typeof hrefProp === 'string') {\n                href = hrefProp;\n            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo({\n        \"Link.LinkComponent.useMemo\": ()=>{\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n    }[\"Link.LinkComponent.useMemo\"], [\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + (typeof window !== 'undefined' ? \" \\nOpen your browser's console to view the Component stack trace.\" : ''));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === 'a') {\n                throw new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor');\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: '200px'\n    });\n    const setIntersectionWithResetRef = _react.default.useCallback({\n        \"Link.LinkComponent.useCallback[setIntersectionWithResetRef]\": (el)=>{\n            // Before the link getting observed, check if visible state need to be reset\n            if (previousAs.current !== as || previousHref.current !== href) {\n                resetVisible();\n                previousAs.current = as;\n                previousHref.current = href;\n            }\n            setIntersectionRef(el);\n        }\n    }[\"Link.LinkComponent.useCallback[setIntersectionWithResetRef]\"], [\n        as,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    const setRef = (0, _usemergedref.useMergedRef)(setIntersectionWithResetRef, childRef);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect({\n        \"Link.LinkComponent.useEffect\": ()=>{\n            // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n            if (true) {\n                return;\n            }\n            if (!router) {\n                return;\n            }\n            // If we don't need to prefetch the URL, don't do prefetch.\n            if (!isVisible || !prefetchEnabled) {\n                return;\n            }\n            // Prefetch the URL.\n            prefetch(router, href, {\n                kind: appPrefetchKind\n            });\n        }\n    }[\"Link.LinkComponent.useEffect\"], [\n        as,\n        href,\n        isVisible,\n        prefetchEnabled,\n        router,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled || \"development\" === 'development') {\n                return;\n            }\n            prefetch(router, href, {\n                kind: appPrefetchKind\n            });\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled) {\n                return;\n            }\n            prefetch(router, href, {\n                kind: appPrefetchKind\n            });\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the basePath.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        childProps.href = (0, _addbasepath.addBasePath)(as);\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"cOEYCKQNQkvb3D7rzCm6zrDrstY=\")), \"cOEYCKQNQkvb3D7rzCm6zrDrstY=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1kaXIvbGluay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBMmxCQTs7O2VBQUE7Ozs7OzRFQXZsQmtCO3VDQUVROzJEQUNPOzZDQUdEO2dEQUNIOzBDQUNBO21DQUNDO3lDQUNGO3NDQUNIO0FBbUd6QixTQUFTQSxTQUNQQyxNQUF5QixFQUN6QkMsSUFBWSxFQUNaQyxPQUF3QjtJQUV4QixJQUFJLE9BQU9DLFdBQVcsYUFBYTtRQUNqQztJQUNGO0lBRUEsTUFBTUMsYUFBYTtRQUNqQixzREFBc0Q7UUFDdEQsd0ZBQXdGO1FBQ3hGLE9BQU9KLE9BQU9ELFFBQVEsQ0FBQ0UsTUFBTUM7SUFDL0I7SUFFQSxrREFBa0Q7SUFDbEQsMERBQTBEO0lBQzFELHNEQUFzRDtJQUN0RCx5REFBeUQ7SUFDekRFLGFBQWFDLEtBQUssQ0FBQyxDQUFDQztRQUNsQixJQUFJQyxJQUFvQixFQUFtQjtZQUN6QyxxQ0FBcUM7WUFDckMsTUFBTUQ7UUFDUjtJQUNGO0FBQ0Y7QUFFQSxTQUFTSSxnQkFBZ0JDLEtBQXVCO0lBQzlDLE1BQU1DLGNBQWNELE1BQU1FLGFBQWE7SUFDdkMsTUFBTUMsU0FBU0YsWUFBWUcsWUFBWSxDQUFDO0lBQ3hDLE9BQ0dELFVBQVVBLFdBQVcsV0FDdEJILE1BQU1LLE9BQU8sSUFDYkwsTUFBTU0sT0FBTyxJQUNiTixNQUFNTyxRQUFRLElBQ2RQLE1BQU1RLE1BQU0sSUFBSSw2QkFBNkI7SUFDNUNSLE1BQU1TLFdBQVcsSUFBSVQsTUFBTVMsV0FBVyxDQUFDQyxLQUFLLEtBQUs7QUFFdEQ7QUFFQSxTQUFTQyxZQUNQQyxDQUFtQixFQUNuQnZCLE1BQXNDLEVBQ3RDQyxJQUFZLEVBQ1p1QixFQUFVLEVBQ1ZDLE9BQWlCLEVBQ2pCQyxPQUFpQixFQUNqQkMsTUFBZ0I7SUFFaEIsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0wsRUFBRVYsYUFBYTtJQUVwQyxrREFB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RCxLQUFBQTtRQUFHLEdBQUdELFNBQVM7UUFBRyxHQUFHMkQsVUFBVTtrQkFDN0J2RTs7QUFHUDs7TUFHRixXQUFlTCIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxTclxcMjAyNF9DX1Rlcm1cXHNyY1xcY2xpZW50XFxhcHAtZGlyXFxsaW5rLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyJ1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBBcHBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlckluc3RhbmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IFByZWZldGNoT3B0aW9ucyB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgdXNlSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi4vdXNlLWludGVyc2VjdGlvbidcbmltcG9ydCB7IFByZWZldGNoS2luZCB9IGZyb20gJy4uL2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWYgfSBmcm9tICcuLi91c2UtbWVyZ2VkLXJlZidcbmltcG9ydCB7IGlzQWJzb2x1dGVVcmwgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzJ1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcblxudHlwZSBVcmwgPSBzdHJpbmcgfCBVcmxPYmplY3RcbnR5cGUgUmVxdWlyZWRLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBuZXZlciA6IEtcbn1ba2V5b2YgVF1cbnR5cGUgT3B0aW9uYWxLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBLIDogbmV2ZXJcbn1ba2V5b2YgVF1cblxudHlwZSBJbnRlcm5hbExpbmtQcm9wcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIG9yIFVSTCB0byBuYXZpZ2F0ZSB0by4gSXQgY2FuIGFsc28gYmUgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZSBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvbGluayN3aXRoLXVybC1vYmplY3RcbiAgICovXG4gIGhyZWY6IFVybFxuICAvKipcbiAgICogT3B0aW9uYWwgZGVjb3JhdG9yIGZvciB0aGUgcGF0aCB0aGF0IHdpbGwgYmUgc2hvd24gaW4gdGhlIGJyb3dzZXIgVVJMIGJhci4gQmVmb3JlIE5leHQuanMgOS41LjMgdGhpcyB3YXMgdXNlZCBmb3IgZHluYW1pYyByb3V0ZXMsIGNoZWNrIG91ciBbcHJldmlvdXMgZG9jc10oaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Jsb2IvdjkuNS4yL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xpbmsubWQjZHluYW1pYy1yb3V0ZXMpIHRvIHNlZSBob3cgaXQgd29ya2VkLiBOb3RlOiB3aGVuIHRoaXMgcGF0aCBkaWZmZXJzIGZyb20gdGhlIG9uZSBwcm92aWRlZCBpbiBgaHJlZmAgdGhlIHByZXZpb3VzIGBocmVmYC9gYXNgIGJlaGF2aW9yIGlzIHVzZWQgYXMgc2hvd24gaW4gdGhlIFtwcmV2aW91cyBkb2NzXShodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvYmxvYi92OS41LjIvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvbGluay5tZCNkeW5hbWljLXJvdXRlcykuXG4gICAqL1xuICBhcz86IFVybFxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgY3VycmVudCBgaGlzdG9yeWAgc3RhdGUgaW5zdGVhZCBvZiBhZGRpbmcgYSBuZXcgdXJsIGludG8gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIHJlcGxhY2U/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNjcm9sbCBiZWhhdmlvclxuICAgKlxuICAgKiBAZXhhbXBsZSBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvbGluayNkaXNhYmxlLXNjcm9sbGluZy10by10aGUtdG9wLW9mLXRoZS1wYWdlXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgXG4gICAqL1xuICBzY3JvbGw/OiBib29sZWFuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgcGFnZSB3aXRob3V0IHJlcnVubmluZyBbYGdldFN0YXRpY1Byb3BzYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvcGFnZXMvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL2dldC1zdGF0aWMtcHJvcHMpLCBbYGdldFNlcnZlclNpZGVQcm9wc2BdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL3BhZ2VzL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vZGF0YS1mZXRjaGluZy9nZXQtc2VydmVyLXNpZGUtcHJvcHMpIG9yIFtgZ2V0SW5pdGlhbFByb3BzYF0oL2RvY3MvcGFnZXMvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvZ2V0LWluaXRpYWwtcHJvcHMpLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIC8qKlxuICAgKiBGb3JjZXMgYExpbmtgIHRvIHNlbmQgdGhlIGBocmVmYCBwcm9wZXJ0eSB0byBpdHMgY2hpbGQuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKi9cbiAgcGFzc0hyZWY/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCB0aGUgcGFnZSBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogQW55IGA8TGluayAvPmAgdGhhdCBpcyBpbiB0aGUgdmlld3BvcnQgKGluaXRpYWxseSBvciB0aHJvdWdoIHNjcm9sbCkgd2lsbCBiZSBwcmVmZXRjaGVkLlxuICAgKiBQcmVmZXRjaCBjYW4gYmUgZGlzYWJsZWQgYnkgcGFzc2luZyBgcHJlZmV0Y2g9e2ZhbHNlfWAuIFByZWZldGNoaW5nIGlzIG9ubHkgZW5hYmxlZCBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiBJbiBBcHAgUm91dGVyOlxuICAgKiAtIGBudWxsYCAoZGVmYXVsdCk6IEZvciBzdGF0aWNhbGx5IGdlbmVyYXRlZCBwYWdlcywgdGhpcyB3aWxsIHByZWZldGNoIHRoZSBmdWxsIFJlYWN0IFNlcnZlciBDb21wb25lbnQgZGF0YS4gRm9yIGR5bmFtaWMgcGFnZXMsIHRoaXMgd2lsbCBwcmVmZXRjaCB1cCB0byB0aGUgbmVhcmVzdCByb3V0ZSBzZWdtZW50IHdpdGggYSBbYGxvYWRpbmcuanNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9maWxlLWNvbnZlbnRpb25zL2xvYWRpbmcpIGZpbGUuIElmIHRoZXJlIGlzIG5vIGxvYWRpbmcgZmlsZSwgaXQgd2lsbCBub3QgZmV0Y2ggdGhlIGZ1bGwgdHJlZSB0byBhdm9pZCBmZXRjaGluZyB0b28gbXVjaCBkYXRhLlxuICAgKiAtIGB0cnVlYDogVGhpcyB3aWxsIHByZWZldGNoIHRoZSBmdWxsIFJlYWN0IFNlcnZlciBDb21wb25lbnQgZGF0YSBmb3IgYWxsIHJvdXRlIHNlZ21lbnRzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleSBjb250YWluIGEgc2VnbWVudCB3aXRoIGBsb2FkaW5nLmpzYC5cbiAgICogLSBgZmFsc2VgOiBUaGlzIHdpbGwgbm90IHByZWZldGNoIGFueSBkYXRhLCBldmVuIG9uIGhvdmVyLlxuICAgKlxuICAgKiBJbiBQYWdlcyBSb3V0ZXI6XG4gICAqIC0gYHRydWVgIChkZWZhdWx0KTogVGhlIGZ1bGwgcm91dGUgJiBpdHMgZGF0YSB3aWxsIGJlIHByZWZldGNoZWQuXG4gICAqIC0gYGZhbHNlYDogUHJlZmV0Y2hpbmcgd2lsbCBub3QgaGFwcGVuIHdoZW4gZW50ZXJpbmcgdGhlIHZpZXdwb3J0LCBidXQgd2lsbCBzdGlsbCBoYXBwZW4gb24gaG92ZXIuXG4gICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgIChwYWdlcyByb3V0ZXIpIG9yIGBudWxsYCAoYXBwIHJvdXRlcilcbiAgICovXG4gIHByZWZldGNoPzogYm9vbGVhbiB8IG51bGxcbiAgLyoqXG4gICAqIFRoZSBhY3RpdmUgbG9jYWxlIGlzIGF1dG9tYXRpY2FsbHkgcHJlcGVuZGVkLiBgbG9jYWxlYCBhbGxvd3MgZm9yIHByb3ZpZGluZyBhIGRpZmZlcmVudCBsb2NhbGUuXG4gICAqIFdoZW4gYGZhbHNlYCBgaHJlZmAgaGFzIHRvIGluY2x1ZGUgdGhlIGxvY2FsZSBhcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBkaXNhYmxlZC5cbiAgICogTm90ZTogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgUGFnZXMgUm91dGVyLlxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2VcbiAgLyoqXG4gICAqIEVuYWJsZSBsZWdhY3kgbGluayBiZWhhdmlvci5cbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2NvbW1pdC80ODllNjVlZDk4NTQ0ZTY5YjBhZmQ3ZTBjZmMzZjlmNmMyYjgwM2I3XG4gICAqL1xuICBsZWdhY3lCZWhhdmlvcj86IGJvb2xlYW5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIG1vdXNlIHBvaW50ZXIgaXMgbW92ZWQgb250byBMaW5rXG4gICAqL1xuICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gTGluayBpcyB0b3VjaGVkLlxuICAgKi9cbiAgb25Ub3VjaFN0YXJ0PzogUmVhY3QuVG91Y2hFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG4gIC8qKlxuICAgKiBPcHRpb25hbCBldmVudCBoYW5kbGVyIGZvciB3aGVuIExpbmsgaXMgY2xpY2tlZC5cbiAgICovXG4gIG9uQ2xpY2s/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbn1cblxuLy8gVE9ETy1BUFA6IEluY2x1ZGUgdGhlIGZ1bGwgc2V0IG9mIEFuY2hvciBwcm9wc1xuLy8gYWRkaW5nIHRoaXMgdG8gdGhlIHB1YmxpY2x5IGV4cG9ydGVkIHR5cGUgY3VycmVudGx5IGJyZWFrcyBleGlzdGluZyBhcHBzXG5cbi8vIGBSb3V0ZUluZmVyVHlwZWAgaXMgYSBzdHViIGhlcmUgdG8gYXZvaWQgYnJlYWtpbmcgYHR5cGVkUm91dGVzYCB3aGVuIHRoZSB0eXBlXG4vLyBpc24ndCBnZW5lcmF0ZWQgeWV0LiBJdCB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHdlYnBhY2sgcGx1Z2luIHJ1bnMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgdHlwZSBMaW5rUHJvcHM8Um91dGVJbmZlclR5cGUgPSBhbnk+ID0gSW50ZXJuYWxMaW5rUHJvcHNcbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxPbWl0PEludGVybmFsTGlua1Byb3BzLCAnbG9jYWxlJz4+XG5cbmZ1bmN0aW9uIHByZWZldGNoKFxuICByb3V0ZXI6IEFwcFJvdXRlckluc3RhbmNlLFxuICBocmVmOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFByZWZldGNoT3B0aW9uc1xuKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgZG9QcmVmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBub3RlIHRoYXQgYGFwcFJvdXRlci5wcmVmZXRjaCgpYCBpcyBjdXJyZW50bHkgc3luYyxcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIHdyYXAgdGhpcyBjYWxsIGluIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGFibGUgdG8gY2F0Y2goKSBlcnJvcnMgYmVsb3cuXG4gICAgcmV0dXJuIHJvdXRlci5wcmVmZXRjaChocmVmLCBvcHRpb25zKVxuICB9XG5cbiAgLy8gUHJlZmV0Y2ggdGhlIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIGRvUHJlZmV0Y2goKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0JylcbiAgcmV0dXJuIChcbiAgICAodGFyZ2V0ICYmIHRhcmdldCAhPT0gJ19zZWxmJykgfHxcbiAgICBldmVudC5tZXRhS2V5IHx8XG4gICAgZXZlbnQuY3RybEtleSB8fFxuICAgIGV2ZW50LnNoaWZ0S2V5IHx8XG4gICAgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgKGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyKVxuICApXG59XG5cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKFxuICBlOiBSZWFjdC5Nb3VzZUV2ZW50LFxuICByb3V0ZXI6IE5leHRSb3V0ZXIgfCBBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2hhbGxvdz86IGJvb2xlYW4sXG4gIHNjcm9sbD86IGJvb2xlYW5cbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICAvLyBhbmNob3JzIGluc2lkZSBhbiBzdmcgaGF2ZSBhIGxvd2VyY2FzZSBub2RlTmFtZVxuICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0EnXG5cbiAgaWYgKGlzQW5jaG9yTm9kZU5hbWUgJiYgaXNNb2RpZmllZEV2ZW50KGUpKSB7XG4gICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgcmV0dXJuXG4gIH1cblxuICBlLnByZXZlbnREZWZhdWx0KClcblxuICBjb25zdCBuYXZpZ2F0ZSA9ICgpID0+IHtcbiAgICAvLyBJZiB0aGUgcm91dGVyIGlzIGFuIE5leHRSb3V0ZXIgaW5zdGFuY2UgaXQgd2lsbCBoYXZlIGBiZWZvcmVQb3BTdGF0ZWBcbiAgICBjb25zdCByb3V0ZXJTY3JvbGwgPSBzY3JvbGwgPz8gdHJ1ZVxuICAgIGlmICgnYmVmb3JlUG9wU3RhdGUnIGluIHJvdXRlcikge1xuICAgICAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7XG4gICAgICAgIHNoYWxsb3csXG4gICAgICAgIHNjcm9sbDogcm91dGVyU2Nyb2xsLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGFzIHx8IGhyZWYsIHtcbiAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGwsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbihuYXZpZ2F0ZSlcbn1cblxudHlwZSBMaW5rUHJvcHNSZWFsID0gUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48XG4gIE9taXQ8UmVhY3QuQW5jaG9ySFRNTEF0dHJpYnV0ZXM8SFRNTEFuY2hvckVsZW1lbnQ+LCBrZXlvZiBMaW5rUHJvcHM+ICZcbiAgICBMaW5rUHJvcHNcbj5cblxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nT3JVcmwodXJsT2JqT3JTdHJpbmc6IFVybE9iamVjdCB8IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgdXJsT2JqT3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHVybE9iak9yU3RyaW5nXG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybE9iak9yU3RyaW5nKVxufVxuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgZXh0ZW5kcyB0aGUgSFRNTCBgPGE+YCBlbGVtZW50IHRvIHByb3ZpZGUgW3ByZWZldGNoaW5nXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL2xpbmtpbmctYW5kLW5hdmlnYXRpbmcjMi1wcmVmZXRjaGluZylcbiAqIGFuZCBjbGllbnQtc2lkZSBuYXZpZ2F0aW9uIGJldHdlZW4gcm91dGVzLlxuICpcbiAqIEl0IGlzIHRoZSBwcmltYXJ5IHdheSB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHJvdXRlcyBpbiBOZXh0LmpzLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgZG9jczogYDxMaW5rPmBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvbGluaylcbiAqL1xuY29uc3QgTGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIExpbmtQcm9wc1JlYWw+KFxuICBmdW5jdGlvbiBMaW5rQ29tcG9uZW50KHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgICBsZXQgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuXG4gICAgY29uc3Qge1xuICAgICAgaHJlZjogaHJlZlByb3AsXG4gICAgICBhczogYXNQcm9wLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuUHJvcCxcbiAgICAgIHByZWZldGNoOiBwcmVmZXRjaFByb3AgPSBudWxsLFxuICAgICAgcGFzc0hyZWYsXG4gICAgICByZXBsYWNlLFxuICAgICAgc2hhbGxvdyxcbiAgICAgIHNjcm9sbCxcbiAgICAgIG9uQ2xpY2ssXG4gICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlclByb3AsXG4gICAgICBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydFByb3AsXG4gICAgICBsZWdhY3lCZWhhdmlvciA9IGZhbHNlLFxuICAgICAgLi4ucmVzdFByb3BzXG4gICAgfSA9IHByb3BzXG5cbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcFxuXG4gICAgaWYgKFxuICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ251bWJlcicpXG4gICAgKSB7XG4gICAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVyID0gUmVhY3QudXNlQ29udGV4dChBcHBSb3V0ZXJDb250ZXh0KVxuXG4gICAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NzaWJsZSBzdGF0ZXMgZm9yIHByZWZldGNoIGFyZTpcbiAgICAgKiAtIG51bGw6IHRoaXMgaXMgdGhlIGRlZmF1bHQgXCJhdXRvXCIgbW9kZSwgd2hlcmUgd2Ugd2lsbCBwcmVmZXRjaCBwYXJ0aWFsbHkgaWYgdGhlIGxpbmsgaXMgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogLSB0cnVlOiB3ZSB3aWxsIHByZWZldGNoIGlmIHRoZSBsaW5rIGlzIHZpc2libGUgYW5kIHByZWZldGNoIHRoZSBmdWxsIHBhZ2UsIG5vdCBqdXN0IHBhcnRpYWxseVxuICAgICAqIC0gZmFsc2U6IHdlIHdpbGwgbm90IHByZWZldGNoIGlmIGluIHRoZSB2aWV3cG9ydCBhdCBhbGxcbiAgICAgKi9cbiAgICBjb25zdCBhcHBQcmVmZXRjaEtpbmQgPVxuICAgICAgcHJlZmV0Y2hQcm9wID09PSBudWxsID8gUHJlZmV0Y2hLaW5kLkFVVE8gOiBQcmVmZXRjaEtpbmQuRlVMTFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzOiB7XG4gICAgICAgIGtleTogc3RyaW5nXG4gICAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgICAgYWN0dWFsOiBzdHJpbmdcbiAgICAgIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArXG4gICAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgICAgOiAnJylcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkOiBSZWNvcmQ8TGlua1Byb3BzUmVxdWlyZWQsIHRydWU+ID0ge1xuICAgICAgICBocmVmOiB0cnVlLFxuICAgICAgfSBhcyBjb25zdFxuICAgICAgY29uc3QgcmVxdWlyZWRQcm9wczogTGlua1Byb3BzUmVxdWlyZWRbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICAgICkgYXMgTGlua1Byb3BzUmVxdWlyZWRbXVxuICAgICAgcmVxdWlyZWRQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc1JlcXVpcmVkKSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHByb3BzW2tleV0gPT0gbnVsbCB8fFxuICAgICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcHJvcHNba2V5XSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgIGNvbnN0IF86IG5ldmVyID0ga2V5XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICAgIGFzOiB0cnVlLFxuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgIHBhc3NIcmVmOiB0cnVlLFxuICAgICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0cnVlLFxuICAgICAgICBvblRvdWNoU3RhcnQ6IHRydWUsXG4gICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlLFxuICAgICAgfSBhcyBjb25zdFxuICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgICBvcHRpb25hbFByb3BzR3VhcmRcbiAgICAgICkgYXMgTGlua1Byb3BzT3B0aW9uYWxbXVxuICAgICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XVxuXG4gICAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnb25DbGljaycgfHxcbiAgICAgICAgICBrZXkgPT09ICdvbk1vdXNlRW50ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnb25Ub3VjaFN0YXJ0J1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiAnYGZ1bmN0aW9uYCcsXG4gICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ3JlcGxhY2UnIHx8XG4gICAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3NoYWxsb3cnIHx8XG4gICAgICAgICAga2V5ID09PSAncGFzc0hyZWYnIHx8XG4gICAgICAgICAga2V5ID09PSAncHJlZmV0Y2gnIHx8XG4gICAgICAgICAga2V5ID09PSAnbGVnYWN5QmVoYXZpb3InXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW5gJyxcbiAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHByb3BzLmxvY2FsZSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAnVGhlIGBsb2NhbGVgIHByb3AgaXMgbm90IHN1cHBvcnRlZCBpbiBgbmV4dC9saW5rYCB3aGlsZSB1c2luZyB0aGUgYGFwcGAgcm91dGVyLiBSZWFkIG1vcmUgYWJvdXQgYXBwIHJvdXRlciBpbnRlcm5hbGl6YXRpb246IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JvdXRpbmcvaW50ZXJuYXRpb25hbGl6YXRpb24nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghYXNQcm9wKSB7XG4gICAgICAgIGxldCBocmVmOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBocmVmID0gaHJlZlByb3BcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlb2YgaHJlZlByb3AgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgdHlwZW9mIGhyZWZQcm9wLnBhdGhuYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICApIHtcbiAgICAgICAgICBocmVmID0gaHJlZlByb3AucGF0aG5hbWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgY29uc3QgaGFzRHluYW1pY1NlZ21lbnQgPSBocmVmXG4gICAgICAgICAgICAuc3BsaXQoJy8nKVxuICAgICAgICAgICAgLnNvbWUoKHNlZ21lbnQpID0+IHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSlcblxuICAgICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgRHluYW1pYyBocmVmIFxcYCR7aHJlZn1cXGAgZm91bmQgaW4gPExpbms+IHdoaWxlIHVzaW5nIHRoZSBcXGAvYXBwXFxgIHJvdXRlciwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2FwcC1kaXItZHluYW1pYy1ocmVmYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgaHJlZiwgYXMgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgIGFzOiBhc1Byb3AgPyBmb3JtYXRTdHJpbmdPclVybChhc1Byb3ApIDogcmVzb2x2ZWRIcmVmLFxuICAgICAgfVxuICAgIH0sIFtocmVmUHJvcCwgYXNQcm9wXSlcblxuICAgIGNvbnN0IHByZXZpb3VzSHJlZiA9IFJlYWN0LnVzZVJlZjxzdHJpbmc+KGhyZWYpXG4gICAgY29uc3QgcHJldmlvdXNBcyA9IFJlYWN0LnVzZVJlZjxzdHJpbmc+KGFzKVxuXG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkOiBhbnlcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFwib25Nb3VzZUVudGVyXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbk1vdXNlRW50ZXIgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBObyBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBvbmUgY2hpbGQgaXMgcmVxdWlyZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1uby1jaGlsZHJlbmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IG9ubHkgb25lIGNoaWxkIGlzIHN1cHBvcnRlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW11bHRpcGxlLWNoaWxkcmVuYCArXG4gICAgICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgICAgIDogJycpXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBpZiAoKGNoaWxkcmVuIGFzIGFueSk/LnR5cGUgPT09ICdhJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkUmVmOiBhbnkgPSBsZWdhY3lCZWhhdmlvclxuICAgICAgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZlxuICAgICAgOiBmb3J3YXJkZWRSZWZcblxuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9IHVzZUludGVyc2VjdGlvbih7XG4gICAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICAgIH0pXG5cbiAgICBjb25zdCBzZXRJbnRlcnNlY3Rpb25XaXRoUmVzZXRSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIChlbDogRWxlbWVudCkgPT4ge1xuICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG4gICAgICAgIGlmIChwcmV2aW91c0FzLmN1cnJlbnQgIT09IGFzIHx8IHByZXZpb3VzSHJlZi5jdXJyZW50ICE9PSBocmVmKSB7XG4gICAgICAgICAgcmVzZXRWaXNpYmxlKClcbiAgICAgICAgICBwcmV2aW91c0FzLmN1cnJlbnQgPSBhc1xuICAgICAgICAgIHByZXZpb3VzSHJlZi5jdXJyZW50ID0gaHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKVxuICAgICAgfSxcbiAgICAgIFthcywgaHJlZiwgcmVzZXRWaXNpYmxlLCBzZXRJbnRlcnNlY3Rpb25SZWZdXG4gICAgKVxuXG4gICAgY29uc3Qgc2V0UmVmID0gdXNlTWVyZ2VkUmVmKHNldEludGVyc2VjdGlvbldpdGhSZXNldFJlZiwgY2hpbGRSZWYpXG5cbiAgICAvLyBQcmVmZXRjaCB0aGUgVVJMIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBhbmQgaXQncyB2aXNpYmxlLlxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBpbiBkZXYsIHdlIG9ubHkgcHJlZmV0Y2ggb24gaG92ZXIgdG8gYXZvaWQgd2FzdGluZyByZXNvdXJjZXMgYXMgdGhlIHByZWZldGNoIHdpbGwgdHJpZ2dlciBjb21waWxpbmcgdGhlIHBhZ2UuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gcHJlZmV0Y2ggdGhlIFVSTCwgZG9uJ3QgZG8gcHJlZmV0Y2guXG4gICAgICBpZiAoIWlzVmlzaWJsZSB8fCAhcHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCB7XG4gICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZCxcbiAgICAgIH0pXG4gICAgfSwgW2FzLCBocmVmLCBpc1Zpc2libGUsIHByZWZldGNoRW5hYmxlZCwgcm91dGVyLCBhcHBQcmVmZXRjaEtpbmRdKVxuXG4gICAgY29uc3QgY2hpbGRQcm9wczoge1xuICAgICAgb25Ub3VjaFN0YXJ0PzogUmVhY3QuVG91Y2hFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG4gICAgICBvbk1vdXNlRW50ZXI6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAgICAgb25DbGljazogUmVhY3QuTW91c2VFdmVudEhhbmRsZXI8SFRNTEFuY2hvckVsZW1lbnQ+XG4gICAgICBocmVmPzogc3RyaW5nXG4gICAgICByZWY/OiBhbnlcbiAgICB9ID0ge1xuICAgICAgcmVmOiBzZXRSZWYsXG4gICAgICBvbkNsaWNrKGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENvbXBvbmVudCByZW5kZXJlZCBpbnNpZGUgbmV4dC9saW5rIGhhcyB0byBwYXNzIGNsaWNrIGV2ZW50IHRvIFwib25DbGlja1wiIHByb3AuYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkNsaWNrKGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICAgICBjaGlsZC5wcm9wcyAmJlxuICAgICAgICAgIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nXG4gICAgICAgICkge1xuICAgICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwpXG4gICAgICB9LFxuICAgICAgb25Nb3VzZUVudGVyKGUpIHtcbiAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Nb3VzZUVudGVyUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uTW91c2VFbnRlclByb3AoZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBsZWdhY3lCZWhhdmlvciAmJlxuICAgICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCB7XG4gICAgICAgICAga2luZDogYXBwUHJlZmV0Y2hLaW5kLFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIG9uVG91Y2hTdGFydDogcHJvY2Vzcy5lbnYuX19ORVhUX0xJTktfTk9fVE9VQ0hfU1RBUlRcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Ub3VjaFN0YXJ0UHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwge1xuICAgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sXG4gICAgfVxuXG4gICAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gICAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyLlxuICAgIC8vIElmIHRoZSB1cmwgaXMgYWJzb2x1dGUsIHdlIGNhbiBieXBhc3MgdGhlIGxvZ2ljIHRvIHByZXBlbmQgdGhlIGJhc2VQYXRoLlxuICAgIGlmIChpc0Fic29sdXRlVXJsKGFzKSkge1xuICAgICAgY2hpbGRQcm9wcy5ocmVmID0gYXNcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgIWxlZ2FjeUJlaGF2aW9yIHx8XG4gICAgICBwYXNzSHJlZiB8fFxuICAgICAgKGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpXG4gICAgKSB7XG4gICAgICBjaGlsZFByb3BzLmhyZWYgPSBhZGRCYXNlUGF0aChhcylcbiAgICB9XG5cbiAgICByZXR1cm4gbGVnYWN5QmVoYXZpb3IgPyAoXG4gICAgICBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG4gICAgKSA6IChcbiAgICAgIDxhIHsuLi5yZXN0UHJvcHN9IHsuLi5jaGlsZFByb3BzfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9hPlxuICAgIClcbiAgfVxuKVxuXG5leHBvcnQgZGVmYXVsdCBMaW5rXG4iXSwibmFtZXMiOlsicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwib3B0aW9ucyIsIndpbmRvdyIsImRvUHJlZmV0Y2giLCJjYXRjaCIsImVyciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiZXZlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm5hdGl2ZUV2ZW50Iiwid2hpY2giLCJsaW5rQ2xpY2tlZCIsImUiLCJhcyIsInJlcGxhY2UiLCJzaGFsbG93Iiwic2Nyb2xsIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwidG9VcHBlckNhc2UiLCJwcmV2ZW50RGVmYXVsdCIsIm5hdmlnYXRlIiwicm91dGVyU2Nyb2xsIiwiUmVhY3QiLCJzdGFydFRyYW5zaXRpb24iLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiZm9ybWF0VXJsIiwiTGluayIsImZvcndhcmRSZWYiLCJMaW5rQ29tcG9uZW50IiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJjaGlsZHJlbiIsImhyZWZQcm9wIiwiYXNQcm9wIiwiY2hpbGRyZW5Qcm9wIiwicHJlZmV0Y2hQcm9wIiwicGFzc0hyZWYiLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUVudGVyUHJvcCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydFByb3AiLCJsZWdhY3lCZWhhdmlvciIsInJlc3RQcm9wcyIsImEiLCJ1c2VDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsInByZWZldGNoRW5hYmxlZCIsImFwcFByZWZldGNoS2luZCIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJGVUxMIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJsb2NhbGUiLCJ3YXJuT25jZSIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInByZXZpb3VzSHJlZiIsInVzZVJlZiIsInByZXZpb3VzQXMiLCJjaGlsZCIsImNvbnNvbGUiLCJ3YXJuIiwiQ2hpbGRyZW4iLCJvbmx5IiwidHlwZSIsImNoaWxkUmVmIiwicmVmIiwic2V0SW50ZXJzZWN0aW9uUmVmIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdE1hcmdpbiIsInNldEludGVyc2VjdGlvbldpdGhSZXNldFJlZiIsInVzZUNhbGxiYWNrIiwiZWwiLCJjdXJyZW50Iiwic2V0UmVmIiwidXNlTWVyZ2VkUmVmIiwidXNlRWZmZWN0Iiwia2luZCIsImNoaWxkUHJvcHMiLCJkZWZhdWx0UHJldmVudGVkIiwiX19ORVhUX0xJTktfTk9fVE9VQ0hfU1RBUlQiLCJ1bmRlZmluZWQiLCJpc0Fic29sdXRlVXJsIiwiYWRkQmFzZVBhdGgiLCJjbG9uZUVsZW1lbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLGtCQUFrQjtlQUFsQkE7O0lBaEJBQyxtQkFBbUI7ZUFBbkJBOzs7QUFBTixNQUFNQSxzQkFDVixPQUFPQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlO2dCQUNiLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUEsQ0FBSTtZQUM1QztRQUNGO0lBQ0YsR0FBRztBQUNMO0FBRUssTUFBTU4scUJBQ1YsT0FBT0UsU0FBUyxlQUNmQSxLQUFLRixrQkFBa0IsSUFDdkJFLEtBQUtGLGtCQUFrQixDQUFDRyxJQUFJLENBQUNDLFdBQy9CLFNBQVVVLEVBQVU7SUFDbEIsT0FBT0MsYUFBYUQ7QUFDdEIiLCJzb3VyY2VzIjpbIkU6XFxXcGlcXFJlZ3VsYXJseVxcQ291cnNlc1xcU3JcXDIwMjRfQ19UZXJtXFxDUzQyNDFcXHNyY1xcY2xpZW50XFxyZXF1ZXN0LWlkbGUtY2FsbGJhY2sudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmXG4gICAgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrICYmXG4gICAgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSkgfHxcbiAgZnVuY3Rpb24gKGNiOiBJZGxlUmVxdWVzdENhbGxiYWNrKTogbnVtYmVyIHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYih7XG4gICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0sIDEpXG4gIH1cblxuZXhwb3J0IGNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBzZWxmLmNhbmNlbElkbGVDYWxsYmFjayAmJlxuICAgIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSkgfHxcbiAgZnVuY3Rpb24gKGlkOiBudW1iZXIpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKVxuICB9XG4iXSwibmFtZXMiOlsiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNlbGYiLCJiaW5kIiwid2luZG93IiwiY2IiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJzZXRUaW1lb3V0IiwiZGlkVGltZW91dCIsInRpbWVSZW1haW5pbmciLCJNYXRoIiwibWF4IiwiaWQiLCJjbGVhclRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === 'function';\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || ''\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OzttREErRmdCQTs7O2VBQUFBOzs7bUNBL0Z5QztpREFJbEQ7QUFxQlAsTUFBTUMsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUVoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQXVCLEVBQUU7QUFFL0IsU0FBU0MsZUFBZUMsT0FBb0M7SUFDMUQsTUFBTUMsS0FBSztRQUNUQyxNQUFNRixRQUFRRSxJQUFJLElBQUk7UUFDdEJDLFFBQVFILFFBQVFJLFVBQVUsSUFBSTtJQUNoQztJQUNBLE1BQU1DLFdBQVdQLE9BQU9RLElBQUksQ0FDMUIsQ0FBQ0MsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtJQUUzRCxJQUFJSztJQUVKLElBQUlILFVBQVU7UUFDWkcsV0FBV1osVUFBVWEsR0FBRyxDQUFDSjtRQUN6QixJQUFJRyxVQUFVO1lBQ1osT0FBT0E7UUFDVDtJQUNGO0lBRUEsTUFBTUUsV0FBVyxJQUFJYjtJQUNyQixNQUFNYyxXQUFXLElBQUloQixxQkFBcUIsQ0FBQ2lCO1FBQ3pDQSxRQUFRQyxPQUFPLENBQUMsQ0FBQ0M7WUFDZixNQUFNQyxXQUFXTCxTQUFTRCxHQUFHLENBQUNLLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN6QkYsU0FBU0U7WUFDWDtRQUNGO0lBQ0YsR0FBR2pCO0lBQ0hRLFdBQVc7UUFDVFA7UUFDQVU7UUFDQUQ7SUFDRjtJQUVBWixPQUFPc0IsSUFBSSxDQUFDbkI7SUFDWkwsVUFBVXlCLEdBQUcsQ0FBQ3BCLElBQUlPO0lBQ2xCLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTYyxRQUNQQyxPQUFnQixFQUNoQlIsUUFBeUIsRUFDekJmLE9BQW9DO0lBRXBDLE1BQU0sRUFBRUMsRUFBRSxFQUFFVSxRQUFRLEVBQUVELFFBQVEsRUFBRSxHQUFHWCxlQUFlQztJQUNsRFUsU0FBU1csR0FBRyxDQUFDRSxTQUFTUjtJQUV0QkosU0FBU1csT0FBTyxDQUFDQztJQUNqQixPQUFPLFNBQVNDO1FBQ2RkLFNBQVNlLE1BQU0sQ0FBQ0Y7UUFDaEJaLFNBQVNhLFNBQVMsQ0FBQ0Q7UUFFbkIsdURBQXVEO1FBQ3ZELElBQUliLFNBQVNnQixJQUFJLEtBQUssR0FBRztZQUN2QmYsU0FBU2dCLFVBQVU7WUFDbkIvQixVQUFVNkIsTUFBTSxDQUFDeEI7WUFDakIsTUFBTTJCLFFBQVE5QixPQUFPK0IsU0FBUyxDQUM1QixDQUFDdEIsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtZQUUzRCxJQUFJeUIsUUFBUSxDQUFDLEdBQUc7Z0JBQ2Q5QixPQUFPZ0MsTUFBTSxDQUFDRixPQUFPO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGO0FBRU8sU0FBU25DLGdCQUFtQyxLQUlqQztJQUppQyxNQUNqRHNDLE9BQU8sRUFDUDNCLFVBQVUsRUFDVjRCLFFBQVEsRUFDUSxHQUppQztJQUtqRCxNQUFNQyxhQUFzQkQsWUFBWSxDQUFDdEM7SUFFekMsTUFBTSxDQUFDd0MsU0FBU0MsV0FBVyxHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxRQUFBQSxFQUFTO0lBQ3ZDLE1BQU1DLGFBQWFDLENBQUFBLEdBQUFBLE9BQUFBLE1BQUFBLEVBQWlCO0lBQ3BDLE1BQU1DLGFBQWFDLENBQUFBLEdBQUFBLE9BQUFBLFdBQUFBLEVBQVksQ0FBQ2pCO1FBQzlCYyxXQUFXSSxPQUFPLEdBQUdsQjtJQUN2QixHQUFHLEVBQUU7SUFFTG1CLENBQUFBLEdBQUFBLE9BQUFBLFNBQUFBLEVBQVU7UUFDUixJQUFJaEQseUJBQXlCO1lBQzNCLElBQUl1QyxjQUFjQyxTQUFTO1lBRTNCLE1BQU1YLFVBQVVjLFdBQVdJLE9BQU87WUFDbEMsSUFBSWxCLFdBQVdBLFFBQVFvQixPQUFPLEVBQUU7Z0JBQzlCLE1BQU1uQixZQUFZRixRQUNoQkMsU0FDQSxDQUFDTixZQUFjQSxhQUFha0IsV0FBV2xCLFlBQ3ZDO29CQUFFZixJQUFJLEVBQUU2QixXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTVSxPQUFPO29CQUFFckM7Z0JBQVc7Z0JBR3ZDLE9BQU9vQjtZQUNUO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQ1UsU0FBUztnQkFDWixNQUFNVSxlQUFlQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQUFBLEVBQW9CLElBQU1WLFdBQVc7Z0JBQzFELE9BQU8sSUFBTVcsQ0FBQUEsR0FBQUEscUJBQUFBLGtCQUFBQSxFQUFtQkY7WUFDbEM7UUFDRjtJQUNBLHVEQUF1RDtJQUN6RCxHQUFHO1FBQUNYO1FBQVk3QjtRQUFZMkI7UUFBU0c7UUFBU0csV0FBV0ksT0FBTztLQUFDO0lBRWpFLE1BQU1NLGVBQWVQLENBQUFBLEdBQUFBLE9BQUFBLFdBQUFBLEVBQVk7UUFDL0JMLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQUNJO1FBQVlMO1FBQVNhO0tBQWE7QUFDNUMiLCJzb3VyY2VzIjpbIkU6XFxXcGlcXFJlZ3VsYXJseVxcQ291cnNlc1xcU3JcXDIwMjRfQ19UZXJtXFxDUzQyNDFcXHNyY1xcY2xpZW50XFx1c2UtaW50ZXJzZWN0aW9uLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQge1xuICByZXF1ZXN0SWRsZUNhbGxiYWNrLFxuICBjYW5jZWxJZGxlQ2FsbGJhY2ssXG59IGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuXG50eXBlIFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdCA9IFBpY2s8XG4gIEludGVyc2VjdGlvbk9ic2VydmVySW5pdCxcbiAgJ3Jvb3RNYXJnaW4nIHwgJ3Jvb3QnXG4+XG5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uID0geyBkaXNhYmxlZD86IGJvb2xlYW4gfSAmIFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdCAmIHtcbiAgICByb290UmVmPzogUmVhY3QuUmVmT2JqZWN0PEhUTUxFbGVtZW50IHwgbnVsbD4gfCBudWxsXG4gIH1cbnR5cGUgT2JzZXJ2ZUNhbGxiYWNrID0gKGlzVmlzaWJsZTogYm9vbGVhbikgPT4gdm9pZFxudHlwZSBJZGVudGlmaWVyID0ge1xuICByb290OiBFbGVtZW50IHwgRG9jdW1lbnQgfCBudWxsXG4gIG1hcmdpbjogc3RyaW5nXG59XG50eXBlIE9ic2VydmVyID0ge1xuICBpZDogSWRlbnRpZmllclxuICBvYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgZWxlbWVudHM6IE1hcDxFbGVtZW50LCBPYnNlcnZlQ2FsbGJhY2s+XG59XG5cbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nXG5cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXA8SWRlbnRpZmllciwgT2JzZXJ2ZXI+KClcbmNvbnN0IGlkTGlzdDogSWRlbnRpZmllcltdID0gW11cblxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KTogT2JzZXJ2ZXIge1xuICBjb25zdCBpZCA9IHtcbiAgICByb290OiBvcHRpb25zLnJvb3QgfHwgbnVsbCxcbiAgICBtYXJnaW46IG9wdGlvbnMucm9vdE1hcmdpbiB8fCAnJyxcbiAgfVxuICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKFxuICAgIChvYmopID0+IG9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpblxuICApXG4gIGxldCBpbnN0YW5jZTogT2JzZXJ2ZXIgfCB1bmRlZmluZWRcblxuICBpZiAoZXhpc3RpbmcpIHtcbiAgICBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoZXhpc3RpbmcpXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VcbiAgICB9XG4gIH1cblxuICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXA8RWxlbWVudCwgT2JzZXJ2ZUNhbGxiYWNrPigpXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KVxuICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgaXNWaXNpYmxlKSB7XG4gICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LCBvcHRpb25zKVxuICBpbnN0YW5jZSA9IHtcbiAgICBpZCxcbiAgICBvYnNlcnZlcixcbiAgICBlbGVtZW50cyxcbiAgfVxuXG4gIGlkTGlzdC5wdXNoKGlkKVxuICBvYnNlcnZlcnMuc2V0KGlkLCBpbnN0YW5jZSlcbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbmZ1bmN0aW9uIG9ic2VydmUoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGNhbGxiYWNrOiBPYnNlcnZlQ2FsbGJhY2ssXG4gIG9wdGlvbnM6IFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdFxuKTogKCkgPT4gdm9pZCB7XG4gIGNvbnN0IHsgaWQsIG9ic2VydmVyLCBlbGVtZW50cyB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucylcbiAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrKVxuXG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpOiB2b2lkIHtcbiAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudClcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudClcblxuICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGlkKVxuICAgICAgY29uc3QgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KFxuICAgICAgICAob2JqKSA9PiBvYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW5cbiAgICAgIClcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb248VCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgcm9vdFJlZixcbiAgcm9vdE1hcmdpbixcbiAgZGlzYWJsZWQsXG59OiBVc2VJbnRlcnNlY3Rpb24pOiBbKGVsZW1lbnQ6IFQgfCBudWxsKSA9PiB2b2lkLCBib29sZWFuLCAoKSA9PiB2b2lkXSB7XG4gIGNvbnN0IGlzRGlzYWJsZWQ6IGJvb2xlYW4gPSBkaXNhYmxlZCB8fCAhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcblxuICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgZWxlbWVudFJlZiA9IHVzZVJlZjxUIHwgbnVsbD4obnVsbClcbiAgY29uc3Qgc2V0RWxlbWVudCA9IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCkgPT4ge1xuICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IGVsZW1lbnRcbiAgfSwgW10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVyblxuXG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudFJlZi5jdXJyZW50XG4gICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgdW5vYnNlcnZlID0gb2JzZXJ2ZShcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIChpc1Zpc2libGUpID0+IGlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksXG4gICAgICAgICAgeyByb290OiByb290UmVmPy5jdXJyZW50LCByb290TWFyZ2luIH1cbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB1bm9ic2VydmVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gc2V0VmlzaWJsZSh0cnVlKSlcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbElkbGVDYWxsYmFjayhpZGxlQ2FsbGJhY2spXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2lzRGlzYWJsZWQsIHJvb3RNYXJnaW4sIHJvb3RSZWYsIHZpc2libGUsIGVsZW1lbnRSZWYuY3VycmVudF0pXG5cbiAgY29uc3QgcmVzZXRWaXNpYmxlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFZpc2libGUoZmFsc2UpXG4gIH0sIFtdKVxuXG4gIHJldHVybiBbc2V0RWxlbWVudCwgdmlzaWJsZSwgcmVzZXRWaXNpYmxlXVxufVxuIl0sIm5hbWVzIjpbInVzZUludGVyc2VjdGlvbiIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJNYXAiLCJpZExpc3QiLCJjcmVhdGVPYnNlcnZlciIsIm9wdGlvbnMiLCJpZCIsInJvb3QiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJmaW5kIiwib2JqIiwiaW5zdGFuY2UiLCJnZXQiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwiZW50cmllcyIsImZvckVhY2giLCJlbnRyeSIsImNhbGxiYWNrIiwidGFyZ2V0IiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJzZXQiLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJyb290UmVmIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJ1c2VTdGF0ZSIsImVsZW1lbnRSZWYiLCJ1c2VSZWYiLCJzZXRFbGVtZW50IiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwidXNlRWZmZWN0IiwidGFnTmFtZSIsImlkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJyZXNldFZpc2libGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(()=>{});\n    const cleanupB = (0, _react.useRef)(()=>{});\n    return (0, _react.useMemo)(()=>{\n        if (!refA || !refB) {\n            return refA || refB;\n        }\n        return (current)=>{\n            if (current === null) {\n                cleanupA.current();\n                cleanupB.current();\n            } else {\n                cleanupA.current = applyRef(refA, current);\n                cleanupB.current = applyRef(refB, current);\n            }\n        };\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBU2dCQTs7O2VBQUFBOzs7bUNBVDBCO0FBU25DLFNBQVNBLGFBQ2RDLElBQW1CLEVBQ25CQyxJQUFtQjtJQUVuQixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUFtQixLQUFPO0lBQzNDLE1BQU1DLFdBQVdELENBQUFBLEdBQUFBLE9BQUFBLE1BQUFBLEVBQW1CLEtBQU87SUFFM0MsT0FBT0UsQ0FBQUEsR0FBQUEsT0FBQUEsT0FBQUEsRUFBUTtRQUNiLElBQUksQ0FBQ0wsUUFBUSxDQUFDQyxNQUFNO1lBQ2xCLE9BQU9ELFFBQVFDO1FBQ2pCO1FBRUEsT0FBTyxDQUFDSztZQUNOLElBQUlBLFlBQVksTUFBTTtnQkFDcEJKLFNBQVNJLE9BQU87Z0JBQ2hCRixTQUFTRSxPQUFPO1lBQ2xCLE9BQU87Z0JBQ0xKLFNBQVNJLE9BQU8sR0FBR0MsU0FBU1AsTUFBTU07Z0JBQ2xDRixTQUFTRSxPQUFPLEdBQUdDLFNBQVNOLE1BQU1LO1lBQ3BDO1FBQ0Y7SUFDRixHQUFHO1FBQUNOO1FBQU1DO0tBQUs7QUFDakI7QUFFQSxTQUFTTSxTQUNQUCxJQUFnQyxFQUNoQ00sT0FBaUI7SUFFakIsSUFBSSxPQUFPTixTQUFTLFlBQVk7UUFDOUIsTUFBTVEsVUFBVVIsS0FBS007UUFDckIsSUFBSSxPQUFPRSxZQUFZLFlBQVk7WUFDakMsT0FBT0E7UUFDVCxPQUFPO1lBQ0wsT0FBTyxJQUFNUixLQUFLO1FBQ3BCO0lBQ0YsT0FBTztRQUNMQSxLQUFLTSxPQUFPLEdBQUdBO1FBQ2YsT0FBTztZQUNMTixLQUFLTSxPQUFPLEdBQUc7UUFDakI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxzcmNcXGNsaWVudFxcdXNlLW1lcmdlZC1yZWYudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlTWVtbywgdXNlUmVmLCB0eXBlIFJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBUaGlzIGlzIGEgY29tcGF0aWJpbGl0eSBob29rIHRvIHN1cHBvcnQgUmVhY3QgMTggYW5kIDE5IHJlZnMuXG4vLyBJbiAxOSwgYSBjbGVhbnVwIGZ1bmN0aW9uIGZyb20gcmVmcyBtYXkgYmUgcmV0dXJuZWQuXG4vLyBJbiAxOCwgcmV0dXJuaW5nIGEgY2xlYW51cCBmdW5jdGlvbiBjcmVhdGVzIGEgd2FybmluZy5cbi8vIFNpbmNlIHdlIHRha2UgdXNlcnNwYWNlIHJlZnMsIHdlIGRvbid0IGtub3cgYWhlYWQgb2YgdGltZSBpZiBhIGNsZWFudXAgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZC5cbi8vIFRoaXMgaW1wbGVtZW50cyBjbGVhbnVwIGZ1bmN0aW9ucyB3aXRoIHRoZSBvbGQgYmVoYXZpb3IgaW4gMTguXG4vLyBXZSBrbm93IHJlZnMgYXJlIGFsd2F5cyBjYWxsZWQgYWx0ZXJuYXRpbmcgd2l0aCBgbnVsbGAgYW5kIHRoZW4gYFRgLlxuLy8gU28gYSBjYWxsIHdpdGggYG51bGxgIG1lYW5zIHdlIG5lZWQgdG8gY2FsbCB0aGUgcHJldmlvdXMgY2xlYW51cCBmdW5jdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmPFRFbGVtZW50PihcbiAgcmVmQTogUmVmPFRFbGVtZW50PixcbiAgcmVmQjogUmVmPFRFbGVtZW50PlxuKTogUmVmPFRFbGVtZW50PiB7XG4gIGNvbnN0IGNsZWFudXBBID0gdXNlUmVmPCgpID0+IHZvaWQ+KCgpID0+IHt9KVxuICBjb25zdCBjbGVhbnVwQiA9IHVzZVJlZjwoKSA9PiB2b2lkPigoKSA9PiB7fSlcblxuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFyZWZBIHx8ICFyZWZCKSB7XG4gICAgICByZXR1cm4gcmVmQSB8fCByZWZCXG4gICAgfVxuXG4gICAgcmV0dXJuIChjdXJyZW50OiBURWxlbWVudCB8IG51bGwpOiB2b2lkID0+IHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBBLmN1cnJlbnQoKVxuICAgICAgICBjbGVhbnVwQi5jdXJyZW50KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBhcHBseVJlZihyZWZBLCBjdXJyZW50KVxuICAgICAgICBjbGVhbnVwQi5jdXJyZW50ID0gYXBwbHlSZWYocmVmQiwgY3VycmVudClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWZBLCByZWZCXSlcbn1cblxuZnVuY3Rpb24gYXBwbHlSZWY8VEVsZW1lbnQ+KFxuICByZWZBOiBOb25OdWxsYWJsZTxSZWY8VEVsZW1lbnQ+PixcbiAgY3VycmVudDogVEVsZW1lbnRcbikge1xuICBpZiAodHlwZW9mIHJlZkEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjbGVhbnVwID0gcmVmQShjdXJyZW50KVxuICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNsZWFudXBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgpID0+IHJlZkEobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVmQS5jdXJyZW50ID0gY3VycmVudFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZWZBLmN1cnJlbnQgPSBudWxsXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsidXNlTWVyZ2VkUmVmIiwicmVmQSIsInJlZkIiLCJjbGVhbnVwQSIsInVzZVJlZiIsImNsZWFudXBCIiwidXNlTWVtbyIsImN1cnJlbnQiLCJhcHBseVJlZiIsImNsZWFudXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || '';\n    let pathname = urlObj.pathname || '';\n    let hash = urlObj.hash || '';\n    let query = urlObj.query || '';\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes'\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsU0FBUztlQUFUQTs7SUE2REFDLG9CQUFvQjtlQUFwQkE7O0lBZkhDLGFBQWE7ZUFBYkE7Ozs7bUZBbERnQjtBQUU3QixNQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBdUI7SUFFM0JOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBRXBFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNmQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzNCLE9BQU8sSUFBSUwsVUFBVTtRQUNuQkssT0FBT04sT0FBUSxFQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBUSxNQUFHUixXQUFTLE1BQUtBLFFBQUFBLENBQU87UUFDakUsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2ZKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUMzQjtJQUNGO0lBRUEsSUFBSUwsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDdENBLFFBQVFNLE9BQU9DLGFBQVlDLHNCQUFzQixDQUFDUjtJQUNwRDtJQUVBLElBQUlTLFNBQVNmLE9BQU9lLE1BQU0sSUFBS1QsU0FBVSxNQUFHQSxTQUFZO0lBRXhELElBQUlILFlBQVksQ0FBQ0EsU0FBU2EsUUFBUSxDQUFDLE1BQU1iLFlBQVk7SUFFckQsSUFDRUgsT0FBT2lCLE9BQU8sSUFDWixFQUFDZCxZQUFZSixpQkFBaUJtQixJQUFJLENBQUNmLFNBQUFBLENBQVEsSUFBTUksU0FBUyxPQUM1RDtRQUNBQSxPQUFPLE9BQVFBLENBQUFBLFFBQVEsR0FBQztRQUN4QixJQUFJSCxZQUFZQSxRQUFRLENBQUMsRUFBRSxLQUFLLEtBQUtBLFdBQVcsTUFBTUE7SUFDeEQsT0FBTyxJQUFJLENBQUNHLE1BQU07UUFDaEJBLE9BQU87SUFDVDtJQUVBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJVSxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFFaERYLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ08sU0FBU0EsT0FBT04sT0FBTyxDQUFDLEtBQUs7SUFFN0IsT0FBUSxLQUFFTixXQUFXSSxPQUFPSCxXQUFXVyxTQUFTVjtBQUNsRDtBQUVPLE1BQU1QLGdCQUFnQjtJQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVNLFNBQVNELHFCQUFxQnNCLEdBQWM7SUFDakQsSUFBSUMsSUFBb0IsRUFBb0I7UUFDMUMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUMzQ0ksT0FBT0MsSUFBSSxDQUFDTCxLQUFLTSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQzVCLGNBQWM2QixRQUFRLENBQUNELE1BQU07b0JBQ2hDRSxRQUFRQyxJQUFJLENBQ1QsdURBQW9ESDtnQkFFekQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPOUIsVUFBVXVCO0FBQ25CIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXHNyY1xcc2hhcmVkXFxsaWJcXHJvdXRlclxcdXRpbHNcXGZvcm1hdC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoJzonKSkgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCF1cmxPYmplY3RLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdFVybCIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsT2JqZWN0S2V5cyIsInNsYXNoZWRQcm90b2NvbHMiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsImVuZHNXaXRoIiwic2xhc2hlcyIsInRlc3QiLCJ1cmwiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === 'undefined') {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            ;\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n        return String(param);\n    } else {\n        return '';\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBNENnQkEsTUFBTTtlQUFOQTs7SUExQ0FDLHNCQUFzQjtlQUF0QkE7O0lBNEJBQyxzQkFBc0I7ZUFBdEJBOzs7QUE1QlQsU0FBU0QsdUJBQ2RFLFlBQTZCO0lBRTdCLE1BQU1DLFFBQXdCLENBQUM7SUFDL0JELGFBQWFFLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUMzQixJQUFJLE9BQU9ILEtBQUssQ0FBQ0csSUFBSSxLQUFLLGFBQWE7WUFDckNILEtBQUssQ0FBQ0csSUFBSSxHQUFHRDtRQUNmLE9BQU8sSUFBSUUsTUFBTUMsT0FBTyxDQUFDTCxLQUFLLENBQUNHLElBQUksR0FBRzs7WUFDbENILEtBQUssQ0FBQ0csSUFBSSxDQUFjRyxJQUFJLENBQUNKO1FBQ2pDLE9BQU87WUFDTEYsS0FBSyxDQUFDRyxJQUFJLEdBQUc7Z0JBQUNILEtBQUssQ0FBQ0csSUFBSTtnQkFBWUQ7YUFBTTtRQUM1QztJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNPLHVCQUF1QkMsS0FBYztJQUM1QyxJQUNFLE9BQU9BLFVBQVUsWUFDaEIsT0FBT0EsVUFBVSxZQUFZLENBQUNDLE1BQU1ELFVBQ3JDLE9BQU9BLFVBQVUsV0FDakI7UUFDQSxPQUFPRSxPQUFPRjtJQUNoQixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTVix1QkFDZGEsUUFBd0I7SUFFeEIsTUFBTUMsU0FBUyxJQUFJQztJQUNuQkMsT0FBT0MsT0FBTyxDQUFDSixVQUFVVixPQUFPLENBQUM7WUFBQyxDQUFDRSxLQUFLRCxNQUFNO1FBQzVDLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUTtZQUN4QkEsTUFBTUQsT0FBTyxDQUFDLENBQUNlLE9BQVNKLE9BQU9LLE1BQU0sQ0FBQ2QsS0FBS0ksdUJBQXVCUztRQUNwRSxPQUFPO1lBQ0xKLE9BQU9NLEdBQUcsQ0FBQ2YsS0FBS0ksdUJBQXVCTDtRQUN6QztJQUNGO0lBQ0EsT0FBT1U7QUFDVDtBQUVPLFNBQVNoQixPQUNkdUIsTUFBdUI7SUFDdkIsaUNBQUdDLG1CQUFIO1FBQUdBLGdCQUFBQSxDQUFILDJCQUFzQzs7SUFFdENBLGlCQUFpQm5CLE9BQU8sQ0FBQyxDQUFDRjtRQUN4QkssTUFBTWlCLElBQUksQ0FBQ3RCLGFBQWF1QixJQUFJLElBQUlyQixPQUFPLENBQUMsQ0FBQ0UsTUFBUWdCLE9BQU9JLE1BQU0sQ0FBQ3BCO1FBQy9ESixhQUFhRSxPQUFPLENBQUMsQ0FBQ0MsT0FBT0MsTUFBUWdCLE9BQU9GLE1BQU0sQ0FBQ2QsS0FBS0Q7SUFDMUQ7SUFDQSxPQUFPaUI7QUFDVCIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxzcmNcXHNoYXJlZFxcbGliXFxyb3V0ZXJcXHV0aWxzXFxxdWVyeXN0cmluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiB1bmtub3duKTogc3RyaW5nIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycgfHxcbiAgICAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocGFyYW0pKSB8fFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ2Jvb2xlYW4nXG4gICkge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW0pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMoXG4gIHVybFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIE9iamVjdC5lbnRyaWVzKHVybFF1ZXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHJlc3VsdC5hcHBlbmQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKGl0ZW0pKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnNldChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0odmFsdWUpKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKFxuICB0YXJnZXQ6IFVSTFNlYXJjaFBhcmFtcyxcbiAgLi4uc2VhcmNoUGFyYW1zTGlzdDogVVJMU2VhcmNoUGFyYW1zW11cbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIHNlYXJjaFBhcmFtc0xpc3QuZm9yRWFjaCgoc2VhcmNoUGFyYW1zKSA9PiB7XG4gICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpID0+IHRhcmdldC5kZWxldGUoa2V5KSlcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKSlcbiAgfSlcbiAgcmV0dXJuIHRhcmdldFxufVxuIl0sIm5hbWVzIjpbImFzc2lnbiIsInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInBhcmFtIiwiaXNOYU4iLCJTdHJpbmciLCJ1cmxRdWVyeSIsInJlc3VsdCIsIlVSTFNlYXJjaFBhcmFtcyIsIk9iamVjdCIsImVudHJpZXMiLCJpdGVtIiwiYXBwZW5kIiwic2V0IiwidGFyZ2V0Iiwic2VhcmNoUGFyYW1zTGlzdCIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    'CLS',\n    'FCP',\n    'FID',\n    'INP',\n    'LCP',\n    'TTFB'\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? ':' + port : '');\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split('?');\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? \"?\" + urlParts.slice(1).join('?') : '');\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== 'undefined';\nconst ST = SP && [\n    'mark',\n    'measure',\n    'getEntriesByName'\n].every((method)=>typeof performance[method] === 'function');\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = 'ENOENT';\n        this.name = 'PageNotFoundError';\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = 'ENOENT';\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvYWFBLFdBQVc7ZUFBWEE7O0lBb0JBQyx1QkFBdUI7ZUFBdkJBOztJQVBBQyxpQkFBaUI7ZUFBakJBOztJQVpBQyxjQUFjO2VBQWRBOztJQUNBQyxpQkFBaUI7ZUFBakJBOztJQVRBQyxFQUFFO2VBQUZBOztJQUNBQyxFQUFFO2VBQUZBOztJQWxYQUMsVUFBVTtlQUFWQTs7SUFzUUdDLFFBQVE7ZUFBUkE7O0lBK0JBQyxjQUFjO2VBQWRBOztJQVhBQyxpQkFBaUI7ZUFBakJBOztJQUtBQyxNQUFNO2VBQU5BOztJQVBIQyxhQUFhO2VBQWJBOztJQW1CR0MsU0FBUztlQUFUQTs7SUFrQk1DLG1CQUFtQjtlQUFuQkE7O0lBZE5DLHdCQUF3QjtlQUF4QkE7O0lBK0dBQyxjQUFjO2VBQWRBOzs7QUE5WlQsTUFBTVQsYUFBYTtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztDQUFPO0FBc1E5RCxTQUFTQyxTQUNkUyxFQUFLO0lBRUwsSUFBSUMsT0FBTztJQUNYLElBQUlDO0lBRUosT0FBUTt5Q0FBSUMsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsS0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O1FBQ1YsSUFBSSxDQUFDRixNQUFNO1lBQ1RBLE9BQU87WUFDUEMsU0FBU0YsTUFBTUc7UUFDakI7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSwwREFBMEQ7QUFDMUQsZ0VBQWdFO0FBQ2hFLE1BQU1FLHFCQUFxQjtBQUNwQixNQUFNVCxnQkFBZ0IsQ0FBQ1UsTUFBZ0JELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUUvRCxTQUFTWjtJQUNkLE1BQU0sRUFBRWMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRSxH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OUQsMEJBQTBCbUQ7SUFDckNVLFlBQVlDLElBQVksRUFBRVosT0FBZSxDQUFFO1FBQ3pDLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBSSwwQ0FBdUNZLE9BQUssTUFBR1o7SUFDakU7QUFDRjtBQUVPLE1BQU1uRCxnQ0FBZ0NvRDtJQUUzQ1UsYUFBYztRQUNaLEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2IsT0FBTyxHQUFJO0lBQ2xCO0FBQ0Y7QUFXTyxTQUFTcEMsZUFBZWtELEtBQVk7SUFDekMsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQUVoQixTQUFTYyxNQUFNZCxPQUFPO1FBQUVpQixPQUFPSCxNQUFNRyxLQUFLO0lBQUM7QUFDckUiLCJzb3VyY2VzIjpbIkU6XFxXcGlcXFJlZ3VsYXJseVxcQ291cnNlc1xcU3JcXDIwMjRfQ19UZXJtXFxzcmNcXHNoYXJlZFxcbGliXFx1dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEh0bWxQcm9wcyB9IGZyb20gJy4vaHRtbC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlLCBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgRG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB0eXBlIHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB0eXBlIHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB0eXBlIHsgUHJldmlld0RhdGEgfSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB0eXBlIHsgQ09NUElMRVJfTkFNRVMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB0eXBlIGZzIGZyb20gJ2ZzJ1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQ29udGV4dCBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJbml0aWFsUHJvcHMgPSB7fSxcbiAgUHJvcHMgPSB7fSxcbj4gPSBDb21wb25lbnRUeXBlPFByb3BzPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQ29udGV4dCk6IEluaXRpYWxQcm9wcyB8IFByb21pc2U8SW5pdGlhbFByb3BzPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPlxuXG5leHBvcnQgdHlwZSBBcHBUeXBlPFAgPSB7fT4gPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIFAsXG4gIEFwcFByb3BzVHlwZTxhbnksIFA+XG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFdFQl9WSVRBTFMgPSBbJ0NMUycsICdGQ1AnLCAnRklEJywgJ0lOUCcsICdMQ1AnLCAnVFRGQiddIGFzIGNvbnN0XG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbiAgYXR0cmlidXRpb24/OiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfVxufSAmIChcbiAgfCB7XG4gICAgICBsYWJlbDogJ3dlYi12aXRhbCdcbiAgICAgIG5hbWU6ICh0eXBlb2YgV0VCX1ZJVEFMUylbbnVtYmVyXVxuICAgIH1cbiAgfCB7XG4gICAgICBsYWJlbDogJ2N1c3RvbSdcbiAgICAgIG5hbWU6XG4gICAgICAgIHwgJ05leHQuanMtaHlkcmF0aW9uJ1xuICAgICAgICB8ICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInXG4gICAgICAgIHwgJ05leHQuanMtcmVuZGVyJ1xuICAgIH1cbilcblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBEb2N1bWVudEluaXRpYWxQcm9wcyB8IFByb21pc2U8RG9jdW1lbnRJbml0aWFsUHJvcHM+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgaXNFeHBlcmltZW50YWxDb21waWxlPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogKHN0cmluZyB8IG51bWJlcilbXVxuICBlcnI/OiBFcnJvciAmIHtcbiAgICBzdGF0dXNDb2RlPzogbnVtYmVyXG4gICAgc291cmNlPzogdHlwZW9mIENPTVBJTEVSX05BTUVTLnNlcnZlciB8IHR5cGVvZiBDT01QSUxFUl9OQU1FUy5lZGdlU2VydmVyXG4gIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZVtdXG4gIHNjcmlwdExvYWRlcj86IGFueVtdXG4gIGlzUHJldmlldz86IGJvb2xlYW5cbiAgbm90Rm91bmRTcmNQYWdlPzogc3RyaW5nXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBsb2NhbGVcbiAgICovXG4gIGxvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIGNvbmZpZ3VyZWQgbG9jYWxlc1xuICAgKi9cbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJlZCBkZWZhdWx0IGxvY2FsZVxuICAgKi9cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogYENvbXBvbmVudGAgdGhlIHRyZWUgb2YgdGhlIEFwcCB0byB1c2UgaWYgbmVlZGluZyB0byByZW5kZXIgc2VwYXJhdGVseVxuICAgKi9cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbn1cblxuZXhwb3J0IHR5cGUgQXBwQ29udGV4dFR5cGU8Um91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSb3V0ZXJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzPFBhZ2VQcm9wcyA9IGFueT4gPSB7XG4gIHBhZ2VQcm9wczogUGFnZVByb3BzXG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzVHlwZTxcbiAgUm91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFBhZ2VQcm9wcyA9IHt9LFxuPiA9IEFwcEluaXRpYWxQcm9wczxQYWdlUHJvcHM+ICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBhbnk+XG4gIHJvdXRlcjogUm91dGVyXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxuICBkZWZhdWx0R2V0SW5pdGlhbFByb3BzKFxuICAgIGN0eDogRG9jdW1lbnRDb250ZXh0LFxuICAgIG9wdGlvbnM/OiB7IG5vbmNlPzogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxEb2N1bWVudEluaXRpYWxQcm9wcz5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRJbml0aWFsUHJvcHMgPSBSZW5kZXJQYWdlUmVzdWx0ICYge1xuICBzdHlsZXM/OiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB8IEl0ZXJhYmxlPFJlYWN0LlJlYWN0Tm9kZT4gfCBKU1guRWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiBIdG1sUHJvcHNcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiBQYXJ0aWFsPHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9PlxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczogUGFydGlhbDx7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH0+XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBkcmFmdE1vZGU/OiBib29sZWFuXG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IFByZXZpZXdEYXRhXG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8RGF0YSA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPERhdGE+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8RGF0YT5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIFNldCBkcmFmdCBtb2RlXG4gICAqL1xuICBzZXREcmFmdE1vZGU6IChvcHRpb25zOiB7IGVuYWJsZTogYm9vbGVhbiB9KSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBwYXRoIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIHdvcmsgdW5kZXIuIEJ5IGRlZmF1bHQsXG4gICAgICAgKiB0aGUgcGF0aCBpcyBjb25zaWRlcmVkIHRoZSBcImRlZmF1bHQgcGF0aFwiLCBpLmUuLCBhbnkgcGFnZXMgdW5kZXIgXCIvXCIuXG4gICAgICAgKi9cbiAgICAgIHBhdGg/OiBzdHJpbmdcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIENsZWFyIHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIGNsZWFyUHJldmlld0RhdGE6IChvcHRpb25zPzogeyBwYXRoPzogc3RyaW5nIH0pID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBSZXZhbGlkYXRlIGEgc3BlY2lmaWMgcGFnZSBhbmQgcmVnZW5lcmF0ZSBpdCB1c2luZyBPbi1EZW1hbmQgSW5jcmVtZW50YWxcbiAgICogU3RhdGljIFJlZ2VuZXJhdGlvbi5cbiAgICogVGhlIHBhdGggc2hvdWxkIGJlIGFuIGFjdHVhbCBwYXRoLCBub3QgYSByZXdyaXR0ZW4gcGF0aC4gRS5nLiBmb3JcbiAgICogXCIvYmxvZy9bc2x1Z11cIiB0aGlzIHNob3VsZCBiZSBcIi9ibG9nL3Bvc3QtMVwiLlxuICAgKiBAbGluayBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL2luY3JlbWVudGFsLXN0YXRpYy1yZWdlbmVyYXRpb24jb24tZGVtYW5kLXJldmFsaWRhdGlvbi13aXRoLXJldmFsaWRhdGVwYXRoXG4gICAqL1xuICByZXZhbGlkYXRlOiAoXG4gICAgdXJsUGF0aDogc3RyaW5nLFxuICAgIG9wdHM/OiB7XG4gICAgICB1bnN0YWJsZV9vbmx5R2VuZXJhdGVkPzogYm9vbGVhblxuICAgIH1cbiAgKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB1bmtub3duIHwgUHJvbWlzZTx1bmtub3duPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi9cbmV4cG9ydCBjb25zdCBpc0Fic29sdXRlVXJsID0gKHVybDogc3RyaW5nKSA9PiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsOiBzdHJpbmcpIHtcbiAgY29uc3QgdXJsUGFydHMgPSB1cmwuc3BsaXQoJz8nKVxuICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF1cblxuICByZXR1cm4gKFxuICAgIHVybE5vUXVlcnlcbiAgICAgIC8vIGZpcnN0IHdlIHJlcGxhY2UgYW55IG5vbi1lbmNvZGVkIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZFxuICAgICAgLy8gdGhlbiBub3JtYWxpemUgcmVwZWF0ZWQgZm9yd2FyZCBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgICAucmVwbGFjZSgvXFwvXFwvKy9nLCAnLycpICtcbiAgICAodXJsUGFydHNbMV0gPyBgPyR7dXJsUGFydHMuc2xpY2UoMSkuam9pbignPycpfWAgOiAnJylcbiAgKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge30sXG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIChbJ21hcmsnLCAnbWVhc3VyZScsICdnZXRFbnRyaWVzQnlOYW1lJ10gYXMgY29uc3QpLmV2ZXJ5KFxuICAgIChtZXRob2QpID0+IHR5cGVvZiBwZXJmb3JtYW5jZVttZXRob2RdID09PSAnZnVuY3Rpb24nXG4gIClcblxuZXhwb3J0IGNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmV4cG9ydCBjbGFzcyBOb3JtYWxpemVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5leHBvcnQgY2xhc3MgUGFnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHBhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJ1xuICAgIHRoaXMubmFtZSA9ICdQYWdlTm90Rm91bmRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBgQ2Fubm90IGZpbmQgbW9kdWxlIGZvciBwYWdlOiAke3BhZ2V9YFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNaXNzaW5nU3RhdGljUGFnZSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGFnZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tZXNzYWdlID0gYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiAke3BhZ2V9ICR7bWVzc2FnZX1gXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBzdHJpbmdcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuY29kZSA9ICdFTk9FTlQnXG4gICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIHRoZSBtaWRkbGV3YXJlIG1vZHVsZWBcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlRnMge1xuICBleGlzdHNTeW5jOiB0eXBlb2YgZnMuZXhpc3RzU3luY1xuICByZWFkRmlsZTogdHlwZW9mIGZzLnByb21pc2VzLnJlYWRGaWxlXG4gIHJlYWRGaWxlU3luYzogdHlwZW9mIGZzLnJlYWRGaWxlU3luY1xuICB3cml0ZUZpbGUoZjogc3RyaW5nLCBkOiBhbnkpOiBQcm9taXNlPHZvaWQ+XG4gIG1rZGlyKGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkIHwgc3RyaW5nPlxuICBzdGF0KGY6IHN0cmluZyk6IFByb21pc2U8eyBtdGltZTogRGF0ZSB9PlxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjayB9KVxufVxuIl0sIm5hbWVzIjpbIkRlY29kZUVycm9yIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJTUCIsIlNUIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImlzQWJzb2x1dGVVcmwiLCJpc1Jlc1NlbnQiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsIkFwcCIsImN0eCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIm1lc3NhZ2UiLCJFcnJvciIsInBhZ2VQcm9wcyIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsImNvbnN0cnVjdG9yIiwicGFnZSIsImNvZGUiLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/SolveDen.js":
/*!*************************************!*\
  !*** ./src/app/dataVis/SolveDen.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveDensity)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\nfunction SolveDensity(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [detail, setDetail] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(20); // Controls bandwidth\n    const [trim, setTrim] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0); // Controls x-axis range trim\n    const [densityData, setDensityData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveDensity.useEffect\": ()=>{\n            if (solves.length > 0) {\n                const times = solves.map({\n                    \"SolveDensity.useEffect.times\": (solve)=>solve.time / 1000\n                }[\"SolveDensity.useEffect.times\"]).sort({\n                    \"SolveDensity.useEffect.times\": (a, b)=>a - b\n                }[\"SolveDensity.useEffect.times\"]);\n                const bandwidth = (d3.max(times) - d3.min(times)) / detail * 1.2; // Slightly increased smoothing\n                const computedDensityData = kde(times, bandwidth);\n                setDensityData(computedDensityData);\n                drawSolveDensity(solves, computedDensityData);\n                window.addEventListener('resize', handleResize);\n            }\n            return ({\n                \"SolveDensity.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveDensity.useEffect\"];\n        }\n    }[\"SolveDensity.useEffect\"], [\n        solves,\n        detail,\n        trim\n    ]);\n    function handleResize() {\n        if (containerRef.current) {\n            drawSolveDensity(solves);\n        }\n    }\n    function drawSolveDensity(data) {\n        if (!containerRef.current) return; // Ensure containerRef is available\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove(); // Clear previous SVG\n        // Get dynamic width and height\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        const times = data.map((solve)=>solve.time / 1000).sort((a, b)=>a - b);\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        const bandwidth = (d3.max(times) - d3.min(times)) / detail;\n        const densityData = kde(times, bandwidth);\n        const densityAo5 = kde(ao5.filter((d)=>d !== null), bandwidth);\n        const densityAo12 = kde(ao12.filter((d)=>d !== null), bandwidth);\n        const xDomain = d3.extent(densityData, (d)=>d[0]);\n        const maxTrim = xDomain[1] - xDomain[0] - 1;\n        const adjustedTrim = Math.min(trim, maxTrim);\n        const trimmedDomain = [\n            xDomain[0],\n            xDomain[1] - adjustedTrim\n        ];\n        const xScale = d3.scaleLinear().domain(trimmedDomain).range([\n            50,\n            width - 50\n        ]);\n        const yScale = d3.scaleLinear().domain([\n            0,\n            d3.max([\n                ...densityData,\n                ...densityAo5,\n                ...densityAo12\n            ], (d)=>d[1])\n        ]).range([\n            height - 50,\n            50\n        ]);\n        const area = d3.area().curve(d3.curveBasis) // Apply smoothing\n        .x((d)=>xScale(d[0])).y0(height - 50).y1((d)=>yScale(d[1]));\n        const line = d3.line().curve(d3.curveBasis) // Smooths the line\n        .x((d)=>xScale(d[0])).y((d)=>yScale(d[1]));\n        svg.append('path').datum(densityData).attr('d', area).attr('fill', 'steelblue').attr('opacity', 0.5);\n        svg.append('path').datum(densityData).attr('d', line).attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(densityAo5).attr('d', area).attr('fill', 'green').attr('opacity', 0.5);\n        svg.append('path').datum(densityAo5).attr('d', line).attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(densityAo12).attr('d', area).attr('fill', 'red').attr('opacity', 0.5);\n        svg.append('path').datum(densityAo12).attr('d', line).attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('text').attr('x', width / 2).attr('y', 20).attr('text-anchor', 'middle');\n        // .text('Solve Time Density');\n        svg.append('g').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale));\n        // Compute percentiles\n        const computePercentiles = (data)=>[\n                0.25,\n                0.50,\n                0.75\n            ].map((p)=>{\n                const index = Math.floor(p * data.length);\n                return data[index];\n            });\n        const percentilesSingle = computePercentiles(times);\n        const percentilesAo5 = computePercentiles(ao5.filter((d)=>d !== null));\n        const percentilesAo12 = computePercentiles(ao12.filter((d)=>d !== null));\n        // Draw dashed lines for all density plots\n        const drawDashedLines = (percentiles, density, strokeColor)=>{\n            percentiles.forEach((value)=>{\n                var _density_find;\n                const yMax = yScale(((_density_find = density.find((d)=>d[0] >= value)) === null || _density_find === void 0 ? void 0 : _density_find[1]) || 0);\n                svg.append('line').attr('x1', xScale(value)).attr('x2', xScale(value)).attr('y1', height - 50).attr('y2', yMax).attr('stroke', strokeColor).attr('stroke-dasharray', '4,2');\n            });\n        };\n        drawDashedLines(percentilesSingle, densityData, 'blue');\n        drawDashedLines(percentilesAo5, densityAo5, 'green');\n        drawDashedLines(percentilesAo12, densityAo12, 'red');\n        // Add legend\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 100)\"));\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color).attr('opacity', 0.5);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n    }\n    function computeRollingAverage(data, windowSize) {\n        return data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null;\n            const subset = arr.slice(i - windowSize + 1, i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n    }\n    function kde(data, bandwidth) {\n        const kernel = (u)=>Math.exp(-0.5 * u * u) / Math.sqrt(2 * Math.PI);\n        const kernelDensityEstimator = (kernel, bandwidth, data)=>{\n            const xMin = d3.min(data) - bandwidth * 3;\n            const xMax = d3.max(data) + bandwidth * 3;\n            const xValues = d3.range(xMin, xMax, (xMax - xMin) / 300); // Increased points\n            return xValues.map((x)=>{\n                return [\n                    x,\n                    d3.mean(data, (v)=>kernel((x - v) / bandwidth)) / bandwidth\n                ];\n            });\n        };\n        return kernelDensityEstimator(kernel, bandwidth, data);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: containerRef,\n                className: \"w-full h-full\"\n            }, void 0, false, {\n                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n                lineNumber: 169,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-2 right-2 bg-white p-2 rounded shadow flex space-x-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"flex flex-col items-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Detail\"\n                            }, void 0, false, {\n                                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n                                lineNumber: 174,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"range\",\n                                min: \"5\",\n                                max: \"50\",\n                                value: detail,\n                                onChange: (e)=>setDetail(Number(e.target.value))\n                            }, void 0, false, {\n                                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n                                lineNumber: 175,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n                        lineNumber: 173,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"flex flex-col items-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Trim\"\n                            }, void 0, false, {\n                                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n                                lineNumber: 184,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"range\",\n                                min: \"0\",\n                                max: densityData.length > 0 ? Math.max(1, Math.floor(d3.max(densityData, (d)=>d[0]) - d3.min(densityData, (d)=>d[0]))) : 1,\n                                step: \"1\",\n                                value: trim,\n                                onChange: (e)=>setTrim(Math.min(Number(e.target.value), Math.floor(d3.max(densityData, (d)=>d[0]) - d3.min(densityData, (d)=>d[0]))))\n                            }, void 0, false, {\n                                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n                                lineNumber: 185,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n                        lineNumber: 183,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n                lineNumber: 172,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\SolveDen.js\",\n        lineNumber: 168,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveDensity, \"1uNbZk50LzmMRxT9VL1dHAsEZcE=\");\n_c = SolveDensity;\nvar _c;\n$RefreshReg$(_c, \"SolveDensity\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9Tb2x2ZURlbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRW9EO0FBQ3BELE1BQU1HLEtBQUssTUFBTSw0TUFBWTtBQUVkLFNBQVNDLGFBQWEsS0FBVTtRQUFWLEVBQUVDLE1BQU0sRUFBRSxHQUFWOztJQUNqQyxNQUFNQyxlQUFlTCw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNLENBQUNNLFFBQVFDLFVBQVUsR0FBR04sK0NBQVFBLENBQUMsS0FBTSxxQkFBcUI7SUFDaEUsTUFBTSxDQUFDTyxNQUFNQyxRQUFRLEdBQUdSLCtDQUFRQSxDQUFDLElBQUssNkJBQTZCO0lBQ25FLE1BQU0sQ0FBQ1MsYUFBYUMsZUFBZSxHQUFHViwrQ0FBUUEsQ0FBQyxFQUFFO0lBRWpERixnREFBU0E7a0NBQUM7WUFDTixJQUFJSyxPQUFPUSxNQUFNLEdBQUcsR0FBRztnQkFDbkIsTUFBTUMsUUFBUVQsT0FBT1UsR0FBRztvREFBQyxDQUFDQyxRQUFVQSxNQUFNQyxJQUFJLEdBQUc7bURBQU1DLElBQUk7b0RBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUM7O2dCQUMxRSxNQUFNQyxZQUFZLENBQUVsQixHQUFHbUIsR0FBRyxDQUFDUixTQUFTWCxHQUFHb0IsR0FBRyxDQUFDVCxNQUFLLElBQUtQLFNBQVUsS0FBSywrQkFBK0I7Z0JBQ25HLE1BQU1pQixzQkFBc0JDLElBQUlYLE9BQU9PO2dCQUN2Q1QsZUFBZVk7Z0JBRWZFLGlCQUFpQnJCLFFBQVFtQjtnQkFDekJHLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVDO1lBQ3RDO1lBQ0E7MENBQU8sSUFBTUYsT0FBT0csbUJBQW1CLENBQUMsVUFBVUQ7O1FBQ3REO2lDQUFHO1FBQUN4QjtRQUFRRTtRQUFRRTtLQUFLO0lBRXpCLFNBQVNvQjtRQUNMLElBQUl2QixhQUFheUIsT0FBTyxFQUFFO1lBQ3RCTCxpQkFBaUJyQjtRQUNyQjtJQUNKO0lBRUEsU0FBU3FCLGlCQUFp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QUFDLENBQUMsRUFBRSxJQUFJOUMsR0FBR29CLEdBQUcsQ0FBQ1osYUFBYXNDLENBQUFBLElBQUtBLENBQUMsQ0FBQyxFQUFFLE1BQ3JGO2dDQUNOMkUsTUFBSztnQ0FDTHZDLE9BQU81RTtnQ0FDUCtHLFVBQVUsQ0FBQ0MsSUFBTS9HLFFBQVE2QyxLQUFLaEMsR0FBRyxDQUFDbUcsT0FBT0QsRUFBRUUsTUFBTSxDQUFDdEMsS0FBSyxHQUFHOUIsS0FBS3FCLEtBQUssQ0FBQ3pFLEdBQUdtQixHQUFHLENBQUNYLGFBQWFzQyxDQUFBQSxJQUFLQSxDQUFDLENBQUMsRUFBRSxJQUFJOUMsR0FBR29CLEdBQUcsQ0FBQ1osYUFBYXNDLENBQUFBLElBQUtBLENBQUMsQ0FBQyxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNM0o7R0FqTXdCN0M7S0FBQUEiLCJzb3VyY2VzIjpbIkU6XFxXcGlcXFJlZ3VsYXJseVxcQ291cnNlc1xcU3JcXDIwMjRfQ19UZXJtXFxDUzQyNDFcXEhXXFxmaW5hbC1wcm9qZWN0LWtlcm1pdC10aGUtZnJvZ1xcc3JjXFxhcHBcXGRhdGFWaXNcXFNvbHZlRGVuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuY29uc3QgZDMgPSBhd2FpdCBpbXBvcnQoJ2QzJyk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTb2x2ZURlbnNpdHkoeyBzb2x2ZXMgfSkge1xyXG4gICAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3QgW2RldGFpbCwgc2V0RGV0YWlsXSA9IHVzZVN0YXRlKDIwKTsgIC8vIENvbnRyb2xzIGJhbmR3aWR0aFxyXG4gICAgY29uc3QgW3RyaW0sIHNldFRyaW1dID0gdXNlU3RhdGUoMCk7ICAvLyBDb250cm9scyB4LWF4aXMgcmFuZ2UgdHJpbVxyXG4gICAgY29uc3QgW2RlbnNpdHlEYXRhLCBzZXREZW5zaXR5RGF0YV0gPSB1c2VTdGF0ZShbXSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc29sdmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgdGltZXMgPSBzb2x2ZXMubWFwKChzb2x2ZSkgPT4gc29sdmUudGltZSAvIDEwMDApLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICAgICAgICAgICAgY29uc3QgYmFuZHdpZHRoID0gKChkMy5tYXgodGltZXMpIC0gZDMubWluKHRpbWVzKSkgLyBkZXRhaWwpICogMS4yOyAvLyBTbGlnaHRseSBpbmNyZWFzZWQgc21vb3RoaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkRGVuc2l0eURhdGEgPSBrZGUodGltZXMsIGJhbmR3aWR0aCk7XHJcbiAgICAgICAgICAgIHNldERlbnNpdHlEYXRhKGNvbXB1dGVkRGVuc2l0eURhdGEpO1xyXG5cclxuICAgICAgICAgICAgZHJhd1NvbHZlRGVuc2l0eShzb2x2ZXMsIGNvbXB1dGVkRGVuc2l0eURhdGEpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgfSwgW3NvbHZlcywgZGV0YWlsLCB0cmltXSk7XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBkcmF3U29sdmVEZW5zaXR5KHNvbHZlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdTb2x2ZURlbnNpdHkoZGF0YSkge1xyXG4gICAgICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjsgLy8gRW5zdXJlIGNvbnRhaW5lclJlZiBpcyBhdmFpbGFibGVcclxuXHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KTtcclxuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7IC8vIENsZWFyIHByZXZpb3VzIFNWR1xyXG5cclxuICAgICAgICAvLyBHZXQgZHluYW1pYyB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0IHx8IDUwMDtcclxuXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gY29udGFpbmVyLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgJzEwMCUnKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgJzEwMCUnKVxyXG4gICAgICAgICAgICAuYXR0cigndmlld0JveCcsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YClcclxuICAgICAgICAgICAgLmF0dHIoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xyXG5cclxuICAgICAgICBjb25zdCB0aW1lcyA9IGRhdGEubWFwKChzb2x2ZSkgPT4gc29sdmUudGltZSAvIDEwMDApLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICAgICAgICBjb25zdCBhbzUgPSBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UodGltZXMsIDUpO1xyXG4gICAgICAgIGNvbnN0IGFvMTIgPSBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UodGltZXMsIDEyKTtcclxuICAgICAgICBjb25zdCBiYW5kd2lkdGggPSAoZDMubWF4KHRpbWVzKSAtIGQzLm1pbih0aW1lcykpIC8gZGV0YWlsO1xyXG5cclxuICAgICAgICBjb25zdCBkZW5zaXR5RGF0YSA9IGtkZSh0aW1lcywgYmFuZHdpZHRoKTtcclxuICAgICAgICBjb25zdCBkZW5zaXR5QW81ID0ga2RlKGFvNS5maWx0ZXIoZCA9PiBkICE9PSBudWxsKSwgYmFuZHdpZHRoKTtcclxuICAgICAgICBjb25zdCBkZW5zaXR5QW8xMiA9IGtkZShhbzEyLmZpbHRlcihkID0+IGQgIT09IG51bGwpLCBiYW5kd2lkdGgpO1xyXG5cclxuICAgICAgICBjb25zdCB4RG9tYWluID0gZDMuZXh0ZW50KGRlbnNpdHlEYXRhLCBkID0+IGRbMF0pO1xyXG4gICAgICAgIGNvbnN0IG1heFRyaW0gPSB4RG9tYWluWzFdIC0geERvbWFpblswXSAtIDE7XHJcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRUcmltID0gTWF0aC5taW4odHJpbSwgbWF4VHJpbSk7XHJcbiAgICAgICAgY29uc3QgdHJpbW1lZERvbWFpbiA9IFt4RG9tYWluWzBdLCB4RG9tYWluWzFdIC0gYWRqdXN0ZWRUcmltXTtcclxuICAgICAgICBjb25zdCB4U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbih0cmltbWVkRG9tYWluKS5yYW5nZShbNTAsIHdpZHRoIC0gNTBdKTtcclxuICAgICAgICBjb25zdCB5U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbMCwgZDMubWF4KFsuLi5kZW5zaXR5RGF0YSwgLi4uZGVuc2l0eUFvNSwgLi4uZGVuc2l0eUFvMTJdLCBkID0+IGRbMV0pXSkucmFuZ2UoW2hlaWdodCAtIDUwLCA1MF0pO1xyXG5cclxuICAgICAgICBjb25zdCBhcmVhID0gZDMuYXJlYSgpXHJcbiAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKSAvLyBBcHBseSBzbW9vdGhpbmdcclxuICAgICAgICAgICAgLngoZCA9PiB4U2NhbGUoZFswXSkpXHJcbiAgICAgICAgICAgIC55MChoZWlnaHQgLSA1MClcclxuICAgICAgICAgICAgLnkxKGQgPT4geVNjYWxlKGRbMV0pKTtcclxuICAgICAgICBjb25zdCBsaW5lID0gZDMubGluZSgpXHJcbiAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKSAvLyBTbW9vdGhzIHRoZSBsaW5lXHJcbiAgICAgICAgICAgIC54KGQgPT4geFNjYWxlKGRbMF0pKVxyXG4gICAgICAgICAgICAueShkID0+IHlTY2FsZShkWzFdKSk7XHJcblxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKS5kYXR1bShkZW5zaXR5RGF0YSkuYXR0cignZCcsIGFyZWEpLmF0dHIoJ2ZpbGwnLCAnc3RlZWxibHVlJykuYXR0cignb3BhY2l0eScsIDAuNSk7XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpLmRhdHVtKGRlbnNpdHlEYXRhKS5hdHRyKCdkJywgbGluZSkuYXR0cignc3Ryb2tlJywgJ2JsdWUnKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpLmRhdHVtKGRlbnNpdHlBbzUpLmF0dHIoJ2QnLCBhcmVhKS5hdHRyKCdmaWxsJywgJ2dyZWVuJykuYXR0cignb3BhY2l0eScsIDAuNSk7XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpLmRhdHVtKGRlbnNpdHlBbzUpLmF0dHIoJ2QnLCBsaW5lKS5hdHRyKCdzdHJva2UnLCAnZ3JlZW4nKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpLmRhdHVtKGRlbnNpdHlBbzEyKS5hdHRyKCdkJywgYXJlYSkuYXR0cignZmlsbCcsICdyZWQnKS5hdHRyKCdvcGFjaXR5JywgMC41KTtcclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJykuZGF0dW0oZGVuc2l0eUFvMTIpLmF0dHIoJ2QnLCBsaW5lKS5hdHRyKCdzdHJva2UnLCAncmVkJykuYXR0cignZmlsbCcsICdub25lJykuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XHJcblxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAyMClcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xyXG4gICAgICAgIC8vIC50ZXh0KCdTb2x2ZSBUaW1lIERlbnNpdHknKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtoZWlnaHQgLSA1MH0pYCkuY2FsbChkMy5heGlzQm90dG9tKHhTY2FsZSkpO1xyXG5cclxuICAgICAgICAvLyBDb21wdXRlIHBlcmNlbnRpbGVzXHJcbiAgICAgICAgY29uc3QgY29tcHV0ZVBlcmNlbnRpbGVzID0gKGRhdGEpID0+IFswLjI1LCAwLjUwLCAwLjc1XS5tYXAocCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihwICogZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YVtpbmRleF07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBlcmNlbnRpbGVzU2luZ2xlID0gY29tcHV0ZVBlcmNlbnRpbGVzKHRpbWVzKTtcclxuICAgICAgICBjb25zdCBwZXJjZW50aWxlc0FvNSA9IGNvbXB1dGVQZXJjZW50aWxlcyhhbzUuZmlsdGVyKGQgPT4gZCAhPT0gbnVsbCkpO1xyXG4gICAgICAgIGNvbnN0IHBlcmNlbnRpbGVzQW8xMiA9IGNvbXB1dGVQZXJjZW50aWxlcyhhbzEyLmZpbHRlcihkID0+IGQgIT09IG51bGwpKTtcclxuXHJcbiAgICAgICAgLy8gRHJhdyBkYXNoZWQgbGluZXMgZm9yIGFsbCBkZW5zaXR5IHBsb3RzXHJcbiAgICAgICAgY29uc3QgZHJhd0Rhc2hlZExpbmVzID0gKHBlcmNlbnRpbGVzLCBkZW5zaXR5LCBzdHJva2VDb2xvcikgPT4ge1xyXG4gICAgICAgICAgICBwZXJjZW50aWxlcy5mb3JFYWNoKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHlNYXggPSB5U2NhbGUoZGVuc2l0eS5maW5kKGQgPT4gZFswXSA+PSB2YWx1ZSk/LlsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdmcuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4U2NhbGUodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHhTY2FsZSh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgaGVpZ2h0IC0gNTApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeU1heClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgc3Ryb2tlQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAnNCwyJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGRyYXdEYXNoZWRMaW5lcyhwZXJjZW50aWxlc1NpbmdsZSwgZGVuc2l0eURhdGEsICdibHVlJyk7XHJcbiAgICAgICAgZHJhd0Rhc2hlZExpbmVzKHBlcmNlbnRpbGVzQW81LCBkZW5zaXR5QW81LCAnZ3JlZW4nKTtcclxuICAgICAgICBkcmF3RGFzaGVkTGluZXMocGVyY2VudGlsZXNBbzEyLCBkZW5zaXR5QW8xMiwgJ3JlZCcpO1xyXG5cclxuICAgICAgICAvLyBBZGQgbGVnZW5kXHJcbiAgICAgICAgY29uc3QgbGVnZW5kID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt3aWR0aCAtIDEyMH0sIDEwMClgKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbXMgPSBbXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdibHVlJywgbGFiZWw6ICdTaW5nbGUnIH0sXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdncmVlbicsIGxhYmVsOiAnQU81JyB9LFxyXG4gICAgICAgICAgICB7IGNvbG9yOiAncmVkJywgbGFiZWw6ICdBTzEyJyB9XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgbGVnZW5kSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZWdlbmQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaSAqIDIwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGl0ZW0uY29sb3IpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDAuNSk7XHJcblxyXG4gICAgICAgICAgICBsZWdlbmQuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMjApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGkgKiAyMCArIDEyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgICAgICAgICAgICAgIC50ZXh0KGl0ZW0ubGFiZWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVSb2xsaW5nQXZlcmFnZShkYXRhLCB3aW5kb3dTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChfLCBpLCBhcnIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGkgPCB3aW5kb3dTaXplIC0gMSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnNldCA9IGFyci5zbGljZShpIC0gd2luZG93U2l6ZSArIDEsIGkgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnNldC5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gc3Vic2V0Lmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZGUoZGF0YSwgYmFuZHdpZHRoKSB7XHJcbiAgICAgICAgY29uc3Qga2VybmVsID0gKHUpID0+IE1hdGguZXhwKC0wLjUgKiB1ICogdSkgLyBNYXRoLnNxcnQoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIGNvbnN0IGtlcm5lbERlbnNpdHlFc3RpbWF0b3IgPSAoa2VybmVsLCBiYW5kd2lkdGgsIGRhdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeE1pbiA9IGQzLm1pbihkYXRhKSAtIGJhbmR3aWR0aCAqIDM7XHJcbiAgICAgICAgICAgIGNvbnN0IHhNYXggPSBkMy5tYXgoZGF0YSkgKyBiYW5kd2lkdGggKiAzO1xyXG4gICAgICAgICAgICBjb25zdCB4VmFsdWVzID0gZDMucmFuZ2UoeE1pbiwgeE1heCwgKHhNYXggLSB4TWluKSAvIDMwMCk7IC8vIEluY3JlYXNlZCBwb2ludHNcclxuICAgICAgICAgICAgcmV0dXJuIHhWYWx1ZXMubWFwKCh4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIGQzLm1lYW4oZGF0YSwgKHYpID0+IGtlcm5lbCgoeCAtIHYpIC8gYmFuZHdpZHRoKSkgLyBiYW5kd2lkdGhdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBrZXJuZWxEZW5zaXR5RXN0aW1hdG9yKGtlcm5lbCwgYmFuZHdpZHRoLCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC1bY2FsYygxMDB2aC0xMDBweCldIGJnLXdoaXRlIHJlbGF0aXZlXCI+XHJcbiAgICAgICAgICAgIDxkaXYgcmVmPXtjb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIj48L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIHsvKiBTbGlkZXJzIGZvciBEZXRhaWwgYW5kIFRyaW0gKi99XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTIgcmlnaHQtMiBiZy13aGl0ZSBwLTIgcm91bmRlZCBzaGFkb3cgZmxleCBzcGFjZS14LTRcIj5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPkRldGFpbDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluPVwiNVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heD1cIjUwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2RldGFpbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXREZXRhaWwoTnVtYmVyKGUudGFyZ2V0LnZhbHVlKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj5UcmltPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFuZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW49XCIwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4PXtkZW5zaXR5RGF0YS5sZW5ndGggPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZDMubWF4KGRlbnNpdHlEYXRhLCBkID0+IGRbMF0pIC0gZDMubWluKGRlbnNpdHlEYXRhLCBkID0+IGRbMF0pKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcD1cIjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dHJpbX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRUcmltKE1hdGgubWluKE51bWJlcihlLnRhcmdldC52YWx1ZSksIE1hdGguZmxvb3IoZDMubWF4KGRlbnNpdHlEYXRhLCBkID0+IGRbMF0pIC0gZDMubWluKGRlbnNpdHlEYXRhLCBkID0+IGRbMF0pKSkpfVxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJkMyIsIlNvbHZlRGVuc2l0eSIsInNvbHZlcyIsImNvbnRhaW5lclJlZiIsImRldGFpbCIsInNldERldGFpbCIsInRyaW0iLCJzZXRUcmltIiwiZGVuc2l0eURhdGEiLCJzZXREZW5zaXR5RGF0YSIsImxlbmd0aCIsInRpbWVzIiwibWFwIiwic29sdmUiLCJ0aW1lIiwic29ydCIsImEiLCJiIiwiYmFuZHdpZHRoIiwibWF4IiwibWluIiwiY29tcHV0ZWREZW5zaXR5RGF0YSIsImtkZSIsImRyYXdTb2x2ZURlbnNpdHkiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlUmVzaXplIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImN1cnJlbnQiLCJkYXRhIiwiY29udGFpbmVyIiwic2VsZWN0Iiwic2VsZWN0QWxsIiwicmVtb3ZlIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsInN2ZyIsImFwcGVuZCIsImF0dHIiLCJhbzUiLCJjb21wdXRlUm9sbGluZ0F2ZXJhZ2UiLCJhbzEyIiwiZGVuc2l0eUFvNSIsImZpbHRlciIsImQiLCJkZW5zaXR5QW8xMiIsInhEb21haW4iLCJleHRlbnQiLCJtYXhUcmltIiwiYWRqdXN0ZWRUcmltIiwiTWF0aCIsInRyaW1tZWREb21haW4iLCJ4U2NhbGUiLCJzY2FsZUxpbmVhciIsImRvbWFpbiIsInJhbmdlIiwieVNjYWxlIiwiYXJlYSIsImN1cnZlIiwiY3VydmVCYXNpcyIsIngiLCJ5MCIsInkxIiwibGluZSIsInkiLCJkYXR1bSIsImNhbGwiLCJheGlzQm90dG9tIiwiY29tcHV0ZVBlcmNlbnRpbGVzIiwicCIsImluZGV4IiwiZmxvb3IiLCJwZXJjZW50aWxlc1NpbmdsZSIsInBlcmNlbnRpbGVzQW81IiwicGVyY2VudGlsZXNBbzEyIiwiZHJhd0Rhc2hlZExpbmVzIiwicGVyY2VudGlsZXMiLCJkZW5zaXR5Iiwic3Ryb2tlQ29sb3IiLCJmb3JFYWNoIiwidmFsdWUiLCJ5TWF4IiwiZmluZCIsImxlZ2VuZCIsImxlZ2VuZEl0ZW1zIiwiY29sb3IiLCJsYWJlbCIsIml0ZW0iLCJpIiwidGV4dCIsIndpbmRvd1NpemUiLCJfIiwiYXJyIiwic3Vic2V0Iiwic2xpY2UiLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJrZXJuZWwiLCJ1IiwiZXhwIiwic3FydCIsIlBJIiwia2VybmVsRGVuc2l0eUVzdGltYXRvciIsInhNaW4iLCJ4TWF4IiwieFZhbHVlcyIsIm1lYW4iLCJ2IiwiZGl2IiwiY2xhc3NOYW1lIiwicmVmIiwic3BhbiIsImlucHV0IiwidHlwZSIsIm9uQ2hhbmdlIiwiZSIsIk51bWJlciIsInRhcmdldCIsInN0ZXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/SolveDen.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TimeDis.js":
/*!************************************!*\
  !*** ./src/app/dataVis/TimeDis.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeDistribution)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\nfunction SolveTimeDistribution(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeDistribution.useEffect\": ()=>{\n            if (containerRef.current && solves.length > 0) {\n                drawSolveTimeDistribution(solves);\n                window.addEventListener('resize', handleResize);\n            }\n            return ({\n                \"SolveTimeDistribution.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeDistribution.useEffect\"];\n        }\n    }[\"SolveTimeDistribution.useEffect\"], [\n        solves\n    ]);\n    function handleResize() {\n        if (containerRef.current) {\n            drawSolveTimeDistribution(solves);\n        }\n    }\n    function drawSolveTimeDistribution(data) {\n        if (!containerRef.current) return;\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth;\n        const height = containerRef.current.clientHeight;\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        const times = data.map((solve)=>solve.time / 1000);\n        const minData = Math.floor(d3.min(times) * 2) / 2;\n        const maxData = Math.ceil(d3.max(times) * 2) / 2;\n        const xScale = d3.scaleLinear().domain([\n            minData,\n            maxData\n        ]).range([\n            50,\n            width - 50\n        ]);\n        const histogram = d3.histogram().domain(xScale.domain()).thresholds(d3.range(minData, maxData, 0.5));\n        const bins = histogram(times);\n        const maxBinCount = d3.max(bins, (d)=>d.length);\n        const yScale = d3.scaleLinear().domain([\n            0,\n            maxBinCount\n        ]).range([\n            height - 50,\n            50\n        ]);\n        // âœ… Draw horizontal grid lines at every integer value (1, 2, 3, ..., maxBinCount)\n        function drawGrid() {\n            svg.append('g').attr('class', 'grid').selectAll('line').data(d3.range(1, maxBinCount + 1, 1)) // âœ… Every integer from 1 to maxBinCount\n            .enter().append('line').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4'); // Dashed lines for better visibility\n        }\n        drawGrid(); // âœ… Call grid function after setting the y-axis\n        svg.selectAll('rect').data(bins).enter().append('rect').attr('x', (d)=>xScale(d.x0)).attr('y', (d)=>yScale(d.length)).attr('width', (d)=>xScale(d.x1) - xScale(d.x0) - 1).attr('height', (d)=>height - 50 - yScale(d.length)).attr('fill', 'steelblue');\n        svg.append('text').attr('x', width / 2).attr('y', 20).attr('text-anchor', 'middle');\n        // .text('Solve Time Distribution');\n        svg.append('g').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale).tickValues(d3.range(minData, maxData + 0.5, 0.5)));\n        svg.append('g').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"bg-white w-screen h-[calc(100vh-100px)]\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TimeDis.js\",\n        lineNumber: 92,\n        columnNumber: 12\n    }, this);\n}\n_s(SolveTimeDistribution, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = SolveTimeDistribution;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeDistribution\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UaW1lRGlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFMEM7QUFDMUMsTUFBTUUsS0FBSyxNQUFNLDRNQUFZO0FBRWQsU0FBU0Msc0JBQXNCLEtBQVU7UUFBVixFQUFFQyxNQUFNLEVBQUUsR0FBVjs7SUFDMUMsTUFBTUMsZUFBZUosNkNBQU1BLENBQUM7SUFFNUJELGdEQUFTQTsyQ0FBQztZQUNOLElBQUlLLGFBQWFDLE9BQU8sSUFBSUYsT0FBT0csTUFBTSxHQUFHLEdBQUc7Z0JBQzNDQywwQkFBMEJKO2dCQUMxQkssT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUM7WUFDdEM7WUFFQTttREFBTyxJQUFNRixPQUFPRyxtQkFBbUIsQ0FBQyxVQUFVRDs7UUFDdEQ7MENBQUc7UUFBQ1A7S0FBTztJQUVYLFNBQVNPO1FBQ0wsSUFBSU4sYUFBYUMsT0FBTyxFQUFFO1lBQ3RCRSwwQkFBMEJKO1FBQzlCO0lBQ0o7SUFFQSxTQUFTSSwwQkFBMEJLLElBQUk7UUFDbkMsSUFBSSxDQUFDUixhQUFhQyxPQUFPLEVBQUU7UUFFM0IsTUFBTVEsWUFBWVosR0FBR2EsTUFBTSxDQUFDVixhQUFhQyxPQUFPO1FBQ2hEUSxVQUFVRSxTQUFTLENBQUMsS0FBS0MsTUFBTTtRQUUvQixNQUFNQyxRQUFRYixhQUFhQyxPQUFPLENBQUNhLFdBQVc7UUFDOUMsTUFBTUMsU0FBU2YsYUFBYUMsT0FBTyxDQUFDZSxZQUFZO1FBRWhELE1BQU1DLE1BQU1SLFVBQVVTLE1BQU0sQ0FBQyxPQUN4QkMsSUFBSSxDQUFDLFNBQVMsUUFDZEEsSUFBSSxDQUFDLFVBQVUsUUFDZkEsSUFBSSxDQUFDLFdBQVcsT0FBZ0JKLE9BQVRGLE9BQU0sS0FBVSxPQUFQRSxTQUNoQ0ksSUFBSSxDQUFDLHVCQUF1QjtRQUVqQyxNQUFNQyxRQUFRWixLQUFLYSxHQUFHLENBQUMsQ0FBQ0MsUUFBVUEsTUFBTUMsSUFBSSxHQUFHO1FBQy9DLE1BQU1DLFVBQVVDLEtBQUtDLEtBQUssQ0FBQzdCLEdBQUc4QixHQUFHLENBQUNQLFNBQVMsS0FBSztRQUNoRCxNQUFNUSxVQUFVSCxLQUFLSSxJQUFJLENBQUNoQyxHQUFHaUMsR0FBRyxDQUFDVixTQUFTLEtBQUs7UUFDL0MsTUFBTVcsU0FBU2xDLEdBQUdtQyxXQUFXLEdBQUdDLE1BQU0sQ0FBQztZQUFDVDtZQUFTSTtTQUFRLEVBQUVNLEtBQUssQ0FBQztZQUFDO1lBQUlyQixRQUFRO1NBQUc7UUFDakYsTUFBTXNCLFlBQVl0QyxHQUFHc0MsU0FBUyxHQUFHRixNQUFNLENBQUNGLE9BQU9FLE1BQU0sSUFBSUcsVUFBVSxDQUFDdkMsR0FBR3FDLEtBQUssQ0FBQ1YsU0FBU0ksU0FBUztRQUMvRixNQUFNUyxPQUFPRixVQUFVZjtRQUV2QixNQUFNa0IsY0FBY3pDLEdBQUdpQyxHQUFHLENBQUNPLE1BQU0sQ0FBQ0UsSUFBTUEsRUFBRXJDLE1BQU07UUFDaEQsTUFBTXNDLFNBQVMzQyxHQUFHbUMsV0FBVyxHQUFHQyxNQUFNLENBQUM7WUFBQztZQUFHSztTQUFZLEVBQUVKLEtBQUssQ0FBQztZQUFDbkIsU0FBUztZQUFJO1NBQUc7UUFFaEYsa0ZBQWtGO1FBQ2xGLFNBQVMwQjtZQUNMeEIsSUFBSUMsTUFBTSxDQUFDLEtBQ05DLElBQUksQ0FBQyxTQUFTLFFBQ2RSLFNBQVMsQ0FBQyxRQUNWSCxJQUFJLENBQUNYLEdBQUdxQyxLQUFLLENBQUMsR0FBR0ksY0FBYyxHQUFHLElBQUksd0NBQXdDO2FBQzlFSSxLQUFLLEdBQ0x4QixNQUFNLENBQUMsUUFDUEMsSUFBSSxDQUFDLE1BQU0sSUFDWEEsSUFBSSxDQUFDLE1BQU1OLFFBQVEsSUFDbkJNLElBQUksQ0FBQyxNQUFNLENBQUNvQixJQUFNQyxPQUFPRCxJQUN6QnBCLElBQUksQ0FBQyxNQUFNLENBQUNvQixJQUFNQyxPQUFPRCxJQUN6QnBCLElBQUksQ0FBQyxVQUFVLFFBQ2ZBLElBQUksQ0FBQyxvQkFBb0IsUUFBUSxxQ0FBcUM7UUFDL0U7UUFFQXNCLFlBQVksZ0RBQWdEO1FBRTVEeEIsSUFBSU4sU0FBUyxDQUFDLFFBQ1RILElBQUksQ0FBQzZCLE1BQ0xLLEtBQUssR0FDTHhCLE1BQU0sQ0FBQyxRQUNQQyxJQUFJLENBQUMsS0FBSyxDQUFDb0IsSUFBTVIsT0FBT1EsRUFBRUksRUFBRSxHQUM1QnhCLElBQUksQ0FBQyxLQUFLLENBQUNvQixJQUFNQyxPQUFPRCxFQUFFckMsTUFBTSxHQUNoQ2lCLElBQUksQ0FBQyxTQUFTLENBQUNvQixJQUFNUixPQUFPUSxFQUFFSyxFQUFFLElBQUliLE9BQU9RLEVBQUVJLEVBQUUsSUFBSSxHQUNuRHhCLElBQUksQ0FBQyxVQUFVLENBQUNvQixJQUFNeEIsU0FBUyxLQUFLeUIsT0FBT0QsRUFBRXJDLE1BQU0sR0FDbkRpQixJQUFJLENBQUMsUUFBUTtRQUVsQkYsSUFBSUMsTUFBTSxDQUFDLFFBQ05DLElBQUksQ0FBQyxLQUFLTixRQUFRLEdBQ2xCTSxJQUFJLENBQUMsS0FBSyxJQUNWQSxJQUFJLENBQUMsZUFBZTtRQUN6QixvQ0FBb0M7UUFFcENGLElBQUlDLE1BQU0sQ0FBQyxLQUNOQyxJQUFJLENBQUMsYUFBYSxnQkFBNEIsT0FBWkosU0FBUyxJQUFHLE1BQzlDOEIsSUFBSSxDQUFDaEQsR0FBR2lELFVBQVUsQ0FBQ2YsUUFBUWdCLFVBQVUsQ0FBQ2xELEdBQUdxQyxLQUFLLENBQUNWLFNBQVNJLFVBQVUsS0FBSztRQUU1RVgsSUFBSUMsTUFBTSxDQUFDLEtBQ05DLElBQUksQ0FBQyxhQUFjLG9CQUNuQjBCLElBQUksQ0FBQ2hELEdBQUdtRCxRQUFRLENBQUNSO0lBQzFCO0lBRUEscUJBQU8sOERBQUNTO1FBQUlDLEtBQUtsRDtRQUFjbUQsV0FBVTs7Ozs7O0FBQzdDO0dBdkZ3QnJEO0tBQUFBIiwic291cmNlcyI6WyJFOlxcV3BpXFxSZWd1bGFybHlcXENvdXJzZXNcXFNyXFwyMDI0X0NfVGVybVxcQ1M0MjQxXFxIV1xcZmluYWwtcHJvamVjdC1rZXJtaXQtdGhlLWZyb2dcXHNyY1xcYXBwXFxkYXRhVmlzXFxUaW1lRGlzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5jb25zdCBkMyA9IGF3YWl0IGltcG9ydCgnZDMnKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNvbHZlVGltZURpc3RyaWJ1dGlvbih7IHNvbHZlcyB9KSB7XHJcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQgJiYgc29sdmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZHJhd1NvbHZlVGltZURpc3RyaWJ1dGlvbihzb2x2ZXMpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgIH0sIFtzb2x2ZXNdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGRyYXdTb2x2ZVRpbWVEaXN0cmlidXRpb24oc29sdmVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NvbHZlVGltZURpc3RyaWJ1dGlvbihkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IGNvbnRhaW5lci5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICcxMDAlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsICcxMDAlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApXHJcbiAgICAgICAgICAgIC5hdHRyKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaWRZTWlkIG1lZXQnKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGltZXMgPSBkYXRhLm1hcCgoc29sdmUpID0+IHNvbHZlLnRpbWUgLyAxMDAwKTtcclxuICAgICAgICBjb25zdCBtaW5EYXRhID0gTWF0aC5mbG9vcihkMy5taW4odGltZXMpICogMikgLyAyO1xyXG4gICAgICAgIGNvbnN0IG1heERhdGEgPSBNYXRoLmNlaWwoZDMubWF4KHRpbWVzKSAqIDIpIC8gMjtcclxuICAgICAgICBjb25zdCB4U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbbWluRGF0YSwgbWF4RGF0YV0pLnJhbmdlKFs1MCwgd2lkdGggLSA1MF0pO1xyXG4gICAgICAgIGNvbnN0IGhpc3RvZ3JhbSA9IGQzLmhpc3RvZ3JhbSgpLmRvbWFpbih4U2NhbGUuZG9tYWluKCkpLnRocmVzaG9sZHMoZDMucmFuZ2UobWluRGF0YSwgbWF4RGF0YSwgMC41KSk7XHJcbiAgICAgICAgY29uc3QgYmlucyA9IGhpc3RvZ3JhbSh0aW1lcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IG1heEJpbkNvdW50ID0gZDMubWF4KGJpbnMsIChkKSA9PiBkLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIG1heEJpbkNvdW50XSkucmFuZ2UoW2hlaWdodCAtIDUwLCA1MF0pO1xyXG5cclxuICAgICAgICAvLyDinIUgRHJhdyBob3Jpem9udGFsIGdyaWQgbGluZXMgYXQgZXZlcnkgaW50ZWdlciB2YWx1ZSAoMSwgMiwgMywgLi4uLCBtYXhCaW5Db3VudClcclxuICAgICAgICBmdW5jdGlvbiBkcmF3R3JpZCgpIHtcclxuICAgICAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGQzLnJhbmdlKDEsIG1heEJpbkNvdW50ICsgMSwgMSkpIC8vIOKchSBFdmVyeSBpbnRlZ2VyIGZyb20gMSB0byBtYXhCaW5Db3VudFxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgKGQpID0+IHlTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIChkKSA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAnNCw0Jyk7IC8vIERhc2hlZCBsaW5lcyBmb3IgYmV0dGVyIHZpc2liaWxpdHlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRyYXdHcmlkKCk7IC8vIOKchSBDYWxsIGdyaWQgZnVuY3Rpb24gYWZ0ZXIgc2V0dGluZyB0aGUgeS1heGlzXHJcblxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuZGF0YShiaW5zKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCkgPT4geFNjYWxlKGQueDApKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiB5U2NhbGUoZC5sZW5ndGgpKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCkgPT4geFNjYWxlKGQueDEpIC0geFNjYWxlKGQueDApIC0gMSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkKSA9PiBoZWlnaHQgLSA1MCAtIHlTY2FsZShkLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3N0ZWVsYmx1ZScpO1xyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCB3aWR0aCAvIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMjApXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcclxuICAgICAgICAvLyAudGV4dCgnU29sdmUgVGltZSBEaXN0cmlidXRpb24nKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7aGVpZ2h0IC0gNTB9KWApXHJcbiAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNCb3R0b20oeFNjYWxlKS50aWNrVmFsdWVzKGQzLnJhbmdlKG1pbkRhdGEsIG1heERhdGEgKyAwLjUsIDAuNSkpKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDUwLCAwKWApXHJcbiAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNMZWZ0KHlTY2FsZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiA8ZGl2IHJlZj17Y29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJiZy13aGl0ZSB3LXNjcmVlbiBoLVtjYWxjKDEwMHZoLTEwMHB4KV1cIj48L2Rpdj47XHJcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiZDMiLCJTb2x2ZVRpbWVEaXN0cmlidXRpb24iLCJzb2x2ZXMiLCJjb250YWluZXJSZWYiLCJjdXJyZW50IiwibGVuZ3RoIiwiZHJhd1NvbHZlVGltZURpc3RyaWJ1dGlvbiIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVSZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGF0YSIsImNvbnRhaW5lciIsInNlbGVjdCIsInNlbGVjdEFsbCIsInJlbW92ZSIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzdmciLCJhcHBlbmQiLCJhdHRyIiwidGltZXMiLCJtYXAiLCJzb2x2ZSIsInRpbWUiLCJtaW5EYXRhIiwiTWF0aCIsImZsb29yIiwibWluIiwibWF4RGF0YSIsImNlaWwiLCJtYXgiLCJ4U2NhbGUiLCJzY2FsZUxpbmVhciIsImRvbWFpbiIsInJhbmdlIiwiaGlzdG9ncmFtIiwidGhyZXNob2xkcyIsImJpbnMiLCJtYXhCaW5Db3VudCIsImQiLCJ5U2NhbGUiLCJkcmF3R3JpZCIsImVudGVyIiwieDAiLCJ4MSIsImNhbGwiLCJheGlzQm90dG9tIiwidGlja1ZhbHVlcyIsImF4aXNMZWZ0IiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TimeDis.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js":
/*!******************************************!*\
  !*** ./src/app/dataVis/TrendAnaIndex.js ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrendAnaTime */ \"(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__]);\n_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\n\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [showTimeView, setShowTimeView] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return; // ðŸ”¥ Ensure solves is valid\n            if (containerRef.current) {\n                drawSolveTimeTrend(solves);\n                window.addEventListener('resize', handleResize);\n            }\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]);\n    if (showTimeView) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TrendAnaTime__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            solves: solves\n        }, void 0, false, {\n            fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaIndex.js\",\n            lineNumber: 23,\n            columnNumber: 16\n        }, this);\n    }\n    function handleResize() {\n        if (containerRef.current) {\n            drawSolveTimeTrend(solves);\n        }\n    }\n    function computeRollingAverage(data, windowSize) {\n        const rollingAvg = data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null;\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n        console.log(\"Window Size: \".concat(windowSize));\n        console.log(\"Original Data Length: \".concat(data.length));\n        console.log(\"Rolling Average (\".concat(windowSize, \") Length: \").concat(rollingAvg.length));\n        console.log(\"First Values:\", rollingAvg.slice(0, 15)); // Check first few values\n        console.log(\"Last Values:\", rollingAvg.slice(-15)); // Check last few values\n        return rollingAvg;\n    }\n    function drawSolveTimeTrend(data) {\n        if (!containerRef.current) return;\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        const times = data.map((solve)=>solve.time / 1000);\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        let xScale = d3.scaleLinear().domain([\n            0,\n            times.length - 1\n        ]).range([\n            50,\n            width - 50\n        ]);\n        let yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]) // Flip domain to match SVG coords\n        .range([\n            50,\n            height - 50\n        ]); // Ensure bottom is lower on the screen\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale));\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom().scaleExtent([\n            0.5,\n            5\n        ]).translateExtent([\n            [\n                0,\n                0\n            ],\n            [\n                width,\n                height\n            ]\n        ]).on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale));\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // âœ… Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 100)\")); // â¬‡ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        function autoscale(event) {\n            event.preventDefault(); // Stop default zoom behavior\n            event.stopPropagation(); // Prevent further event propagation\n            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity); // Reset to original zoom state\n        }\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"ðŸ”„ Updating Plot with New Scales:\");\n            console.log(\"ðŸŸ¢ New X Scale Domain:\", newXScale.domain());\n            console.log(\"ðŸŸ¢ New Y Scale Domain:\", newYScale.domain());\n            // âœ… Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12.map((val, i)=>({\n                    x: i,\n                    y: val\n                })), (d)=>d.x); // Ensure unique key binding\n            console.log(\"âœ” Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"âœ” Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"âš ï¸ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"âš ï¸ No AO12 points found in updatePlot!\");\n            // âœ… Update all AO5 points\n            ao5Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // âœ… Update all AO12 points\n            ao12Selection.attr('cx', (d)=>newXScale(d.x)).attr('cy', (d)=>newYScale(d.y));\n            // âœ… Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // âœ… Update single solve points\n            svg.selectAll('.point-single').attr('cx', (_, i)=>newXScale(i)).attr('cy', (_, i)=>newYScale(times[i]));\n            // âœ… Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(times[i])));\n            // âœ… Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao5[i])));\n            // âœ… Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>newXScale(i)).y((_, i)=>newYScale(ao12[i])));\n        }\n        svg.append('path').datum(times).attr('class', 'line line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao5).attr('class', 'line line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2);\n        svg.append('path').datum(ao12).attr('class', 'line line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2);\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, i) {\n            var _times_i, _ao5_i, _ao12_i;\n            const singleTime = (_times_i = times[i]) === null || _times_i === void 0 ? void 0 : _times_i.toFixed(2);\n            const ao5Time = ao5[i] !== null ? (_ao5_i = ao5[i]) === null || _ao5_i === void 0 ? void 0 : _ao5_i.toFixed(2) : '-';\n            const ao12Time = ao12[i] !== null ? (_ao12_i = ao12[i]) === null || _ao12_i === void 0 ? void 0 : _ao12_i.toFixed(2) : '-';\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // âœ… Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // âœ… Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // âœ… Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"âœ” Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color).on('mouseover', (event, d)=>showTooltip(event, d.x)).on('mouseout', hideTooltip);\n        }\n        // âœ… Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n        const controls = d3.select(containerRef.current).append('div').attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow flex space-x-3'); // Flexbox for horizontal layout and spacing\n        controls.append('button').html('<img src=\"/dataVis-resize-scaling.svg\" alt=\"Autoscale\" width=\"24\" height=\"24\">').style('margin', '5px') // Adds uniform spacing around buttons\n        .on('click', autoscale);\n        controls.append('button').html('<img src=\"/dataVis-switch.svg\" alt=\"Switch View\" width=\"24\" height=\"24\">').style('margin', '5px').on('click', ()=>setShowTimeView(true));\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaIndex.js\",\n        lineNumber: 362,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"ndK8gk+SELWIn4XZP6sgEtccqj4=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYUluZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFb0Q7QUFDcEQsTUFBTUcsS0FBSyxNQUFNLDRNQUFZO0FBQ2E7QUFFM0IsU0FBU0UsZUFBZSxLQUFVO1FBQVYsRUFBRUMsTUFBTSxFQUFFLEdBQVY7O0lBQ25DLE1BQU1DLGVBQWVOLDZDQUFNQSxDQUFDO0lBRTVCLE1BQU0sQ0FBQ08sY0FBY0MsZ0JBQWdCLEdBQUdQLCtDQUFRQSxDQUFDO0lBRWpERixnREFBU0E7b0NBQUM7WUFDTixJQUFJLENBQUNNLFVBQVUsQ0FBQ0ksTUFBTUMsT0FBTyxDQUFDTCxXQUFXQSxPQUFPTSxNQUFNLEtBQUssR0FBRyxRQUFRLDRCQUE0QjtZQUNsRyxJQUFJTCxhQUFhTSxPQUFPLEVBQUU7Z0JBQ3RCQyxtQkFBbUJSO2dCQUNuQlMsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUM7WUFDdEM7WUFFQTs0Q0FBTyxJQUFNRixPQUFPRyxtQkFBbUIsQ0FBQyxVQUFVRDs7UUFDdEQ7bUNBQUc7UUFBQ1g7S0FBTztJQUVYLElBQUlFLGNBQWM7UUFDZCxxQkFBTyw4REFBQ0oscURBQVlBO1lBQUNFLFFBQVFBOzs7Ozs7SUFDakM7SUFFQSxTQUFTVztRQUNMLElBQUlWLGFBQWFNLE9BQU8sRUFBRTtZQUN0QkMsbUJBQW1CUjtRQUN2QjtJQUNKO0lBRUEsU0FBU2Esc0JBQXNCQyxJQUFJLEVBQUVDLFVBQVU7UUFDM0MsTUFBTUMsYUFBYUYsS0FBS0csR0FBRyxDQUFDLENBQUNDLEdBQUdDLEdBQUdDO1lBQy9CLElBQUlELElBQUlKLGFBQWEsR0FBRyxPQUFPO1lBQy9CLE1BQU1NLFNBQVNELElBQUlFLEtBQUssQ0FBQ0gsSUFBS0osQ0FBQUEsYUFBYSxJQUFJSSxJQUFJO1lBQ25ELE9BQU9FLE9BQU9FLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFNQyxLQUFLLEtBQUtKLE9BQU9mLE1B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QUFDLFVBQVUsT0FDaEJsQyxFQUFFLENBQUMsU0FBUyxJQUFNN0QsZ0JBQWdCO0lBQzNDO0lBRUEscUJBQ0ksOERBQUNtSDtRQUNHQyxLQUFLdEg7UUFDTDZHLFdBQVU7Ozs7OztBQUd0QjtHQXhXd0IvRztLQUFBQSIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxTclxcMjAyNF9DX1Rlcm1cXENTNDI0MVxcSFdcXGZpbmFsLXByb2plY3Qta2VybWl0LXRoZS1mcm9nXFxzcmNcXGFwcFxcZGF0YVZpc1xcVHJlbmRBbmFJbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmNvbnN0IGQzID0gYXdhaXQgaW1wb3J0KCdkMycpO1xyXG5pbXBvcnQgVHJlbmRBbmFUaW1lIGZyb20gJy4vVHJlbmRBbmFUaW1lJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNvbHZlVGltZVRyZW5kKHsgc29sdmVzIH0pIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcclxuXHJcbiAgICBjb25zdCBbc2hvd1RpbWVWaWV3LCBzZXRTaG93VGltZVZpZXddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzb2x2ZXMgfHwgIUFycmF5LmlzQXJyYXkoc29sdmVzKSB8fCBzb2x2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIPCflKUgRW5zdXJlIHNvbHZlcyBpcyB2YWxpZFxyXG4gICAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBkcmF3U29sdmVUaW1lVHJlbmQoc29sdmVzKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICB9LCBbc29sdmVzXSk7XHJcblxyXG4gICAgaWYgKHNob3dUaW1lVmlldykge1xyXG4gICAgICAgIHJldHVybiA8VHJlbmRBbmFUaW1lIHNvbHZlcz17c29sdmVzfSAvPjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGRyYXdTb2x2ZVRpbWVUcmVuZChzb2x2ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlUm9sbGluZ0F2ZXJhZ2UoZGF0YSwgd2luZG93U2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IHJvbGxpbmdBdmcgPSBkYXRhLm1hcCgoXywgaSwgYXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgd2luZG93U2l6ZSAtIDEpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBzdWJzZXQgPSBhcnIuc2xpY2UoaSAtICh3aW5kb3dTaXplIC0gMSksIGkgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnNldC5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gc3Vic2V0Lmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFdpbmRvdyBTaXplOiAke3dpbmRvd1NpemV9YCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYE9yaWdpbmFsIERhdGEgTGVuZ3RoOiAke2RhdGEubGVuZ3RofWApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBSb2xsaW5nIEF2ZXJhZ2UgKCR7d2luZG93U2l6ZX0pIExlbmd0aDogJHtyb2xsaW5nQXZnLmxlbmd0aH1gKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgRmlyc3QgVmFsdWVzOmAsIHJvbGxpbmdBdmcuc2xpY2UoMCwgMTUpKTsgLy8gQ2hlY2sgZmlyc3QgZmV3IHZhbHVlc1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBMYXN0IFZhbHVlczpgLCByb2xsaW5nQXZnLnNsaWNlKC0xNSkpOyAvLyBDaGVjayBsYXN0IGZldyB2YWx1ZXNcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvbGxpbmdBdmc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NvbHZlVGltZVRyZW5kKGRhdGEpIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCk7XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgfHwgNTAwO1xyXG5cclxuICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXIuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKVxyXG4gICAgICAgICAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVzID0gZGF0YS5tYXAoKHNvbHZlKSA9PiBzb2x2ZS50aW1lIC8gMTAwMCk7XHJcbiAgICAgICAgY29uc3QgYW81ID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCA1KTtcclxuICAgICAgICBjb25zdCBhbzEyID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCAxMik7XHJcblxyXG4gICAgICAgIGxldCB4U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oWzAsIHRpbWVzLmxlbmd0aCAtIDFdKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCB3aWR0aCAtIDUwXSk7XHJcblxyXG4gICAgICAgIGxldCB5U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4oW2QzLm1heCh0aW1lcyksIGQzLm1pbih0aW1lcyldKSAgLy8gRmxpcCBkb21haW4gdG8gbWF0Y2ggU1ZHIGNvb3Jkc1xyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCBoZWlnaHQgLSA1MF0pOyAvLyBFbnN1cmUgYm90dG9tIGlzIGxvd2VyIG9uIHRoZSBzY3JlZW5cclxuXHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3gtYXhpcycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7aGVpZ2h0IC0gNTB9KWApXHJcbiAgICAgICAgICAgIC5jYWxsKGQzLmF4aXNCb3R0b20oeFNjYWxlKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5LWF4aXMnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSg1MCwgMClgKVxyXG4gICAgICAgICAgICAuY2FsbChkMy5heGlzTGVmdCh5U2NhbGUpKTtcclxuXHJcbiAgICAgICAgY29uc3QgZ3JpZEdyb3VwID0gc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2dyaWQnKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd0dyaWQoeFNjYWxlLCB5U2NhbGUpIHtcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBncmlkIGxpbmVzXHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJy5ob3Jpem9udGFsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoeVNjYWxlLnRpY2tzKDEwKSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdob3Jpem9udGFsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZCA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBkID0+IHlTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICc0LDQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIGdyaWQgbGluZXNcclxuICAgICAgICAgICAgZ3JpZEdyb3VwLnNlbGVjdEFsbCgnLnZlcnRpY2FsLWdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoeFNjYWxlLnRpY2tzKDEwKSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd2ZXJ0aWNhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4geFNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiB4U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGhlaWdodCAtIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjY2NjJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgJzQsNCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHJhd0dyaWQoeFNjYWxlLCB5U2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCB6b29tID0gZDMuem9vbSgpXHJcbiAgICAgICAgICAgIC5zY2FsZUV4dGVudChbMC41LCA1XSlcclxuICAgICAgICAgICAgLnRyYW5zbGF0ZUV4dGVudChbWzAsIDBdLCBbd2lkdGgsIGhlaWdodF1dKVxyXG4gICAgICAgICAgICAub24oJ3pvb20nLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGV2ZW50LnRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1hTY2FsZSA9IHRyYW5zZm9ybS5yZXNjYWxlWCh4U2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3WVNjYWxlID0gdHJhbnNmb3JtLnJlc2NhbGVZKHlTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBwbG90c1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlUGxvdChuZXdYU2NhbGUsIG5ld1lTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGF4ZXNcclxuICAgICAgICAgICAgICAgIHhBeGlzLmNhbGwoZDMuYXhpc0JvdHRvbShuZXdYU2NhbGUpKTtcclxuICAgICAgICAgICAgICAgIHlBeGlzLmNhbGwoZDMuYXhpc0xlZnQobmV3WVNjYWxlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdyaWQgd2l0aCBuZXcgc2NhbGVzXHJcbiAgICAgICAgICAgICAgICBkcmF3R3JpZChuZXdYU2NhbGUsIG5ld1lTY2FsZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzdmcuY2FsbCh6b29tKTtcclxuXHJcbiAgICAgICAgLy8g4pyFIEFkZCBMZWdlbmRzIChCZWxvdyBBdXRvc2NhbGUgQnV0dG9uKVxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3dpZHRoIC0gMTIwfSwgMTAwKWApOyAvLyDirIcgTW92ZXMgbGVnZW5kIGxvd2VyIHVuZGVyIGJ1dHRvblxyXG5cclxuICAgICAgICBjb25zdCBsZWdlbmRJdGVtcyA9IFtcclxuICAgICAgICAgICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ1NpbmdsZScgfSxcclxuICAgICAgICAgICAgeyBjb2xvcjogJ2dyZWVuJywgbGFiZWw6ICdBTzUnIH0sXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdyZWQnLCBsYWJlbDogJ0FPMTInIH1cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBsZWdlbmRJdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBpICogMjApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgaXRlbS5jb2xvcik7XHJcblxyXG4gICAgICAgICAgICBsZWdlbmQuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMjApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGkgKiAyMCArIDEyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgICAgICAgICAgICAgIC50ZXh0KGl0ZW0ubGFiZWwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhdXRvc2NhbGUoZXZlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gU3RvcCBkZWZhdWx0IHpvb20gYmVoYXZpb3JcclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFByZXZlbnQgZnVydGhlciBldmVudCBwcm9wYWdhdGlvblxyXG5cclxuICAgICAgICAgICAgc3ZnLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcclxuICAgICAgICAgICAgICAgIC5jYWxsKHpvb20udHJhbnNmb3JtLCBkMy56b29tSWRlbnRpdHkpOyAvLyBSZXNldCB0byBvcmlnaW5hbCB6b29tIHN0YXRlXHJcbiAgICAgICAgfVxyXG5cclxuLy8gRW5zdXJlIGV2ZW50IGlzIHBhc3NlZCB0byBhdXRvc2NhbGVcclxuICAgICAgICBzdmcub24oJ2RibGNsaWNrJywgKGV2ZW50KSA9PiBhdXRvc2NhbGUoZXZlbnQpKTtcclxuXHJcbi8vIEFsc28gZXhwbGljaXRseSBkaXNhYmxlIHpvb20gb24gZG91YmxlLWNsaWNrIHRvIHByZXZlbnQgem9vbWluZyBpblxyXG4gICAgICAgIHN2Zy5jYWxsKHpvb20pLm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUGxvdChuZXdYU2NhbGUsIG5ld1lTY2FsZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflIQgVXBkYXRpbmcgUGxvdCB3aXRoIE5ldyBTY2FsZXM6XCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfn6IgTmV3IFggU2NhbGUgRG9tYWluOlwiLCBuZXdYU2NhbGUuZG9tYWluKCkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfn6IgTmV3IFkgU2NhbGUgRG9tYWluOlwiLCBuZXdZU2NhbGUuZG9tYWluKCkpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSB0aGF0IHRoZSBBTzUgYW5kIEFPMTIgcG9pbnRzIGFyZSBjb3JyZWN0bHkgYm91bmRcclxuICAgICAgICAgICAgY29uc3QgYW81U2VsZWN0aW9uID0gc3ZnLnNlbGVjdEFsbCgnLnBvaW50LWFvNScpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShhbzUubWFwKCh2YWwsIGkpID0+ICh7IHg6IGksIHk6IHZhbCB9KSksIGQgPT4gZC54KTsgLy8gRW5zdXJlIHVuaXF1ZSBrZXkgYmluZGluZ1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYW8xMlNlbGVjdGlvbiA9IHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1hbzEyJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGFvMTIubWFwKCh2YWwsIGkpID0+ICh7IHg6IGksIHk6IHZhbCB9KSksIGQgPT4gZC54KTsgLy8gRW5zdXJlIHVuaXF1ZSBrZXkgYmluZGluZ1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBUb3RhbCBBTzUgUG9pbnRzIFNlbGVjdGVkOiAke2FvNVNlbGVjdGlvbi5zaXplKCl9IChFeHBlY3RlZDogJHthbzUubGVuZ3RofSlgKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKclCBUb3RhbCBBTzEyIFBvaW50cyBTZWxlY3RlZDogJHthbzEyU2VsZWN0aW9uLnNpemUoKX0gKEV4cGVjdGVkOiAke2FvMTIubGVuZ3RofSlgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbzVTZWxlY3Rpb24uc2l6ZSgpID09PSAwKSBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gQU81IHBvaW50cyBmb3VuZCBpbiB1cGRhdGVQbG90IVwiKTtcclxuICAgICAgICAgICAgaWYgKGFvMTJTZWxlY3Rpb24uc2l6ZSgpID09PSAwKSBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gQU8xMiBwb2ludHMgZm91bmQgaW4gdXBkYXRlUGxvdCFcIik7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIGFsbCBBTzUgcG9pbnRzXHJcbiAgICAgICAgICAgIGFvNVNlbGVjdGlvbi5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKGQueCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgYWxsIEFPMTIgcG9pbnRzXHJcbiAgICAgICAgICAgIGFvMTJTZWxlY3Rpb24uYXR0cignY3gnLCBkID0+IG5ld1hTY2FsZShkLngpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBuZXdZU2NhbGUoZC55KSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRGVidWdnaW5nOiBFbnN1cmUgbGFzdCBBTzUgJiBBTzEyIHBvaW50cyB1cGRhdGUgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGFvNVNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhbzUubGVuZ3RoIC0gNCkgeyAvLyBVc2UgYGFvNS5sZW5ndGhgIHRvIGNvcnJlY3RseSBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfn6IgQU81IFBvaW50ICR7aX06IHg9JHtuZXdYU2NhbGUoZC54KX0sIHk9JHtuZXdZU2NhbGUoZC55KX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBhbzEyU2VsZWN0aW9uLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGFvMTIubGVuZ3RoIC0gMTIpIHsgLy8gVXNlIGBhbzEyLmxlbmd0aGAgdG8gY29ycmVjdGx5IGl0ZXJhdGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UtCBBTzEyIFBvaW50ICR7aX06IHg9JHtuZXdYU2NhbGUoZC54KX0sIHk9JHtuZXdZU2NhbGUoZC55KX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIHNpbmdsZSBzb2x2ZSBwb2ludHNcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLnBvaW50LXNpbmdsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCAoXywgaSkgPT4gbmV3WFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgKF8sIGkpID0+IG5ld1lTY2FsZSh0aW1lc1tpXSkpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBzaW5nbGUgc29sdmUgbGluZVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1zaW5nbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoKF8sIGkpID0+IG5ld1hTY2FsZShpKSlcclxuICAgICAgICAgICAgICAgICAgICAueSgoXywgaSkgPT4gbmV3WVNjYWxlKHRpbWVzW2ldKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgRW5zdXJlIEFPNSBsaW5lIGFsaWducyBkeW5hbWljYWxseVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1hbzUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoKF8sIGkpID0+IGkgPj0gNCAmJiBhbzVbaV0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoKF8sIGkpID0+IG5ld1hTY2FsZShpKSlcclxuICAgICAgICAgICAgICAgICAgICAueSgoXywgaSkgPT4gbmV3WVNjYWxlKGFvNVtpXSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSBBTzEyIGxpbmUgYWxpZ25zIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoKF8sIGkpID0+IGkgPj0gMTEgJiYgYW8xMltpXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAueCgoXywgaSkgPT4gbmV3WFNjYWxlKGkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiBuZXdZU2NhbGUoYW8xMltpXSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXR1bSh0aW1lcylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUgbGluZS1zaW5nbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsdWUnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKGFvNSlcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUgbGluZS1hbzUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2dyZWVuJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5kYXR1bShhbzEyKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZSBsaW5lLWFvMTInKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ3JlZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Fic29sdXRlIGJnLXdoaXRlIHAtMiBib3JkZXIgcm91bmRlZCBzaGFkb3cgdGV4dC1zbScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKGV2ZW50LCBpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVRpbWUgPSB0aW1lc1tpXT8udG9GaXhlZCgyKTtcclxuICAgICAgICAgICAgY29uc3QgYW81VGltZSA9IGFvNVtpXSAhPT0gbnVsbCA/IGFvNVtpXT8udG9GaXhlZCgyKSA6ICctJztcclxuICAgICAgICAgICAgY29uc3QgYW8xMlRpbWUgPSBhbzEyW2ldICE9PSBudWxsID8gYW8xMltpXT8udG9GaXhlZCgyKSA6ICctJztcclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuaHRtbChgXHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+U2luZ2xlOjwvc3Ryb25nPiAke3NpbmdsZVRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPkFPNTo8L3N0cm9uZz4gJHthbzVUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5BTzEyOjwvc3Ryb25nPiAke2FvMTJUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgYClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnZml4ZWQnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgJ3doaXRlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncGFkZGluZycsICc2cHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXInLCAnMXB4IHNvbGlkICNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXItcmFkaXVzJywgJzVweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JveC1zaGFkb3cnLCAnMnB4IDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3otaW5kZXgnLCAnMTAwMCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgLTUwJSknKTtcclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ2xlZnQnLCBgJHtldmVudC5wYWdlWCArIDEyfXB4YCkuc3R5bGUoJ3RvcCcsIGAke2V2ZW50LnBhZ2VZfXB4YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcclxuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB1cGRhdGVQbG90KHhTY2FsZSwgeVNjYWxlKTsgIC8vIOKchSBGb3JjZSByZW5kZXIgYWZ0ZXIgaW5pdGlhbGl6YXRpb25cclxuICAgICAgICB9LCAxMDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRQb2ludHMoZGF0YSwgY29sb3IsIGNsYXNzTmFtZSwgdmFsdWVBY2Nlc3NvciwgbWluSW5kZXgsIGxhYmVsKSB7XHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgdGhhdCB3ZSBjb3JyZWN0bHkgaXRlcmF0ZSBvdmVyIHRoZSBmdWxsIGRhdGFzZXRcclxuICAgICAgICAgICAgY29uc3QgdmFsaWRQb2ludHMgPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAubWFwKCh2YWwsIGkpID0+ICh7IHg6IGksIHk6IHZhbHVlQWNjZXNzb3IoaSkgfSkpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGQgPT4gZC55ICE9PSBudWxsICYmIGQueCA+PSBtaW5JbmRleCk7IC8vIOKchSBSZW1vdmVkIHggPCB0aW1lcy5sZW5ndGggY29uc3RyYWludFxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfn6IgQWRkaW5nIFBvaW50cyBmb3IgJHtsYWJlbH0gfCBDbGFzczogJHtjbGFzc05hbWV9IHwgTWluSW5kZXg6ICR7bWluSW5kZXh9YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJQgVmFsaWQgUG9pbnRzIENvdW50OiAke3ZhbGlkUG9pbnRzLmxlbmd0aH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk40gRmlyc3QgNSBQb2ludHM6YCwgdmFsaWRQb2ludHMuc2xpY2UoMCwgNSkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjSBMYXN0IDUgUG9pbnRzOmAsIHZhbGlkUG9pbnRzLnNsaWNlKC01KSk7XHJcblxyXG4gICAgICAgICAgICB2YWxpZFBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICAgICAgYPCflLUgJHtsYWJlbH0gUG9pbnQgJHtpICsgbWluSW5kZXh9OiBSYXdYPSR7cG9pbnQueH0sIFNjYWxlZFg9JHt4U2NhbGUocG9pbnQueCl9LCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUmF3WT0ke3BvaW50LnkudG9GaXhlZCgzKX0sIFNjYWxlZFk9JHt5U2NhbGUocG9pbnQueSkudG9GaXhlZCgyKX1gXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSBkYXRhIGJpbmRpbmcgaXMgZG9uZSBjb3JyZWN0bHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbChgLiR7Y2xhc3NOYW1lfWApXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh2YWxpZFBvaW50cywgZCA9PiBkLngpIC8vIEVuc3VyZSB1bmlxdWUga2V5IGJpbmRpbmdcclxuICAgICAgICAgICAgICAgIC5qb2luKFwiY2lyY2xlXCIpIC8vIEVuc3VyZSBwcm9wZXIgYmluZGluZ1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYHBvaW50ICR7Y2xhc3NOYW1lfWApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IHhTY2FsZShkLngpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC55KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY29sb3IpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIChldmVudCwgZCkgPT4gc2hvd1Rvb2x0aXAoZXZlbnQsIGQueCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgaGlkZVRvb2x0aXApO1xyXG4gICAgICAgIH1cclxuXHJcbi8vIOKchSBFbnN1cmUgQU81ICYgQU8xMiBwb2ludHMgYXJlIGZ1bGx5IGFkZGVkIGJlZm9yZSB1cGRhdGluZ1xyXG4gICAgICAgIGFkZFBvaW50cyh0aW1lcywgJ2JsdWUnLCAncG9pbnQtc2luZ2xlJywgKGkpID0+IHRpbWVzW2ldLCAwLCBcIlNpbmdsZVwiKTtcclxuICAgICAgICBhZGRQb2ludHMoYW81LCAnZ3JlZW4nLCAncG9pbnQtYW81JywgKGkpID0+IGFvNVtpXSwgNCwgXCJBTzVcIik7XHJcbiAgICAgICAgYWRkUG9pbnRzKGFvMTIsICdyZWQnLCAncG9pbnQtYW8xMicsIChpKSA9PiBhbzEyW2ldLCAxMSwgXCJBTzEyXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBjb250cm9scyA9IGQzLnNlbGVjdChjb250YWluZXJSZWYuY3VycmVudCkuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYWJzb2x1dGUgdG9wLTIgcmlnaHQtMiBiZy13aGl0ZSBwLTIgcm91bmRlZCBzaGFkb3cgZmxleCBzcGFjZS14LTMnKTsgLy8gRmxleGJveCBmb3IgaG9yaXpvbnRhbCBsYXlvdXQgYW5kIHNwYWNpbmdcclxuXHJcbiAgICAgICAgY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgICAgICAuaHRtbCgnPGltZyBzcmM9XCIvZGF0YVZpcy1yZXNpemUtc2NhbGluZy5zdmdcIiBhbHQ9XCJBdXRvc2NhbGVcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIj4nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmdpbicsICc1cHgnKSAvLyBBZGRzIHVuaWZvcm0gc3BhY2luZyBhcm91bmQgYnV0dG9uc1xyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgYXV0b3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgICAgICAuaHRtbCgnPGltZyBzcmM9XCIvZGF0YVZpcy1zd2l0Y2guc3ZnXCIgYWx0PVwiU3dpdGNoIFZpZXdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIj4nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmdpbicsICc1cHgnKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4gc2V0U2hvd1RpbWVWaWV3KHRydWUpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInctc2NyZWVuIGgtW2NhbGMoMTAwdmgtMTAwcHgpXSBiZy13aGl0ZSByZWxhdGl2ZVwiXHJcbiAgICAgICAgPjwvZGl2PlxyXG4gICAgKTtcclxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImQzIiwiVHJlbmRBbmFUaW1lIiwiU29sdmVUaW1lVHJlbmQiLCJzb2x2ZXMiLCJjb250YWluZXJSZWYiLCJzaG93VGltZVZpZXciLCJzZXRTaG93VGltZVZpZXciLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJjdXJyZW50IiwiZHJhd1NvbHZlVGltZVRyZW5kIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZVJlc2l6ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb21wdXRlUm9sbGluZ0F2ZXJhZ2UiLCJkYXRhIiwid2luZG93U2l6ZSIsInJvbGxpbmdBdmciLCJtYXAiLCJfIiwiaSIsImFyciIsInN1YnNldCIsInNsaWNlIiwicmVkdWNlIiwic3VtIiwidmFsIiwiY29uc29sZSIsImxvZyIsImNvbnRhaW5lciIsInNlbGVjdCIsInNlbGVjdEFsbCIsInJlbW92ZSIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzdmciLCJhcHBlbmQiLCJhdHRyIiwidGltZXMiLCJzb2x2ZSIsInRpbWUiLCJhbzUiLCJhbzEyIiwieFNjYWxlIiwic2NhbGVMaW5lYXIiLCJkb21haW4iLCJyYW5nZSIsInlTY2FsZSIsIm1heCIsIm1pbiIsInhBeGlzIiwiY2FsbCIsImF4aXNCb3R0b20iLCJ5QXhpcyIsImF4aXNMZWZ0IiwiZ3JpZEdyb3VwIiwiZHJhd0dyaWQiLCJ0aWNrcyIsImVudGVyIiwiZCIsInpvb20iLCJzY2FsZUV4dGVudCIsInRyYW5zbGF0ZUV4dGVudCIsIm9uIiwiZXZlbnQiLCJ0cmFuc2Zvcm0iLCJuZXdYU2NhbGUiLCJyZXNjYWxlWCIsIm5ld1lTY2FsZSIsInJlc2NhbGVZIiwidXBkYXRlUGxvdCIsImxlZ2VuZCIsImxlZ2VuZEl0ZW1zIiwiY29sb3IiLCJsYWJlbCIsImZvckVhY2giLCJpdGVtIiwidGV4dCIsImF1dG9zY2FsZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwidHJhbnNpdGlvbiIsImR1cmF0aW9uIiwiem9vbUlkZW50aXR5IiwiYW81U2VsZWN0aW9uIiwieCIsInkiLCJhbzEyU2VsZWN0aW9uIiwic2l6ZSIsIndhcm4iLCJlYWNoIiwibGluZSIsImN1cnZlIiwiY3VydmVNb25vdG9uZVgiLCJkZWZpbmVkIiwiZGF0dW0iLCJ0b29sdGlwIiwic3R5bGUiLCJzaG93VG9vbHRpcCIsInNpbmdsZVRpbWUiLCJ0b0ZpeGVkIiwiYW81VGltZSIsImFvMTJUaW1lIiwiaHRtbCIsInBhZ2VYIiwicGFnZVkiLCJoaWRlVG9vbHRpcCIsInNldFRpbWVvdXQiLCJhZGRQb2ludHMiLCJjbGFzc05hbWUiLCJ2YWx1ZUFjY2Vzc29yIiwibWluSW5kZXgiLCJ2YWxpZFBvaW50cyIsImZpbHRlciIsInBvaW50Iiwiam9pbiIsImNvbnRyb2xzIiwiZGl2IiwicmVmIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js":
/*!*****************************************!*\
  !*** ./src/app/dataVis/TrendAnaTime.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SolveTimeTrend)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrendAnaIndex */ \"(app-pages-browser)/./src/app/dataVis/TrendAnaIndex.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__]);\n_TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\nfunction SolveTimeTrend(param) {\n    let { solves } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [currentClusterIndex, setCurrentClusterIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [clusters, setClusters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [xDomain, setXDomain] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const xDomainRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // âœ… State to track whether we are in SolveTimeTrend or TrendAnaTime\n    const [showIndexView, setShowIndexView] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            console.log(\"ðŸ”„ XDomain or window size updated:\", xDomain);\n            if (!solves || solves.length === 0) {\n                console.warn(\"âš ï¸ No solves data available!\");\n                return;\n            }\n            const container = containerRef.current;\n            if (!container) {\n                console.warn(\"âš ï¸ Container reference is null!\");\n                return;\n            }\n            console.log(\"ðŸ“ Updating chart dimensions after resize...\");\n            drawSolveTimeTrend(solves);\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        xDomain,\n        containerRef\n    ]); // ðŸ”¥ Ensure chart updates when xDomain or container size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SolveTimeTrend.useEffect\": ()=>{\n            if (!solves || !Array.isArray(solves) || solves.length === 0) return;\n            console.log(\"ðŸ” Running cluster detection...\");\n            const detectedClusters = findClusters(solves);\n            setClusters(detectedClusters);\n            if (detectedClusters.length > 0) {\n                const firstCluster = detectedClusters[0];\n                const newDomain = [\n                    new Date(firstCluster[0].timestamp),\n                    new Date(firstCluster.slice(-1)[0].timestamp)\n                ];\n                setXDomain(newDomain);\n                xDomainRef.current = newDomain; // âœ… Ensure ref is updated\n                // â— Log AFTER setting the state to reflect the correct value\n                console.log(\"âœ… X-Domain initialized to first cluster:\", newDomain);\n            }\n            // Attach resize event\n            window.addEventListener('resize', handleResize);\n            return ({\n                \"SolveTimeTrend.useEffect\": ()=>window.removeEventListener('resize', handleResize)\n            })[\"SolveTimeTrend.useEffect\"];\n        }\n    }[\"SolveTimeTrend.useEffect\"], [\n        solves\n    ]); // <-- Runs only on first load\n    if (showIndexView) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TrendAnaIndex__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            solves: solves\n        }, void 0, false, {\n            fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n            lineNumber: 62,\n            columnNumber: 16\n        }, this);\n    }\n    function handleResize() {\n        console.log(\"ðŸ”„ Handling resize...\");\n        if (!solves || solves.length === 0) {\n            console.warn(\"âš ï¸ No solves available, skipping resize!\");\n            return;\n        }\n        let detectedClusters = clusters;\n        if (clusters.length === 0) {\n            console.warn(\"âš ï¸ No clusters available on resize! Refinding clusters...\");\n            detectedClusters = findClusters(solves);\n            setClusters(detectedClusters);\n        }\n        if (detectedClusters.length === 0) {\n            console.warn(\"âš ï¸ Still no clusters found after resize!\");\n            return;\n        }\n        const prevClusterIndex = currentClusterIndex;\n        const prevXDomain = xDomainRef.current;\n        console.log(\"\\uD83D\\uDCCC Preserving Cluster Index: \".concat(prevClusterIndex));\n        console.log(\"ðŸ” Preserving X-Domain before resize:\", prevXDomain);\n        // Ensure re-renders with correct states\n        setCurrentClusterIndex(prevClusterIndex);\n        setXDomain(prevXDomain);\n        xDomainRef.current = prevXDomain;\n        // âœ… Force state updates to re-enable buttons\n        setTimeout(()=>{\n            setClusters([\n                ...detectedClusters\n            ]);\n            setXDomain([\n                ...prevXDomain\n            ]);\n            setCurrentClusterIndex(prevClusterIndex);\n        }, 0);\n        // Redraw the chart after resize\n        drawSolveTimeTrend(solves);\n        console.log(\"âœ… Resize handled, restoring states.\");\n    }\n    function findClusters(data) {\n        console.log(\"ðŸ” Running findClusters...\");\n        let detectedClusters = [];\n        let currentCluster = [\n            data[0]\n        ];\n        for(let i = 1; i < data.length; i++){\n            if (new Date(data[i].timestamp) - new Date(data[i - 1].timestamp) > 15 * 60 * 1000) {\n                if (currentCluster.length > 1) {\n                    const uniqueXValues = new Set(currentCluster.map((d)=>d.timestamp));\n                    if (uniqueXValues.size > 1) {\n                        detectedClusters.push(currentCluster);\n                    } else {\n                        console.warn(\"âš ï¸ Ignoring cluster with same X-Axis values:\", currentCluster);\n                    }\n                }\n                currentCluster = [];\n            }\n            currentCluster.push(data[i]);\n        }\n        // Check last cluster before adding it\n        if (currentCluster.length > 1) {\n            const uniqueXValues = new Set(currentCluster.map((d)=>d.timestamp));\n            if (uniqueXValues.size > 1) {\n                detectedClusters.push(currentCluster);\n            } else {\n                console.warn(\"âš ï¸ Ignoring cluster with same X-Axis values:\", currentCluster);\n            }\n        }\n        console.log(\"ðŸ“Š Clusters identified (excluding single/same x-axis clusters):\", detectedClusters.length, detectedClusters);\n        return detectedClusters;\n    }\n    function computeRollingAverage(data, windowSize) {\n        return data.map((_, i, arr)=>{\n            if (i < windowSize - 1) return null; // âœ… Preserve nulls at the beginning\n            const subset = arr.slice(i - (windowSize - 1), i + 1);\n            return subset.reduce((sum, val)=>sum + val, 0) / subset.length;\n        });\n    }\n    function drawSolveTimeTrend(data) {\n        console.log(\"ðŸ” Current X-Domain in drawSolveTimeTrend:\", xDomainRef.current);\n        if (!containerRef.current) {\n            console.warn(\"âš ï¸ Container reference is null, cannot draw!\");\n            return;\n        }\n        const container = d3.select(containerRef.current);\n        container.selectAll('*').remove();\n        const width = containerRef.current.clientWidth || 800;\n        const height = containerRef.current.clientHeight || 500;\n        console.log(\"ðŸ“ Chart dimensions:\", width, height);\n        const svg = container.append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', \"0 0 \".concat(width, \" \").concat(height)).attr('preserveAspectRatio', 'xMidYMid meet');\n        // Ensure all data contains timestamps\n        const processedData = data.map((solve)=>{\n            if (!solve.timestamp) {\n                console.warn(\"âš ï¸ Skipping entry with missing timestamp:\", solve);\n                return null;\n            }\n            return {\n                timestamp: new Date(solve.timestamp),\n                time: solve.time / 1000\n            };\n        }).filter((d)=>d !== null); // Remove invalid entries\n        const timestamps = processedData.map((d)=>d.timestamp);\n        const times = processedData.map((d)=>d.time);\n        console.log(\"Processed timestamps:\", timestamps);\n        // ðŸ”¥ Find the first \"cluster\" (a short interval of data)\n        let clusterStartIndex = 0;\n        let clusterEndIndex = timestamps.length - 1;\n        for(let i = 1; i < timestamps.length; i++){\n            if (timestamps[i] - timestamps[0] > 15 * 60 * 1000) {\n                clusterEndIndex = i;\n                break;\n            }\n        }\n        // Extract the cluster time range\n        const initialXDomain = [\n            timestamps[clusterStartIndex],\n            timestamps[clusterEndIndex]\n        ];\n        console.log(\"â³ Initial Focus X Domain: \".concat(initialXDomain[0], \" to \").concat(initialXDomain[1]));\n        const ao5 = computeRollingAverage(times, 5);\n        const ao12 = computeRollingAverage(times, 12);\n        const ao5Data = timestamps.map((timestamp, i)=>({\n                timestamp: timestamp,\n                value: ao5[i] !== null ? ao5[i] : null\n            })).filter((d)=>d.value !== null); // Remove initial nulls\n        const ao12Data = timestamps.map((timestamp, i)=>({\n                timestamp: timestamp,\n                value: ao12[i] !== null ? ao12[i] : null\n            })).filter((d)=>d.value !== null); // Remove initial nulls\n        var _xDomainRef_current;\n        // X Scale: Start zoomed into the identified cluster\n        let xScale = d3.scaleTime().domain((_xDomainRef_current = xDomainRef.current) !== null && _xDomainRef_current !== void 0 ? _xDomainRef_current : [\n            timestamps[0],\n            timestamps[timestamps.length - 1]\n        ]) // âœ… Use ref as fallback\n        .range([\n            50,\n            width - 50\n        ]);\n        console.log(\"ðŸ“‰ Applying X Scale domain in drawSolveTimeTrend:\", xScale.domain());\n        console.log(\"xScale range:\", xScale.range());\n        const yScale = d3.scaleLinear().domain([\n            d3.max(times),\n            d3.min(times)\n        ]).range([\n            50,\n            height - 50\n        ]);\n        // Add X and Y axes\n        const xAxis = svg.append('g').attr('class', 'x-axis').attr('transform', \"translate(0, \".concat(height - 50, \")\")).call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%H:%M:%S')));\n        // Filter unique days for displaying date below\n        let lastDate = null;\n        xAxis.selectAll('text').attr('dy', '1.2em') // Move time labels up slightly\n        .each(function(d, i, nodes) {\n            const currentText = d3.select(this);\n            const dateStr = d3.timeFormat('%b %d, %Y')(new Date(d));\n            if (dateStr !== lastDate) {\n                currentText.append('tspan').attr('x', 0).attr('dy', '1.2em').text(dateStr);\n                lastDate = dateStr;\n            }\n        });\n        const yAxis = svg.append('g').attr('class', 'y-axis').attr('transform', \"translate(50, 0)\").call(d3.axisLeft(yScale));\n        const gridGroup = svg.append('g').attr('class', 'grid');\n        function drawGrid(xScale, yScale) {\n            gridGroup.selectAll('*').remove();\n            // Horizontal grid lines\n            gridGroup.selectAll('.horizontal-grid').data(yScale.ticks(10)).enter().append('line').attr('class', 'horizontal-grid').attr('x1', 50).attr('x2', width - 50).attr('y1', (d)=>yScale(d)).attr('y2', (d)=>yScale(d)).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n            // Vertical grid lines\n            gridGroup.selectAll('.vertical-grid').data(xScale.ticks(10)).enter().append('line').attr('class', 'vertical-grid').attr('x1', (d)=>xScale(d)).attr('x2', (d)=>xScale(d)).attr('y1', 50).attr('y2', height - 50).attr('stroke', '#ccc').attr('stroke-dasharray', '4,4');\n        }\n        drawGrid(xScale, yScale);\n        const zoom = d3.zoom()// .scaleExtent([0.5, 5])\n        // .translateExtent([[0, 0], [width, height]])\n        .on('zoom', (event)=>{\n            const transform = event.transform;\n            const newXScale = transform.rescaleX(xScale);\n            const newYScale = transform.rescaleY(yScale);\n            console.log(\"Updated xScale domain:\", newXScale.domain());\n            // Update all plots\n            updatePlot(newXScale, newYScale);\n            // Update axes\n            xAxis.call(d3.axisBottom(newXScale).tickFormat(d3.timeFormat('%H:%M:%S')));\n            let lastZoomDate = null;\n            xAxis.selectAll('text').attr('dy', '1.2em').each(function(d, i, nodes) {\n                const currentText = d3.select(this);\n                const dateStr = d3.timeFormat('%b %d, %Y')(new Date(d));\n                if (dateStr !== lastZoomDate) {\n                    currentText.append('tspan').attr('x', 0).attr('dy', '1.2em').text(dateStr);\n                    lastZoomDate = dateStr;\n                }\n            });\n            yAxis.call(d3.axisLeft(newYScale));\n            // Update grid with new scales\n            drawGrid(newXScale, newYScale);\n        });\n        svg.call(zoom);\n        // âœ… Add Legends (Below Autoscale Button)\n        const legend = svg.append('g').attr('transform', \"translate(\".concat(width - 120, \", 100)\")); // â¬‡ Moves legend lower under button\n        const legendItems = [\n            {\n                color: 'blue',\n                label: 'Single'\n            },\n            {\n                color: 'green',\n                label: 'AO5'\n            },\n            {\n                color: 'red',\n                label: 'AO12'\n            }\n        ];\n        legendItems.forEach((item, i)=>{\n            legend.append('rect').attr('x', 0).attr('y', i * 20).attr('width', 15).attr('height', 15).attr('fill', item.color);\n            legend.append('text').attr('x', 20).attr('y', i * 20 + 12).attr('fill', 'black').attr('font-size', '12px').text(item.label);\n        });\n        // Ensure event is passed to autoscale\n        svg.on('dblclick', (event)=>autoscale(event));\n        // Also explicitly disable zoom on double-click to prevent zooming in\n        svg.call(zoom).on(\"dblclick.zoom\", null);\n        function updatePlot(newXScale, newYScale) {\n            console.log(\"ðŸ”„ Updating Plot with New Scales:\");\n            console.log(\"ðŸŸ¢ New X Scale Domain:\", newXScale.domain());\n            console.log(\"ðŸŸ¢ New Y Scale Domain:\", newYScale.domain());\n            // âœ… Ensure that the AO5 and AO12 points are correctly bound\n            const ao5Selection = svg.selectAll('.point-ao5').data(ao5Data, (d)=>d.timestamp).join('circle').attr('class', 'point-ao5').attr('cx', (d)=>xScale(new Date(d.timestamp))) // Align with timestamps\n            .attr('cy', (d)=>yScale(d.value)).attr('r', 5).attr('fill', 'green').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            const ao12Selection = svg.selectAll('.point-ao12').data(ao12Data, (d)=>d.timestamp).join('circle').attr('class', 'point-ao12').attr('cx', (d)=>xScale(new Date(d.timestamp))) // Align with timestamps\n            .attr('cy', (d)=>yScale(d.value)).attr('r', 5).attr('fill', 'red').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            console.log(\"âœ” Total AO5 Points Selected: \".concat(ao5Selection.size(), \" (Expected: \").concat(ao5.length, \")\"));\n            console.log(\"âœ” Total AO12 Points Selected: \".concat(ao12Selection.size(), \" (Expected: \").concat(ao12.length, \")\"));\n            if (ao5Selection.size() === 0) console.warn(\"âš ï¸ No AO5 points found in updatePlot!\");\n            if (ao12Selection.size() === 0) console.warn(\"âš ï¸ No AO12 points found in updatePlot!\");\n            // âœ… Update all AO5 points correctly\n            ao5Selection.attr('cx', (d)=>newXScale(new Date(d.timestamp))).attr('cy', (d)=>newYScale(d.value)); // âœ… Use d.value for AO5\n            // âœ… Update all AO12 points correctly\n            ao12Selection.attr('cx', (d)=>newXScale(new Date(d.timestamp))).attr('cy', (d)=>newYScale(d.value)); // âœ… Use d.value for AO12\n            // âœ… Debugging: Ensure last AO5 & AO12 points update correctly\n            ao5Selection.each(function(d, i) {\n                if (i >= ao5.length - 4) {\n                    console.log(\"\\uD83D\\uDFE2 AO5 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            ao12Selection.each(function(d, i) {\n                if (i >= ao12.length - 12) {\n                    console.log(\"\\uD83D\\uDD34 AO12 Point \".concat(i, \": x=\").concat(newXScale(d.x), \", y=\").concat(newYScale(d.y)));\n                }\n            });\n            // âœ… Update single solve points\n            svg.selectAll('.point-single').data(processedData, (d)=>d.timestamp).join('circle').attr('class', 'point-single').attr('cx', (d)=>newXScale(new Date(d.timestamp))) // FIX: Use newXScale\n            .attr('cy', (d)=>newYScale(d.time)) // FIX: Use newYScale\n            .attr('r', 5).attr('fill', 'blue').on(\"mouseover\", (event, d)=>showTooltip(event, d.timestamp)).on(\"mouseout\", ()=>tooltip.style(\"visibility\", \"hidden\"));\n            // âœ… Update single solve line\n            svg.selectAll('.line-single').attr('d', d3.line().curve(d3.curveMonotoneX).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.time)));\n            // âœ… Ensure AO5 line aligns dynamically\n            svg.selectAll('.line-ao5').datum(ao5.map((val, i)=>({\n                    timestamp: timestamps[i],\n                    value: val\n                }))).attr('d', d3.line().curve(d3.curveMonotoneX).defined((d)=>d.value !== null).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.value)));\n            // âœ… Ensure AO12 line aligns dynamically\n            svg.selectAll('.line-ao12').datum(ao12.map((val, i)=>({\n                    timestamp: timestamps[i],\n                    value: val\n                }))).attr('d', d3.line().curve(d3.curveMonotoneX).defined((d)=>d.value !== null).x((d)=>newXScale(new Date(d.timestamp))).y((d)=>newYScale(d.value)));\n        }\n        svg.append('path').datum(processedData).attr('class', 'line-single').attr('stroke', 'blue').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).x((d)=>xScale(new Date(d.timestamp))).y((d)=>yScale(d.time)));\n        svg.selectAll('.line-ao5').data([\n            ao5\n        ]) // âœ… Use .data([]) instead of .datum()\n        .join(\"path\").attr('class', 'line-ao5').attr('stroke', 'green').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 4 && ao5[i] !== null).x((_, i)=>xScale(new Date(timestamps[i]))) // âœ… Use timestamps\n        .y((_, i)=>yScale(ao5[i])));\n        svg.selectAll('.line-ao12').data([\n            ao12\n        ]) // âœ… Use .data([]) instead of .datum()\n        .join(\"path\").attr('class', 'line-ao12').attr('stroke', 'red').attr('fill', 'none').attr('stroke-width', 2).attr('d', d3.line().curve(d3.curveMonotoneX).defined((_, i)=>i >= 11 && ao12[i] !== null).x((_, i)=>xScale(new Date(timestamps[i]))) // âœ… Use timestamps\n        .y((_, i)=>yScale(ao12[i])));\n        const tooltip = d3.select(containerRef.current).append('div').attr('class', 'absolute bg-white p-2 border rounded shadow text-sm').style('visibility', 'hidden').style('position', 'absolute');\n        function showTooltip(event, timestamp) {\n            if (!timestamp) {\n                console.warn(\"âš ï¸ showTooltip called with invalid timestamp:\", timestamp);\n                return;\n            }\n            // Find all data points with the same timestamp\n            const singleData = processedData.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const ao5DataPoint = ao5Data.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const ao12DataPoint = ao12Data.find((d)=>d.timestamp.getTime() === timestamp.getTime());\n            const singleTime = singleData ? singleData.time.toFixed(2) : \"-\";\n            const ao5Time = ao5DataPoint ? ao5DataPoint.value.toFixed(2) : \"-\";\n            const ao12Time = ao12DataPoint ? ao12DataPoint.value.toFixed(2) : \"-\";\n            console.log(\"\\uD83D\\uDFE2 Showing tooltip for timestamp \".concat(timestamp, \": Single=\").concat(singleTime, \", AO5=\").concat(ao5Time, \", AO12=\").concat(ao12Time));\n            tooltip.html(\"\\n                <div><strong>Single:</strong> \".concat(singleTime, \"s</div>\\n                <div><strong>AO5:</strong> \").concat(ao5Time, \"s</div>\\n                <div><strong>AO12:</strong> \").concat(ao12Time, \"s</div>\\n            \")).style('visibility', 'visible').style('position', 'fixed').style('background', 'white').style('padding', '6px').style('border', '1px solid #ccc').style('border-radius', '5px').style('box-shadow', '2px 2px 10px rgba(0, 0, 0, 0.1)').style('font-size', '12px').style('pointer-events', 'none').style('z-index', '1000').style('transform', 'translate(0, -50%)');\n            tooltip.style('left', \"\".concat(event.pageX + 12, \"px\")).style('top', \"\".concat(event.pageY, \"px\"));\n        }\n        function hideTooltip() {\n            tooltip.style('visibility', 'hidden');\n        }\n        setTimeout(()=>{\n            updatePlot(xScale, yScale); // âœ… Force render after initialization\n        }, 100);\n        function addPoints(data, color, className, valueAccessor, minIndex, label) {\n            // âœ… Ensure that we correctly iterate over the full dataset\n            const validPoints = data.map((val, i)=>({\n                    x: i,\n                    y: valueAccessor(i)\n                })).filter((d)=>d.y !== null && d.x >= minIndex); // âœ… Removed x < times.length constraint\n            console.log(\"\\n\\uD83D\\uDFE2 Adding Points for \".concat(label, \" | Class: \").concat(className, \" | MinIndex: \").concat(minIndex));\n            console.log(\"âœ” Valid Points Count: \".concat(validPoints.length));\n            console.log(\"\\uD83D\\uDCCD First 5 Points:\", validPoints.slice(0, 5));\n            console.log(\"\\uD83D\\uDCCD Last 5 Points:\", validPoints.slice(-5));\n            validPoints.forEach((point, i)=>{\n                console.log(\"\\uD83D\\uDD35 \".concat(label, \" Point \").concat(i + minIndex, \": RawX=\").concat(point.x, \", ScaledX=\").concat(xScale(point.x), \", \") + \"RawY=\".concat(point.y.toFixed(3), \", ScaledY=\").concat(yScale(point.y).toFixed(2)));\n            });\n            // Ensure data binding is done correctly\n            svg.selectAll(\".\".concat(className)).data(validPoints, (d)=>d.x) // Ensure unique key binding\n            .join(\"circle\") // Ensure proper binding\n            .attr('class', \"point \".concat(className)).attr('cx', (d)=>xScale(d.x)).attr('cy', (d)=>yScale(d.y)).attr('r', 5).attr('fill', color);\n        }\n        // âœ… Ensure AO5 & AO12 points are fully added before updating\n        addPoints(times, 'blue', 'point-single', (i)=>times[i], 0, \"Single\");\n        addPoints(ao5, 'green', 'point-ao5', (i)=>ao5[i], 4, \"AO5\");\n        addPoints(ao12, 'red', 'point-ao12', (i)=>ao12[i], 11, \"AO12\");\n        const controls = d3.select(containerRef.current).append('div').attr('class', 'absolute top-2 right-2 bg-white p-2 rounded shadow flex space-x-4'); // Horizontal layout with spacing\n        // Previous Cluster Button\n        controls.append('button').html('<img src=\"/dataVis-previous.svg\" alt=\"Previous\" width=\"24\" height=\"24\">').style('margin', '5px') // Adds spacing around the button\n        .attr('disabled', clusters.length === 0 || currentClusterIndex === 0 ? 'disabled' : null).on('click', prevCluster);\n        // Next Cluster Button\n        controls.append('button').html('<img src=\"/dataVis-next.svg\" alt=\"Next\" width=\"24\" height=\"24\">').style('margin', '5px').attr('disabled', clusters.length === 0 || currentClusterIndex >= clusters.length - 1 ? 'disabled' : null).on('click', nextCluster);\n        // Autoscale Button\n        controls.append('button').html('<img src=\"/dataVis-resize-scaling.svg\" alt=\"Autoscale\" width=\"24\" height=\"24\">').style('margin', '5px').on('click', autoscale);\n        // Switch to Time View Button\n        controls.append('button').html('<img src=\"/dataVis-switch.svg\" alt=\"Switch View\" width=\"24\" height=\"24\">').style('margin', '5px').on('click', ()=>setShowIndexView(true));\n    }\n    function autoscale() {\n        console.log(\"ðŸ” Autoscale triggered...\");\n        if (!clusters || clusters.length === 0) {\n            console.warn(\"âš ï¸ No clusters available for autoscale!\");\n            return;\n        }\n        console.log(\"ðŸ“Œ Autoscaling to first cluster...\");\n        setCurrentClusterIndex(0);\n        const firstCluster = clusters[0];\n        if (!firstCluster || firstCluster.length === 0) {\n            console.warn(\"âš ï¸ First cluster is empty, cannot autoscale!\");\n            return;\n        }\n        const newDomain = [\n            new Date(firstCluster[0].timestamp),\n            new Date(firstCluster.slice(-1)[0].timestamp)\n        ];\n        console.log(\"âœ… Setting autoscale X-Domain to:\", newDomain);\n        setXDomain(newDomain);\n        xDomainRef.current = newDomain;\n        // âœ… Force React to update UI state\n        setTimeout(()=>{\n            setClusters([\n                ...clusters\n            ]); // Force re-evaluation of clusters state\n        }, 0);\n    }\n    function nextCluster() {\n        console.log(\"âž¡ï¸ Next cluster clicked...\");\n        if (currentClusterIndex < clusters.length - 1) {\n            const nextIndex = currentClusterIndex + 1;\n            console.log(\"ðŸ“Œ Moving to next cluster:\", nextIndex);\n            setCurrentClusterIndex(nextIndex);\n            const newDomain = [\n                new Date(clusters[nextIndex][0].timestamp),\n                new Date(clusters[nextIndex].slice(-1)[0].timestamp)\n            ];\n            setXDomain(newDomain);\n            xDomainRef.current = newDomain;\n        } else {\n            console.warn(\"âš ï¸ No next cluster available!\");\n        }\n    }\n    function prevCluster() {\n        console.log(\"â¬…ï¸ Previous cluster clicked...\");\n        if (currentClusterIndex > 0) {\n            const prevIndex = currentClusterIndex - 1;\n            console.log(\"ðŸ“Œ Moving to previous cluster:\", prevIndex);\n            setCurrentClusterIndex(prevIndex);\n            const newDomain = [\n                new Date(clusters[prevIndex][0].timestamp),\n                new Date(clusters[prevIndex].slice(-1)[0].timestamp)\n            ];\n            setXDomain(newDomain);\n            xDomainRef.current = newDomain;\n        } else {\n            console.warn(\"âš ï¸ No previous cluster available!\");\n        }\n    }\n    // return (\n    //     <div className=\"w-screen h-[calc(100vh-100px)] bg-white relative\">\n    //         {/* âœ… Chart container */}\n    //         <div ref={containerRef} className=\"w-full h-full\"></div>\n    //\n    //         {/* âœ… Controls Section */}\n    //         <div className=\"absolute top-2 right-2 bg-white p-2 rounded shadow flex space-x-2\">\n    //             <button\n    //                 className=\"px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\"\n    //                 disabled={clusters.length === 0 || currentClusterIndex === 0}\n    //                 onClick={() => prevCluster()}\n    //             >\n    //                 Previous Cluster\n    //             </button>\n    //\n    //             <button\n    //                 className=\"px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\"\n    //                 disabled={clusters.length === 0 || currentClusterIndex >= clusters.length - 1}\n    //                 onClick={() => nextCluster()}\n    //             >\n    //                 Next Cluster\n    //             </button>\n    //\n    //             <button\n    //                 className=\"px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\"\n    //                 onClick={() => autoscale()}\n    //             >\n    //                 Autoscale\n    //             </button>\n    //\n    //             {/* âœ… Switch button to go to TrendAnaTime.js */}\n    //             <button\n    //                 className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-700\"\n    //                 onClick={() => setShowIndexView(true)}\n    //             >\n    //                 Switch to Time View\n    //             </button>\n    //         </div>\n    //     </div>\n    // );\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-screen h-[calc(100vh-100px)] bg-white relative\"\n    }, void 0, false, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\TrendAnaTime.js\",\n        lineNumber: 729,\n        columnNumber: 9\n    }, this);\n}\n_s(SolveTimeTrend, \"Q25XOb70ZXebfFN2RMbglhBYjRA=\");\n_c = SolveTimeTrend;\nvar _c;\n$RefreshReg$(_c, \"SolveTimeTrend\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9UcmVuZEFuYVRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVvRDtBQUNSO0FBQzVDLE1BQU1JLEtBQUssTUFBTSw0TUFBWTtBQUVkLFNBQVNDLGVBQWUsS0FBVTtRQUFWLEVBQUVDLE1BQU0sRUFBRSxHQUFWOztJQUNuQyxNQUFNQyxlQUFlTiw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNLENBQUNPLHFCQUFxQkMsdUJBQXVCLEdBQUdQLCtDQUFRQSxDQUFDO0lBQy9ELE1BQU0sQ0FBQ1EsVUFBVUMsWUFBWSxHQUFHVCwrQ0FBUUEsQ0FBQyxFQUFFO0lBQzNDLE1BQU0sQ0FBQ1UsU0FBU0MsV0FBVyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNWSxhQUFhYiw2Q0FBTUEsQ0FBQztJQUUxQixvRUFBb0U7SUFDcEUsTUFBTSxDQUFDYyxlQUFlQyxpQkFBaUIsR0FBR2QsK0NBQVFBLENBQUM7SUFFbkRGLGdEQUFTQTtvQ0FBQztZQUNOaUIsUUFBUUMsR0FBRyxDQUFDLHNDQUFzQ047WUFFbEQsSUFBSSxDQUFDTixVQUFVQSxPQUFPYSxNQUFNLEtBQUssR0FBRztnQkFDaENGLFFBQVFHLElBQUksQ0FBQztnQkFDYjtZQUNKO1lBRUEsTUFBTUMsWUFBWWQsYUFBYWUsT0FBTztZQUN0QyxJQUFJLENBQUNELFdBQVc7Z0JBQ1pKLFFBQVFHLElBQUksQ0FBQztnQkFDYjtZQUNKO1lBRUFILFFBQVFDLEdBQUcsQ0FBQztZQUNaSyxtQkFBbUJqQjtRQUN2QjttQ0FBRztRQUFDTTtRQUFTTDtLQUFhLEdBQUksaUVBQWlFO0lBRS9GUCxnREFBU0E7b0NBQUM7WUFDTixJQUFJLENBQUNNLFVBQVUsQ0FBQ2tCLE1BQU1DLE9BQU8sQ0FBQ25CLFdBQVdBLE9BQU9hLE1BQU0sS0FBSyxHQUFHO1lBRTlERixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNUSxtQkFBbUJDLGFBQWFyQjtZQUN0Q0ssWUFB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Qyx3QkFBd0I7SUFDeEIsRUFBRTtJQUNGLHNCQUFzQjtJQUN0Qiw4RUFBOEU7SUFDOUUsaUdBQWlHO0lBQ2pHLGdEQUFnRDtJQUNoRCxnQkFBZ0I7SUFDaEIsK0JBQStCO0lBQy9CLHdCQUF3QjtJQUN4QixFQUFFO0lBQ0Ysc0JBQXNCO0lBQ3RCLDhFQUE4RTtJQUM5RSw4Q0FBOEM7SUFDOUMsZ0JBQWdCO0lBQ2hCLDRCQUE0QjtJQUM1Qix3QkFBd0I7SUFDeEIsRUFBRTtJQUNGLCtEQUErRDtJQUMvRCxzQkFBc0I7SUFDdEIseUZBQXlGO0lBQ3pGLHlEQUF5RDtJQUN6RCxnQkFBZ0I7SUFDaEIsc0NBQXNDO0lBQ3RDLHdCQUF3QjtJQUN4QixpQkFBaUI7SUFDakIsYUFBYTtJQUNiLEtBQUs7SUFFTCxxQkFDSSw4REFBQzRJO1FBQ0dDLEtBQUsxSjtRQUNMK0ksV0FBVTs7Ozs7O0FBR3RCO0dBdnRCd0JqSjtLQUFBQSIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxTclxcMjAyNF9DX1Rlcm1cXENTNDI0MVxcSFdcXGZpbmFsLXByb2plY3Qta2VybWl0LXRoZS1mcm9nXFxzcmNcXGFwcFxcZGF0YVZpc1xcVHJlbmRBbmFUaW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFRyZW5kQW5hSW5kZXggZnJvbSAnLi9UcmVuZEFuYUluZGV4JztcclxuY29uc3QgZDMgPSBhd2FpdCBpbXBvcnQoJ2QzJyk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTb2x2ZVRpbWVUcmVuZCh7IHNvbHZlcyB9KSB7XHJcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBbY3VycmVudENsdXN0ZXJJbmRleCwgc2V0Q3VycmVudENsdXN0ZXJJbmRleF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtjbHVzdGVycywgc2V0Q2x1c3RlcnNdID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgW3hEb21haW4sIHNldFhEb21haW5dID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCB4RG9tYWluUmVmID0gdXNlUmVmKG51bGwpO1xyXG5cclxuICAgIC8vIOKchSBTdGF0ZSB0byB0cmFjayB3aGV0aGVyIHdlIGFyZSBpbiBTb2x2ZVRpbWVUcmVuZCBvciBUcmVuZEFuYVRpbWVcclxuICAgIGNvbnN0IFtzaG93SW5kZXhWaWV3LCBzZXRTaG93SW5kZXhWaWV3XSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBYRG9tYWluIG9yIHdpbmRvdyBzaXplIHVwZGF0ZWQ6XCIsIHhEb21haW4pO1xyXG5cclxuICAgICAgICBpZiAoIXNvbHZlcyB8fCBzb2x2ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBzb2x2ZXMgZGF0YSBhdmFpbGFibGUhXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gQ29udGFpbmVyIHJlZmVyZW5jZSBpcyBudWxsIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OPIFVwZGF0aW5nIGNoYXJ0IGRpbWVuc2lvbnMgYWZ0ZXIgcmVzaXplLi4uXCIpO1xyXG4gICAgICAgIGRyYXdTb2x2ZVRpbWVUcmVuZChzb2x2ZXMpO1xyXG4gICAgfSwgW3hEb21haW4sIGNvbnRhaW5lclJlZl0pOyAgLy8g8J+UpSBFbnN1cmUgY2hhcnQgdXBkYXRlcyB3aGVuIHhEb21haW4gb3IgY29udGFpbmVyIHNpemUgY2hhbmdlc1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzb2x2ZXMgfHwgIUFycmF5LmlzQXJyYXkoc29sdmVzKSB8fCBzb2x2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBSdW5uaW5nIGNsdXN0ZXIgZGV0ZWN0aW9uLi4uXCIpO1xyXG4gICAgICAgIGNvbnN0IGRldGVjdGVkQ2x1c3RlcnMgPSBmaW5kQ2x1c3RlcnMoc29sdmVzKTtcclxuICAgICAgICBzZXRDbHVzdGVycyhkZXRlY3RlZENsdXN0ZXJzKTtcclxuXHJcbiAgICAgICAgaWYgKGRldGVjdGVkQ2x1c3RlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdENsdXN0ZXIgPSBkZXRlY3RlZENsdXN0ZXJzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdEb21haW4gPSBbXHJcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShmaXJzdENsdXN0ZXJbMF0udGltZXN0YW1wKSxcclxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGZpcnN0Q2x1c3Rlci5zbGljZSgtMSlbMF0udGltZXN0YW1wKVxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgc2V0WERvbWFpbihuZXdEb21haW4pO1xyXG4gICAgICAgICAgICB4RG9tYWluUmVmLmN1cnJlbnQgPSBuZXdEb21haW47ICAvLyDinIUgRW5zdXJlIHJlZiBpcyB1cGRhdGVkXHJcblxyXG4gICAgICAgICAgICAvLyDinZcgTG9nIEFGVEVSIHNldHRpbmcgdGhlIHN0YXRlIHRvIHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLinIUgWC1Eb21haW4gaW5pdGlhbGl6ZWQgdG8gZmlyc3QgY2x1c3RlcjpcIiwgbmV3RG9tYWluKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF0dGFjaCByZXNpemUgZXZlbnRcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICB9LCBbc29sdmVzXSk7ICAvLyA8LS0gUnVucyBvbmx5IG9uIGZpcnN0IGxvYWRcclxuXHJcbiAgICBpZiAoc2hvd0luZGV4Vmlldykge1xyXG4gICAgICAgIHJldHVybiA8VHJlbmRBbmFJbmRleCBzb2x2ZXM9e3NvbHZlc30gLz47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UhCBIYW5kbGluZyByZXNpemUuLi5cIik7XHJcblxyXG4gICAgICAgIGlmICghc29sdmVzIHx8IHNvbHZlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIHNvbHZlcyBhdmFpbGFibGUsIHNraXBwaW5nIHJlc2l6ZSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkZXRlY3RlZENsdXN0ZXJzID0gY2x1c3RlcnM7XHJcblxyXG4gICAgICAgIGlmIChjbHVzdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIGNsdXN0ZXJzIGF2YWlsYWJsZSBvbiByZXNpemUhIFJlZmluZGluZyBjbHVzdGVycy4uLlwiKTtcclxuICAgICAgICAgICAgZGV0ZWN0ZWRDbHVzdGVycyA9IGZpbmRDbHVzdGVycyhzb2x2ZXMpO1xyXG4gICAgICAgICAgICBzZXRDbHVzdGVycyhkZXRlY3RlZENsdXN0ZXJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZXRlY3RlZENsdXN0ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gU3RpbGwgbm8gY2x1c3RlcnMgZm91bmQgYWZ0ZXIgcmVzaXplIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJldkNsdXN0ZXJJbmRleCA9IGN1cnJlbnRDbHVzdGVySW5kZXg7XHJcbiAgICAgICAgY29uc3QgcHJldlhEb21haW4gPSB4RG9tYWluUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OMIFByZXNlcnZpbmcgQ2x1c3RlciBJbmRleDogJHtwcmV2Q2x1c3RlckluZGV4fWApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBQcmVzZXJ2aW5nIFgtRG9tYWluIGJlZm9yZSByZXNpemU6XCIsIHByZXZYRG9tYWluKTtcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIHJlLXJlbmRlcnMgd2l0aCBjb3JyZWN0IHN0YXRlc1xyXG4gICAgICAgIHNldEN1cnJlbnRDbHVzdGVySW5kZXgocHJldkNsdXN0ZXJJbmRleCk7XHJcbiAgICAgICAgc2V0WERvbWFpbihwcmV2WERvbWFpbik7XHJcbiAgICAgICAgeERvbWFpblJlZi5jdXJyZW50ID0gcHJldlhEb21haW47XHJcblxyXG4gICAgICAgIC8vIOKchSBGb3JjZSBzdGF0ZSB1cGRhdGVzIHRvIHJlLWVuYWJsZSBidXR0b25zXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldENsdXN0ZXJzKFsuLi5kZXRlY3RlZENsdXN0ZXJzXSk7XHJcbiAgICAgICAgICAgIHNldFhEb21haW4oWy4uLnByZXZYRG9tYWluXSk7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRDbHVzdGVySW5kZXgocHJldkNsdXN0ZXJJbmRleCk7XHJcbiAgICAgICAgfSwgMCk7XHJcblxyXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgY2hhcnQgYWZ0ZXIgcmVzaXplXHJcbiAgICAgICAgZHJhd1NvbHZlVGltZVRyZW5kKHNvbHZlcyk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFJlc2l6ZSBoYW5kbGVkLCByZXN0b3Jpbmcgc3RhdGVzLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaW5kQ2x1c3RlcnMoZGF0YSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBSdW5uaW5nIGZpbmRDbHVzdGVycy4uLlwiKTtcclxuXHJcbiAgICAgICAgbGV0IGRldGVjdGVkQ2x1c3RlcnMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudENsdXN0ZXIgPSBbZGF0YVswXV07XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobmV3IERhdGUoZGF0YVtpXS50aW1lc3RhbXApIC0gbmV3IERhdGUoZGF0YVtpIC0gMV0udGltZXN0YW1wKSA+IDE1ICogNjAgKiAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENsdXN0ZXIubGVuZ3RoID4gMSkgeyAgLy8g4pyFIElnbm9yZSBjbHVzdGVycyB3aXRoIGEgc2luZ2xlIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlWFZhbHVlcyA9IG5ldyBTZXQoY3VycmVudENsdXN0ZXIubWFwKGQgPT4gZC50aW1lc3RhbXApKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodW5pcXVlWFZhbHVlcy5zaXplID4gMSkgeyAgLy8g4pyFIElnbm9yZSBjbHVzdGVycyB3aXRoIHRoZSBzYW1lIFgtQXhpcyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZENsdXN0ZXJzLnB1c2goY3VycmVudENsdXN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBJZ25vcmluZyBjbHVzdGVyIHdpdGggc2FtZSBYLUF4aXMgdmFsdWVzOlwiLCBjdXJyZW50Q2x1c3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudENsdXN0ZXIgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50Q2x1c3Rlci5wdXNoKGRhdGFbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgbGFzdCBjbHVzdGVyIGJlZm9yZSBhZGRpbmcgaXRcclxuICAgICAgICBpZiAoY3VycmVudENsdXN0ZXIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVYVmFsdWVzID0gbmV3IFNldChjdXJyZW50Q2x1c3Rlci5tYXAoZCA9PiBkLnRpbWVzdGFtcCkpO1xyXG4gICAgICAgICAgICBpZiAodW5pcXVlWFZhbHVlcy5zaXplID4gMSkge1xyXG4gICAgICAgICAgICAgICAgZGV0ZWN0ZWRDbHVzdGVycy5wdXNoKGN1cnJlbnRDbHVzdGVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBJZ25vcmluZyBjbHVzdGVyIHdpdGggc2FtZSBYLUF4aXMgdmFsdWVzOlwiLCBjdXJyZW50Q2x1c3Rlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TiiBDbHVzdGVycyBpZGVudGlmaWVkIChleGNsdWRpbmcgc2luZ2xlL3NhbWUgeC1heGlzIGNsdXN0ZXJzKTpcIiwgZGV0ZWN0ZWRDbHVzdGVycy5sZW5ndGgsIGRldGVjdGVkQ2x1c3RlcnMpO1xyXG4gICAgICAgIHJldHVybiBkZXRlY3RlZENsdXN0ZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVSb2xsaW5nQXZlcmFnZShkYXRhLCB3aW5kb3dTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChfLCBpLCBhcnIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGkgPCB3aW5kb3dTaXplIC0gMSkgcmV0dXJuIG51bGw7ICAvLyDinIUgUHJlc2VydmUgbnVsbHMgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICBjb25zdCBzdWJzZXQgPSBhcnIuc2xpY2UoaSAtICh3aW5kb3dTaXplIC0gMSksIGkgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnNldC5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gc3Vic2V0Lmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U29sdmVUaW1lVHJlbmQoZGF0YSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBDdXJyZW50IFgtRG9tYWluIGluIGRyYXdTb2x2ZVRpbWVUcmVuZDpcIiwgeERvbWFpblJlZi5jdXJyZW50KTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KXtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIENvbnRhaW5lciByZWZlcmVuY2UgaXMgbnVsbCwgY2Fubm90IGRyYXchXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0IHx8IDUwMDtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OPIENoYXJ0IGRpbWVuc2lvbnM6XCIsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXIuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMTAwJScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKVxyXG4gICAgICAgICAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBhbGwgZGF0YSBjb250YWlucyB0aW1lc3RhbXBzXHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IGRhdGFcclxuICAgICAgICAgICAgLm1hcChzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNvbHZlLnRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBTa2lwcGluZyBlbnRyeSB3aXRoIG1pc3NpbmcgdGltZXN0YW1wOlwiLCBzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoc29sdmUudGltZXN0YW1wKSxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBzb2x2ZS50aW1lIC8gMTAwMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihkID0+IGQgIT09IG51bGwpOyAgLy8gUmVtb3ZlIGludmFsaWQgZW50cmllc1xyXG5cclxuICAgICAgICBjb25zdCB0aW1lc3RhbXBzID0gcHJvY2Vzc2VkRGF0YS5tYXAoZCA9PiBkLnRpbWVzdGFtcCk7XHJcbiAgICAgICAgY29uc3QgdGltZXMgPSBwcm9jZXNzZWREYXRhLm1hcChkID0+IGQudGltZSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2VkIHRpbWVzdGFtcHM6XCIsIHRpbWVzdGFtcHMpO1xyXG5cclxuICAgICAgICAvLyDwn5SlIEZpbmQgdGhlIGZpcnN0IFwiY2x1c3RlclwiIChhIHNob3J0IGludGVydmFsIG9mIGRhdGEpXHJcbiAgICAgICAgbGV0IGNsdXN0ZXJTdGFydEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgY2x1c3RlckVuZEluZGV4ID0gdGltZXN0YW1wcy5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRpbWVzdGFtcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbaV0gLSB0aW1lc3RhbXBzWzBdID4gMTUgKiA2MCAqIDEwMDApIHsgLy8gMTUtbWludXRlIHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgY2x1c3RlckVuZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBjbHVzdGVyIHRpbWUgcmFuZ2VcclxuICAgICAgICBjb25zdCBpbml0aWFsWERvbWFpbiA9IFtcclxuICAgICAgICAgICAgdGltZXN0YW1wc1tjbHVzdGVyU3RhcnRJbmRleF0sXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcHNbY2x1c3RlckVuZEluZGV4XVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDij7MgSW5pdGlhbCBGb2N1cyBYIERvbWFpbjogJHtpbml0aWFsWERvbWFpblswXX0gdG8gJHtpbml0aWFsWERvbWFpblsxXX1gKTtcclxuXHJcbiAgICAgICAgY29uc3QgYW81ID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCA1KTtcclxuICAgICAgICBjb25zdCBhbzEyID0gY29tcHV0ZVJvbGxpbmdBdmVyYWdlKHRpbWVzLCAxMik7XHJcblxyXG4gICAgICAgIGNvbnN0IGFvNURhdGEgPSB0aW1lc3RhbXBzLm1hcCgodGltZXN0YW1wLCBpKSA9PiAoe1xyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgdmFsdWU6IGFvNVtpXSAhPT0gbnVsbCA/IGFvNVtpXSA6IG51bGxcclxuICAgICAgICB9KSkuZmlsdGVyKGQgPT4gZC52YWx1ZSAhPT0gbnVsbCk7IC8vIFJlbW92ZSBpbml0aWFsIG51bGxzXHJcblxyXG4gICAgICAgIGNvbnN0IGFvMTJEYXRhID0gdGltZXN0YW1wcy5tYXAoKHRpbWVzdGFtcCwgaSkgPT4gKHtcclxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIHZhbHVlOiBhbzEyW2ldICE9PSBudWxsID8gYW8xMltpXSA6IG51bGxcclxuICAgICAgICB9KSkuZmlsdGVyKGQgPT4gZC52YWx1ZSAhPT0gbnVsbCk7IC8vIFJlbW92ZSBpbml0aWFsIG51bGxzXHJcblxyXG4gICAgICAgIC8vIFggU2NhbGU6IFN0YXJ0IHpvb21lZCBpbnRvIHRoZSBpZGVudGlmaWVkIGNsdXN0ZXJcclxuICAgICAgICBsZXQgeFNjYWxlID0gZDMuc2NhbGVUaW1lKClcclxuICAgICAgICAgICAgLmRvbWFpbih4RG9tYWluUmVmLmN1cnJlbnQgPz8gW3RpbWVzdGFtcHNbMF0sIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXV0pICAvLyDinIUgVXNlIHJlZiBhcyBmYWxsYmFja1xyXG4gICAgICAgICAgICAucmFuZ2UoWzUwLCB3aWR0aCAtIDUwXSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TiSBBcHBseWluZyBYIFNjYWxlIGRvbWFpbiBpbiBkcmF3U29sdmVUaW1lVHJlbmQ6XCIsIHhTY2FsZS5kb21haW4oKSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJ4U2NhbGUgcmFuZ2U6XCIsIHhTY2FsZS5yYW5nZSgpKTtcclxuXHJcbiAgICAgICAgY29uc3QgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFtkMy5tYXgodGltZXMpLCBkMy5taW4odGltZXMpXSlcclxuICAgICAgICAgICAgLnJhbmdlKFs1MCwgaGVpZ2h0IC0gNTBdKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIFggYW5kIFkgYXhlc1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd4LWF4aXMnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke2hlaWdodCAtIDUwfSlgKVxyXG4gICAgICAgICAgICAuY2FsbChkMy5heGlzQm90dG9tKHhTY2FsZSkudGlja0Zvcm1hdChkMy50aW1lRm9ybWF0KCclSDolTTolUycpKSk7XHJcblxyXG4gICAgICAgIC8vIEZpbHRlciB1bmlxdWUgZGF5cyBmb3IgZGlzcGxheWluZyBkYXRlIGJlbG93XHJcbiAgICAgICAgbGV0IGxhc3REYXRlID0gbnVsbDtcclxuICAgICAgICB4QXhpcy5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnMS4yZW0nKSAvLyBNb3ZlIHRpbWUgbGFiZWxzIHVwIHNsaWdodGx5XHJcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsIGksIG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVTdHIgPSBkMy50aW1lRm9ybWF0KCclYiAlZCwgJVknKShuZXcgRGF0ZShkKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVN0ciAhPT0gbGFzdERhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dC5hcHBlbmQoJ3RzcGFuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMS4yZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dChkYXRlU3RyKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RGF0ZSA9IGRhdGVTdHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB5QXhpcyA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneS1heGlzJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoNTAsIDApYClcclxuICAgICAgICAgICAgLmNhbGwoZDMuYXhpc0xlZnQoeVNjYWxlKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGdyaWRHcm91cCA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdncmlkJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdHcmlkKHhTY2FsZSwgeVNjYWxlKSB7XHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgZ3JpZCBsaW5lc1xyXG4gICAgICAgICAgICBncmlkR3JvdXAuc2VsZWN0QWxsKCcuaG9yaXpvbnRhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHlTY2FsZS50aWNrcygxMCkpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaG9yaXpvbnRhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGggLSA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGQgPT4geVNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgZCA9PiB5U2NhbGUoZCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAnNCw0Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJ0aWNhbCBncmlkIGxpbmVzXHJcbiAgICAgICAgICAgIGdyaWRHcm91cC5zZWxlY3RBbGwoJy52ZXJ0aWNhbC1ncmlkJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHhTY2FsZS50aWNrcygxMCkpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndmVydGljYWwtZ3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBkID0+IHhTY2FsZShkKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGQgPT4geFNjYWxlKGQpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgNTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBoZWlnaHQgLSA1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnI2NjYycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICc0LDQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRyYXdHcmlkKHhTY2FsZSwgeVNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgem9vbSA9IGQzLnpvb20oKVxyXG4gICAgICAgICAgICAvLyAuc2NhbGVFeHRlbnQoWzAuNSwgNV0pXHJcbiAgICAgICAgICAgIC8vIC50cmFuc2xhdGVFeHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcclxuICAgICAgICAgICAgLm9uKCd6b29tJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdYU2NhbGUgPSB0cmFuc2Zvcm0ucmVzY2FsZVgoeFNjYWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1lTY2FsZSA9IHRyYW5zZm9ybS5yZXNjYWxlWSh5U2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRlZCB4U2NhbGUgZG9tYWluOlwiLCBuZXdYU2NhbGUuZG9tYWluKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgcGxvdHNcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVBsb3QobmV3WFNjYWxlLCBuZXdZU2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBheGVzXHJcbiAgICAgICAgICAgICAgICB4QXhpcy5jYWxsKGQzLmF4aXNCb3R0b20obmV3WFNjYWxlKS50aWNrRm9ybWF0KGQzLnRpbWVGb3JtYXQoJyVIOiVNOiVTJykpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFpvb21EYXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHhBeGlzLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzEuMmVtJylcclxuICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkLCBpLCBub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IGQzLnRpbWVGb3JtYXQoJyViICVkLCAlWScpKG5ldyBEYXRlKGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVTdHIgIT09IGxhc3Rab29tRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQuYXBwZW5kKCd0c3BhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcxLjJlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZGF0ZVN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Wm9vbURhdGUgPSBkYXRlU3RyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB5QXhpcy5jYWxsKGQzLmF4aXNMZWZ0KG5ld1lTY2FsZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBncmlkIHdpdGggbmV3IHNjYWxlc1xyXG4gICAgICAgICAgICAgICAgZHJhd0dyaWQobmV3WFNjYWxlLCBuZXdZU2NhbGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc3ZnLmNhbGwoem9vbSk7XHJcblxyXG4gICAgICAgIC8vIOKchSBBZGQgTGVnZW5kcyAoQmVsb3cgQXV0b3NjYWxlIEJ1dHRvbilcclxuICAgICAgICBjb25zdCBsZWdlbmQgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt3aWR0aCAtIDEyMH0sIDEwMClgKTsgLy8g4qyHIE1vdmVzIGxlZ2VuZCBsb3dlciB1bmRlciBidXR0b25cclxuXHJcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbXMgPSBbXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdibHVlJywgbGFiZWw6ICdTaW5nbGUnIH0sXHJcbiAgICAgICAgICAgIHsgY29sb3I6ICdncmVlbicsIGxhYmVsOiAnQU81JyB9LFxyXG4gICAgICAgICAgICB7IGNvbG9yOiAncmVkJywgbGFiZWw6ICdBTzEyJyB9XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgbGVnZW5kSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZWdlbmQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgaSAqIDIwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGl0ZW0uY29sb3IpO1xyXG5cclxuICAgICAgICAgICAgbGVnZW5kLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDIwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBpICogMjAgKyAxMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2JsYWNrJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnMTJweCcpXHJcbiAgICAgICAgICAgICAgICAudGV4dChpdGVtLmxhYmVsKTtcclxuICAgICAgICB9KTtcclxuXHJcbi8vIEVuc3VyZSBldmVudCBpcyBwYXNzZWQgdG8gYXV0b3NjYWxlXHJcbiAgICAgICAgc3ZnLm9uKCdkYmxjbGljaycsIChldmVudCkgPT4gYXV0b3NjYWxlKGV2ZW50KSk7XHJcblxyXG4vLyBBbHNvIGV4cGxpY2l0bHkgZGlzYWJsZSB6b29tIG9uIGRvdWJsZS1jbGljayB0byBwcmV2ZW50IHpvb21pbmcgaW5cclxuICAgICAgICBzdmcuY2FsbCh6b29tKS5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBsb3QobmV3WFNjYWxlLCBuZXdZU2NhbGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5SEIFVwZGF0aW5nIFBsb3Qgd2l0aCBOZXcgU2NhbGVzOlwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5+iIE5ldyBYIFNjYWxlIERvbWFpbjpcIiwgbmV3WFNjYWxlLmRvbWFpbigpKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5+iIE5ldyBZIFNjYWxlIERvbWFpbjpcIiwgbmV3WVNjYWxlLmRvbWFpbigpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgdGhhdCB0aGUgQU81IGFuZCBBTzEyIHBvaW50cyBhcmUgY29ycmVjdGx5IGJvdW5kXHJcbiAgICAgICAgICAgIGNvbnN0IGFvNVNlbGVjdGlvbiA9IHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1hbzUnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoYW81RGF0YSwgZCA9PiBkLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgICAgIC5qb2luKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50LWFvNScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IHhTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKSAgLy8gQWxpZ24gd2l0aCB0aW1lc3RhbXBzXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IHlTY2FsZShkLnZhbHVlKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2dyZWVuJylcclxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZXZlbnQsIGQpID0+IHNob3dUb29sdGlwKGV2ZW50LCBkLnRpbWVzdGFtcCkpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoKSA9PiB0b29sdGlwLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhbzEyU2VsZWN0aW9uID0gc3ZnLnNlbGVjdEFsbCgnLnBvaW50LWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoYW8xMkRhdGEsIGQgPT4gZC50aW1lc3RhbXApXHJcbiAgICAgICAgICAgICAgICAuam9pbignY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwb2ludC1hbzEyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4geFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpICAvLyBBbGlnbiB3aXRoIHRpbWVzdGFtcHNcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4geVNjYWxlKGQudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAncmVkJylcclxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZXZlbnQsIGQpID0+IHNob3dUb29sdGlwKGV2ZW50LCBkLnRpbWVzdGFtcCkpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoKSA9PiB0b29sdGlwLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFRvdGFsIEFPNSBQb2ludHMgU2VsZWN0ZWQ6ICR7YW81U2VsZWN0aW9uLnNpemUoKX0gKEV4cGVjdGVkOiAke2FvNS5sZW5ndGh9KWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyUIFRvdGFsIEFPMTIgUG9pbnRzIFNlbGVjdGVkOiAke2FvMTJTZWxlY3Rpb24uc2l6ZSgpfSAoRXhwZWN0ZWQ6ICR7YW8xMi5sZW5ndGh9KWApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFvNVNlbGVjdGlvbi5zaXplKCkgPT09IDApIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBBTzUgcG9pbnRzIGZvdW5kIGluIHVwZGF0ZVBsb3QhXCIpO1xyXG4gICAgICAgICAgICBpZiAoYW8xMlNlbGVjdGlvbi5zaXplKCkgPT09IDApIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBBTzEyIHBvaW50cyBmb3VuZCBpbiB1cGRhdGVQbG90IVwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBVcGRhdGUgYWxsIEFPNSBwb2ludHMgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIGFvNVNlbGVjdGlvbi5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnZhbHVlKSk7IC8vIOKchSBVc2UgZC52YWx1ZSBmb3IgQU81XHJcblxyXG4gICAgICAgICAgICAvLyDinIUgVXBkYXRlIGFsbCBBTzEyIHBvaW50cyBjb3JyZWN0bHlcclxuICAgICAgICAgICAgYW8xMlNlbGVjdGlvbi5hdHRyKCdjeCcsIGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBkID0+IG5ld1lTY2FsZShkLnZhbHVlKSk7IC8vIOKchSBVc2UgZC52YWx1ZSBmb3IgQU8xMlxyXG5cclxuICAgICAgICAgICAgLy8g4pyFIERlYnVnZ2luZzogRW5zdXJlIGxhc3QgQU81ICYgQU8xMiBwb2ludHMgdXBkYXRlIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBhbzVTZWxlY3Rpb24uZWFjaChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYW81Lmxlbmd0aCAtIDQpIHsgLy8gVXNlIGBhbzUubGVuZ3RoYCB0byBjb3JyZWN0bHkgaXRlcmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5+iIEFPNSBQb2ludCAke2l9OiB4PSR7bmV3WFNjYWxlKGQueCl9LCB5PSR7bmV3WVNjYWxlKGQueSl9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYW8xMlNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhbzEyLmxlbmd0aCAtIDEyKSB7IC8vIFVzZSBgYW8xMi5sZW5ndGhgIHRvIGNvcnJlY3RseSBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflLQgQU8xMiBQb2ludCAke2l9OiB4PSR7bmV3WFNjYWxlKGQueCl9LCB5PSR7bmV3WVNjYWxlKGQueSl9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBzaW5nbGUgc29sdmUgcG9pbnRzXHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5wb2ludC1zaW5nbGUnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocHJvY2Vzc2VkRGF0YSwgZCA9PiBkLnRpbWVzdGFtcClcclxuICAgICAgICAgICAgICAgIC5qb2luKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50LXNpbmdsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IG5ld1hTY2FsZShuZXcgRGF0ZShkLnRpbWVzdGFtcCkpKSAvLyBGSVg6IFVzZSBuZXdYU2NhbGVcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4gbmV3WVNjYWxlKGQudGltZSkpIC8vIEZJWDogVXNlIG5ld1lTY2FsZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmx1ZScpXHJcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGV2ZW50LCBkKSA9PiBzaG93VG9vbHRpcChldmVudCwgZC50aW1lc3RhbXApKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKCkgPT4gdG9vbHRpcC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikpO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIFVwZGF0ZSBzaW5nbGUgc29sdmUgbGluZVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1zaW5nbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoZCA9PiBuZXdYU2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSlcclxuICAgICAgICAgICAgICAgICAgICAueShkID0+IG5ld1lTY2FsZShkLnRpbWUpKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgQU81IGxpbmUgYWxpZ25zIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvNScpXHJcbiAgICAgICAgICAgICAgICAuZGF0dW0oYW81Lm1hcCgodmFsLCBpKSA9PiAoeyB0aW1lc3RhbXA6IHRpbWVzdGFtcHNbaV0sIHZhbHVlOiB2YWwgfSkpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoZCA9PiBkLnZhbHVlICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC54KGQgPT4gbmV3WFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnkoZCA9PiBuZXdZU2NhbGUoZC52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8g4pyFIEVuc3VyZSBBTzEyIGxpbmUgYWxpZ25zIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvMTInKVxyXG4gICAgICAgICAgICAgICAgLmRhdHVtKGFvMTIubWFwKCh2YWwsIGkpID0+ICh7IHRpbWVzdGFtcDogdGltZXN0YW1wc1tpXSwgdmFsdWU6IHZhbCB9KSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZChkID0+IGQudmFsdWUgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgLngoZCA9PiBuZXdYU2NhbGUobmV3IERhdGUoZC50aW1lc3RhbXApKSlcclxuICAgICAgICAgICAgICAgICAgICAueShkID0+IG5ld1lTY2FsZShkLnZhbHVlKSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmRhdHVtKHByb2Nlc3NlZERhdGEpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lLXNpbmdsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmx1ZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMilcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5saW5lKClcclxuICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAgICAgICAgIC54KGQgPT4geFNjYWxlKG5ldyBEYXRlKGQudGltZXN0YW1wKSkpXHJcbiAgICAgICAgICAgICAgICAueShkID0+IHlTY2FsZShkLnRpbWUpKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGluZS1hbzUnKVxyXG4gICAgICAgICAgICAuZGF0YShbYW81XSkgIC8vIOKchSBVc2UgLmRhdGEoW10pIGluc3RlYWQgb2YgLmRhdHVtKClcclxuICAgICAgICAgICAgLmpvaW4oXCJwYXRoXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lLWFvNScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnZ3JlZW4nKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAuZGVmaW5lZCgoXywgaSkgPT4gaSA+PSA0ICYmIGFvNVtpXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIC54KChfLCBpKSA9PiB4U2NhbGUobmV3IERhdGUodGltZXN0YW1wc1tpXSkpKSAgLy8g4pyFIFVzZSB0aW1lc3RhbXBzXHJcbiAgICAgICAgICAgICAgICAueSgoXywgaSkgPT4geVNjYWxlKGFvNVtpXSkpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5saW5lLWFvMTInKVxyXG4gICAgICAgICAgICAuZGF0YShbYW8xMl0pICAvLyDinIUgVXNlIC5kYXRhKFtdKSBpbnN0ZWFkIG9mIC5kYXR1bSgpXHJcbiAgICAgICAgICAgIC5qb2luKFwicGF0aFwiKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZS1hbzEyJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdyZWQnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgZDMubGluZSgpXHJcbiAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVNb25vdG9uZVgpXHJcbiAgICAgICAgICAgICAgICAuZGVmaW5lZCgoXywgaSkgPT4gaSA+PSAxMSAmJiBhbzEyW2ldICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgLngoKF8sIGkpID0+IHhTY2FsZShuZXcgRGF0ZSh0aW1lc3RhbXBzW2ldKSkpICAvLyDinIUgVXNlIHRpbWVzdGFtcHNcclxuICAgICAgICAgICAgICAgIC55KChfLCBpKSA9PiB5U2NhbGUoYW8xMltpXSkpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBkMy5zZWxlY3QoY29udGFpbmVyUmVmLmN1cnJlbnQpLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Fic29sdXRlIGJnLXdoaXRlIHAtMiBib3JkZXIgcm91bmRlZCBzaGFkb3cgdGV4dC1zbScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKGV2ZW50LCB0aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgaWYgKCF0aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBzaG93VG9vbHRpcCBjYWxsZWQgd2l0aCBpbnZhbGlkIHRpbWVzdGFtcDpcIiwgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmluZCBhbGwgZGF0YSBwb2ludHMgd2l0aCB0aGUgc2FtZSB0aW1lc3RhbXBcclxuICAgICAgICAgICAgY29uc3Qgc2luZ2xlRGF0YSA9IHByb2Nlc3NlZERhdGEuZmluZChkID0+IGQudGltZXN0YW1wLmdldFRpbWUoKSA9PT0gdGltZXN0YW1wLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvNURhdGFQb2ludCA9IGFvNURhdGEuZmluZChkID0+IGQudGltZXN0YW1wLmdldFRpbWUoKSA9PT0gdGltZXN0YW1wLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvMTJEYXRhUG9pbnQgPSBhbzEyRGF0YS5maW5kKGQgPT4gZC50aW1lc3RhbXAuZ2V0VGltZSgpID09PSB0aW1lc3RhbXAuZ2V0VGltZSgpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVRpbWUgPSBzaW5nbGVEYXRhID8gc2luZ2xlRGF0YS50aW1lLnRvRml4ZWQoMikgOiBcIi1cIjtcclxuICAgICAgICAgICAgY29uc3QgYW81VGltZSA9IGFvNURhdGFQb2ludCA/IGFvNURhdGFQb2ludC52YWx1ZS50b0ZpeGVkKDIpIDogXCItXCI7XHJcbiAgICAgICAgICAgIGNvbnN0IGFvMTJUaW1lID0gYW8xMkRhdGFQb2ludCA/IGFvMTJEYXRhUG9pbnQudmFsdWUudG9GaXhlZCgyKSA6IFwiLVwiO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfn6IgU2hvd2luZyB0b29sdGlwIGZvciB0aW1lc3RhbXAgJHt0aW1lc3RhbXB9OiBTaW5nbGU9JHtzaW5nbGVUaW1lfSwgQU81PSR7YW81VGltZX0sIEFPMTI9JHthbzEyVGltZX1gKTtcclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuaHRtbChgXHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+U2luZ2xlOjwvc3Ryb25nPiAke3NpbmdsZVRpbWV9czwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPkFPNTo8L3N0cm9uZz4gJHthbzVUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXY+PHN0cm9uZz5BTzEyOjwvc3Ryb25nPiAke2FvMTJUaW1lfXM8L2Rpdj5cclxuICAgICAgICAgICAgYClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnZml4ZWQnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgJ3doaXRlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncGFkZGluZycsICc2cHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXInLCAnMXB4IHNvbGlkICNjY2MnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXItcmFkaXVzJywgJzVweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JveC1zaGFkb3cnLCAnMnB4IDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxMnB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3otaW5kZXgnLCAnMTAwMCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgLTUwJSknKTtcclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ2xlZnQnLCBgJHtldmVudC5wYWdlWCArIDEyfXB4YCkuc3R5bGUoJ3RvcCcsIGAke2V2ZW50LnBhZ2VZfXB4YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcclxuICAgICAgICAgICAgdG9vbHRpcC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB1cGRhdGVQbG90KHhTY2FsZSwgeVNjYWxlKTsgIC8vIOKchSBGb3JjZSByZW5kZXIgYWZ0ZXIgaW5pdGlhbGl6YXRpb25cclxuICAgICAgICB9LCAxMDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRQb2ludHMoZGF0YSwgY29sb3IsIGNsYXNzTmFtZSwgdmFsdWVBY2Nlc3NvciwgbWluSW5kZXgsIGxhYmVsKSB7XHJcbiAgICAgICAgICAgIC8vIOKchSBFbnN1cmUgdGhhdCB3ZSBjb3JyZWN0bHkgaXRlcmF0ZSBvdmVyIHRoZSBmdWxsIGRhdGFzZXRcclxuICAgICAgICAgICAgY29uc3QgdmFsaWRQb2ludHMgPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAubWFwKCh2YWwsIGkpID0+ICh7IHg6IGksIHk6IHZhbHVlQWNjZXNzb3IoaSkgfSkpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGQgPT4gZC55ICE9PSBudWxsICYmIGQueCA+PSBtaW5JbmRleCk7IC8vIOKchSBSZW1vdmVkIHggPCB0aW1lcy5sZW5ndGggY29uc3RyYWludFxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxcbvCfn6IgQWRkaW5nIFBvaW50cyBmb3IgJHtsYWJlbH0gfCBDbGFzczogJHtjbGFzc05hbWV9IHwgTWluSW5kZXg6ICR7bWluSW5kZXh9YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJQgVmFsaWQgUG9pbnRzIENvdW50OiAke3ZhbGlkUG9pbnRzLmxlbmd0aH1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk40gRmlyc3QgNSBQb2ludHM6YCwgdmFsaWRQb2ludHMuc2xpY2UoMCwgNSkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TjSBMYXN0IDUgUG9pbnRzOmAsIHZhbGlkUG9pbnRzLnNsaWNlKC01KSk7XHJcblxyXG4gICAgICAgICAgICB2YWxpZFBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICAgICAgYPCflLUgJHtsYWJlbH0gUG9pbnQgJHtpICsgbWluSW5kZXh9OiBSYXdYPSR7cG9pbnQueH0sIFNjYWxlZFg9JHt4U2NhbGUocG9pbnQueCl9LCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUmF3WT0ke3BvaW50LnkudG9GaXhlZCgzKX0sIFNjYWxlZFk9JHt5U2NhbGUocG9pbnQueSkudG9GaXhlZCgyKX1gXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSBkYXRhIGJpbmRpbmcgaXMgZG9uZSBjb3JyZWN0bHlcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbChgLiR7Y2xhc3NOYW1lfWApXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh2YWxpZFBvaW50cywgZCA9PiBkLngpIC8vIEVuc3VyZSB1bmlxdWUga2V5IGJpbmRpbmdcclxuICAgICAgICAgICAgICAgIC5qb2luKFwiY2lyY2xlXCIpIC8vIEVuc3VyZSBwcm9wZXIgYmluZGluZ1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYHBvaW50ICR7Y2xhc3NOYW1lfWApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IHhTY2FsZShkLngpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC55KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY29sb3IpXHJcbiAgICAgICAgfVxyXG5cclxuLy8g4pyFIEVuc3VyZSBBTzUgJiBBTzEyIHBvaW50cyBhcmUgZnVsbHkgYWRkZWQgYmVmb3JlIHVwZGF0aW5nXHJcbiAgICAgICAgYWRkUG9pbnRzKHRpbWVzLCAnYmx1ZScsICdwb2ludC1zaW5nbGUnLCAoaSkgPT4gdGltZXNbaV0sIDAsIFwiU2luZ2xlXCIpO1xyXG4gICAgICAgIGFkZFBvaW50cyhhbzUsICdncmVlbicsICdwb2ludC1hbzUnLCAoaSkgPT4gYW81W2ldLCA0LCBcIkFPNVwiKTtcclxuICAgICAgICBhZGRQb2ludHMoYW8xMiwgJ3JlZCcsICdwb2ludC1hbzEyJywgKGkpID0+IGFvMTJbaV0sIDExLCBcIkFPMTJcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzID0gZDMuc2VsZWN0KGNvbnRhaW5lclJlZi5jdXJyZW50KS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdhYnNvbHV0ZSB0b3AtMiByaWdodC0yIGJnLXdoaXRlIHAtMiByb3VuZGVkIHNoYWRvdyBmbGV4IHNwYWNlLXgtNCcpOyAvLyBIb3Jpem9udGFsIGxheW91dCB3aXRoIHNwYWNpbmdcclxuXHJcbi8vIFByZXZpb3VzIENsdXN0ZXIgQnV0dG9uXHJcbiAgICAgICAgY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxyXG4gICAgICAgICAgICAuaHRtbCgnPGltZyBzcmM9XCIvZGF0YVZpcy1wcmV2aW91cy5zdmdcIiBhbHQ9XCJQcmV2aW91c1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiPicpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luJywgJzVweCcpIC8vIEFkZHMgc3BhY2luZyBhcm91bmQgdGhlIGJ1dHRvblxyXG4gICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCBjbHVzdGVycy5sZW5ndGggPT09IDAgfHwgY3VycmVudENsdXN0ZXJJbmRleCA9PT0gMCA/ICdkaXNhYmxlZCcgOiBudWxsKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgcHJldkNsdXN0ZXIpO1xyXG5cclxuLy8gTmV4dCBDbHVzdGVyIEJ1dHRvblxyXG4gICAgICAgIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcclxuICAgICAgICAgICAgLmh0bWwoJzxpbWcgc3JjPVwiL2RhdGFWaXMtbmV4dC5zdmdcIiBhbHQ9XCJOZXh0XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCI+JylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4nLCAnNXB4JylcclxuICAgICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgY2x1c3RlcnMubGVuZ3RoID09PSAwIHx8IGN1cnJlbnRDbHVzdGVySW5kZXggPj0gY2x1c3RlcnMubGVuZ3RoIC0gMSA/ICdkaXNhYmxlZCcgOiBudWxsKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgbmV4dENsdXN0ZXIpO1xyXG5cclxuLy8gQXV0b3NjYWxlIEJ1dHRvblxyXG4gICAgICAgIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcclxuICAgICAgICAgICAgLmh0bWwoJzxpbWcgc3JjPVwiL2RhdGFWaXMtcmVzaXplLXNjYWxpbmcuc3ZnXCIgYWx0PVwiQXV0b3NjYWxlXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCI+JylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4nLCAnNXB4JylcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGF1dG9zY2FsZSk7XHJcblxyXG4vLyBTd2l0Y2ggdG8gVGltZSBWaWV3IEJ1dHRvblxyXG4gICAgICAgIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcclxuICAgICAgICAgICAgLmh0bWwoJzxpbWcgc3JjPVwiL2RhdGFWaXMtc3dpdGNoLnN2Z1wiIGFsdD1cIlN3aXRjaCBWaWV3XCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCI+JylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4nLCAnNXB4JylcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHNldFNob3dJbmRleFZpZXcodHJ1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGF1dG9zY2FsZSgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gQXV0b3NjYWxlIHRyaWdnZXJlZC4uLlwiKTtcclxuXHJcbiAgICAgICAgaWYgKCFjbHVzdGVycyB8fCBjbHVzdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIGNsdXN0ZXJzIGF2YWlsYWJsZSBmb3IgYXV0b3NjYWxlIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OMIEF1dG9zY2FsaW5nIHRvIGZpcnN0IGNsdXN0ZXIuLi5cIik7XHJcbiAgICAgICAgc2V0Q3VycmVudENsdXN0ZXJJbmRleCgwKTtcclxuXHJcbiAgICAgICAgY29uc3QgZmlyc3RDbHVzdGVyID0gY2x1c3RlcnNbMF07XHJcblxyXG4gICAgICAgIGlmICghZmlyc3RDbHVzdGVyIHx8IGZpcnN0Q2x1c3Rlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIEZpcnN0IGNsdXN0ZXIgaXMgZW1wdHksIGNhbm5vdCBhdXRvc2NhbGUhXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBuZXdEb21haW4gPSBbXHJcbiAgICAgICAgICAgIG5ldyBEYXRlKGZpcnN0Q2x1c3RlclswXS50aW1lc3RhbXApLFxyXG4gICAgICAgICAgICBuZXcgRGF0ZShmaXJzdENsdXN0ZXIuc2xpY2UoLTEpWzBdLnRpbWVzdGFtcClcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBTZXR0aW5nIGF1dG9zY2FsZSBYLURvbWFpbiB0bzpcIiwgbmV3RG9tYWluKTtcclxuICAgICAgICBzZXRYRG9tYWluKG5ld0RvbWFpbik7XHJcbiAgICAgICAgeERvbWFpblJlZi5jdXJyZW50ID0gbmV3RG9tYWluO1xyXG5cclxuICAgICAgICAvLyDinIUgRm9yY2UgUmVhY3QgdG8gdXBkYXRlIFVJIHN0YXRlXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldENsdXN0ZXJzKFsuLi5jbHVzdGVyc10pOyAvLyBGb3JjZSByZS1ldmFsdWF0aW9uIG9mIGNsdXN0ZXJzIHN0YXRlXHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmV4dENsdXN0ZXIoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLinqHvuI8gTmV4dCBjbHVzdGVyIGNsaWNrZWQuLi5cIik7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRDbHVzdGVySW5kZXggPCBjbHVzdGVycy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGN1cnJlbnRDbHVzdGVySW5kZXggKyAxO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4wgTW92aW5nIHRvIG5leHQgY2x1c3RlcjpcIiwgbmV4dEluZGV4KTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudENsdXN0ZXJJbmRleChuZXh0SW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdEb21haW4gPSBbXHJcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShjbHVzdGVyc1tuZXh0SW5kZXhdWzBdLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShjbHVzdGVyc1tuZXh0SW5kZXhdLnNsaWNlKC0xKVswXS50aW1lc3RhbXApXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICBzZXRYRG9tYWluKG5ld0RvbWFpbik7XHJcbiAgICAgICAgICAgIHhEb21haW5SZWYuY3VycmVudCA9IG5ld0RvbWFpbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gbmV4dCBjbHVzdGVyIGF2YWlsYWJsZSFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByZXZDbHVzdGVyKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4qyF77iPIFByZXZpb3VzIGNsdXN0ZXIgY2xpY2tlZC4uLlwiKTtcclxuICAgICAgICBpZiAoY3VycmVudENsdXN0ZXJJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldkluZGV4ID0gY3VycmVudENsdXN0ZXJJbmRleCAtIDE7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjCBNb3ZpbmcgdG8gcHJldmlvdXMgY2x1c3RlcjpcIiwgcHJldkluZGV4KTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudENsdXN0ZXJJbmRleChwcmV2SW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdEb21haW4gPSBbXHJcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShjbHVzdGVyc1twcmV2SW5kZXhdWzBdLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShjbHVzdGVyc1twcmV2SW5kZXhdLnNsaWNlKC0xKVswXS50aW1lc3RhbXApXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICBzZXRYRG9tYWluKG5ld0RvbWFpbik7XHJcbiAgICAgICAgICAgIHhEb21haW5SZWYuY3VycmVudCA9IG5ld0RvbWFpbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gcHJldmlvdXMgY2x1c3RlciBhdmFpbGFibGUhXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm4gKFxyXG4gICAgLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC1bY2FsYygxMDB2aC0xMDBweCldIGJnLXdoaXRlIHJlbGF0aXZlXCI+XHJcbiAgICAvLyAgICAgICAgIHsvKiDinIUgQ2hhcnQgY29udGFpbmVyICovfVxyXG4gICAgLy8gICAgICAgICA8ZGl2IHJlZj17Y29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCI+PC9kaXY+XHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAgICB7Lyog4pyFIENvbnRyb2xzIFNlY3Rpb24gKi99XHJcbiAgICAvLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTIgcmlnaHQtMiBiZy13aGl0ZSBwLTIgcm91bmRlZCBzaGFkb3cgZmxleCBzcGFjZS14LTJcIj5cclxuICAgIC8vICAgICAgICAgICAgIDxidXR0b25cclxuICAgIC8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctZ3JheS0yMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTMwMFwiXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2NsdXN0ZXJzLmxlbmd0aCA9PT0gMCB8fCBjdXJyZW50Q2x1c3RlckluZGV4ID09PSAwfVxyXG4gICAgLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHByZXZDbHVzdGVyKCl9XHJcbiAgICAvLyAgICAgICAgICAgICA+XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgUHJldmlvdXMgQ2x1c3RlclxyXG4gICAgLy8gICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgLy8gICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmF5LTIwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktMzAwXCJcclxuICAgIC8vICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y2x1c3RlcnMubGVuZ3RoID09PSAwIHx8IGN1cnJlbnRDbHVzdGVySW5kZXggPj0gY2x1c3RlcnMubGVuZ3RoIC0gMX1cclxuICAgIC8vICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBuZXh0Q2x1c3RlcigpfVxyXG4gICAgLy8gICAgICAgICAgICAgPlxyXG4gICAgLy8gICAgICAgICAgICAgICAgIE5leHQgQ2x1c3RlclxyXG4gICAgLy8gICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgLy8gICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmF5LTIwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktMzAwXCJcclxuICAgIC8vICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBhdXRvc2NhbGUoKX1cclxuICAgIC8vICAgICAgICAgICAgID5cclxuICAgIC8vICAgICAgICAgICAgICAgICBBdXRvc2NhbGVcclxuICAgIC8vICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgLy9cclxuICAgIC8vICAgICAgICAgICAgIHsvKiDinIUgU3dpdGNoIGJ1dHRvbiB0byBnbyB0byBUcmVuZEFuYVRpbWUuanMgKi99XHJcbiAgICAvLyAgICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1ibHVlLTcwMFwiXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2hvd0luZGV4Vmlldyh0cnVlKX1cclxuICAgIC8vICAgICAgICAgICAgID5cclxuICAgIC8vICAgICAgICAgICAgICAgICBTd2l0Y2ggdG8gVGltZSBWaWV3XHJcbiAgICAvLyAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgIC8vICAgICAgICAgPC9kaXY+XHJcbiAgICAvLyAgICAgPC9kaXY+XHJcbiAgICAvLyApO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICByZWY9e2NvbnRhaW5lclJlZn1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC1bY2FsYygxMDB2aC0xMDBweCldIGJnLXdoaXRlIHJlbGF0aXZlXCJcclxuICAgICAgICA+PC9kaXY+XHJcbiAgICApO1xyXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiVHJlbmRBbmFJbmRleCIsImQzIiwiU29sdmVUaW1lVHJlbmQiLCJzb2x2ZXMiLCJjb250YWluZXJSZWYiLCJjdXJyZW50Q2x1c3RlckluZGV4Iiwic2V0Q3VycmVudENsdXN0ZXJJbmRleCIsImNsdXN0ZXJzIiwic2V0Q2x1c3RlcnMiLCJ4RG9tYWluIiwic2V0WERvbWFpbiIsInhEb21haW5SZWYiLCJzaG93SW5kZXhWaWV3Iiwic2V0U2hvd0luZGV4VmlldyIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJ3YXJuIiwiY29udGFpbmVyIiwiY3VycmVudCIsImRyYXdTb2x2ZVRpbWVUcmVuZCIsIkFycmF5IiwiaXNBcnJheSIsImRldGVjdGVkQ2x1c3RlcnMiLCJmaW5kQ2x1c3RlcnMiLCJmaXJzdENsdXN0ZXIiLCJuZXdEb21haW4iLCJEYXRlIiwidGltZXN0YW1wIiwic2xpY2UiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlUmVzaXplIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInByZXZDbHVzdGVySW5kZXgiLCJwcmV2WERvbWFpbiIsInNldFRpbWVvdXQiLCJkYXRhIiwiY3VycmVudENsdXN0ZXIiLCJpIiwidW5pcXVlWFZhbHVlcyIsIlNldCIsIm1hcCIsImQiLCJzaXplIiwicHVzaCIsImNvbXB1dGVSb2xsaW5nQXZlcmFnZSIsIndpbmRvd1NpemUiLCJfIiwiYXJyIiwic3Vic2V0IiwicmVkdWNlIiwic3VtIiwidmFsIiwic2VsZWN0Iiwic2VsZWN0QWxsIiwicmVtb3ZlIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsInN2ZyIsImFwcGVuZCIsImF0dHIiLCJwcm9jZXNzZWREYXRhIiwic29sdmUiLCJ0aW1lIiwiZmlsdGVyIiwidGltZXN0YW1wcyIsInRpbWVzIiwiY2x1c3RlclN0YXJ0SW5kZXgiLCJjbHVzdGVyRW5kSW5kZXgiLCJpbml0aWFsWERvbWFpbiIsImFvNSIsImFvMTIiLCJhbzVEYXRhIiwidmFsdWUiLCJhbzEyRGF0YSIsInhTY2FsZSIsInNjYWxlVGltZSIsImRvbWFpbiIsInJhbmdlIiwieVNjYWxlIiwic2NhbGVMaW5lYXIiLCJtYXgiLCJtaW4iLCJ4QXhpcyIsImNhbGwiLCJheGlzQm90dG9tIiwidGlja0Zvcm1hdCIsInRpbWVGb3JtYXQiLCJsYXN0RGF0ZSIsImVhY2giLCJub2RlcyIsImN1cnJlbnRUZXh0IiwiZGF0ZVN0ciIsInRleHQiLCJ5QXhpcyIsImF4aXNMZWZ0IiwiZ3JpZEdyb3VwIiwiZHJhd0dyaWQiLCJ0aWNrcyIsImVudGVyIiwiem9vbSIsIm9uIiwiZXZlbnQiLCJ0cmFuc2Zvcm0iLCJuZXdYU2NhbGUiLCJyZXNjYWxlWCIsIm5ld1lTY2FsZSIsInJlc2NhbGVZIiwidXBkYXRlUGxvdCIsImxhc3Rab29tRGF0ZSIsImxlZ2VuZCIsImxlZ2VuZEl0ZW1zIiwiY29sb3IiLCJsYWJlbCIsImZvckVhY2giLCJpdGVtIiwiYXV0b3NjYWxlIiwiYW81U2VsZWN0aW9uIiwiam9pbiIsInNob3dUb29sdGlwIiwidG9vbHRpcCIsInN0eWxlIiwiYW8xMlNlbGVjdGlvbiIsIngiLCJ5IiwibGluZSIsImN1cnZlIiwiY3VydmVNb25vdG9uZVgiLCJkYXR1bSIsImRlZmluZWQiLCJzaW5nbGVEYXRhIiwiZmluZCIsImdldFRpbWUiLCJhbzVEYXRhUG9pbnQiLCJhbzEyRGF0YVBvaW50Iiwic2luZ2xlVGltZSIsInRvRml4ZWQiLCJhbzVUaW1lIiwiYW8xMlRpbWUiLCJodG1sIiwicGFnZVgiLCJwYWdlWSIsImhpZGVUb29sdGlwIiwiYWRkUG9pbnRzIiwiY2xhc3NOYW1lIiwidmFsdWVBY2Nlc3NvciIsIm1pbkluZGV4IiwidmFsaWRQb2ludHMiLCJwb2ludCIsImNvbnRyb2xzIiwicHJldkNsdXN0ZXIiLCJuZXh0Q2x1c3RlciIsIm5leHRJbmRleCIsInByZXZJbmRleCIsImRpdiIsInJlZiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/dataVis/page.js":
/*!*********************************!*\
  !*** ./src/app/dataVis/page.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataDashboard)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _globals_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../globals.css */ \"(app-pages-browser)/./src/app/globals.css\");\n/* harmony import */ var _TrendAnaTime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TrendAnaTime */ \"(app-pages-browser)/./src/app/dataVis/TrendAnaTime.js\");\n/* harmony import */ var _TimeDis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TimeDis */ \"(app-pages-browser)/./src/app/dataVis/TimeDis.js\");\n/* harmony import */ var _SolveDen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SolveDen */ \"(app-pages-browser)/./src/app/dataVis/SolveDen.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_TrendAnaTime__WEBPACK_IMPORTED_MODULE_4__, _TimeDis__WEBPACK_IMPORTED_MODULE_5__, _SolveDen__WEBPACK_IMPORTED_MODULE_6__]);\n([_TrendAnaTime__WEBPACK_IMPORTED_MODULE_4__, _TimeDis__WEBPACK_IMPORTED_MODULE_5__, _SolveDen__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nconst d3 = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_d3_src_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! d3 */ \"(app-pages-browser)/./node_modules/d3/src/index.js\"));\n\n\n\n\n\n// import SessionHea from './SessionHea';\nfunction DataDashboard() {\n    _s();\n    const [solves, setSolves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeTab, setActiveTab] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('chart');\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DataDashboard.useEffect\": ()=>{\n            fetch('/api/data').then({\n                \"DataDashboard.useEffect\": (response)=>response.json()\n            }[\"DataDashboard.useEffect\"]).then({\n                \"DataDashboard.useEffect\": (data)=>setSolves(data.solves)\n            }[\"DataDashboard.useEffect\"]).catch({\n                \"DataDashboard.useEffect\": (error)=>console.error('Error fetching data:', error)\n            }[\"DataDashboard.useEffect\"]);\n        }\n    }[\"DataDashboard.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"bg-gray-100 max-h-screen max-w-screen\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \"bg-blue-600 text-white p-4 shadow-md flex justify-between\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                        href: \"/\",\n                        children: \"Kermit Timer\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                        lineNumber: 26,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                        href: \"/timer\",\n                        children: \"Back to Timer\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                        lineNumber: 27,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                lineNumber: 25,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"bg-blue-500 text-white flex justify-center space-x-6 p-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 \".concat(activeTab === 'chart' ? 'border-b-2 border-white font-bold' : ''),\n                        onClick: ()=>setActiveTab('chart'),\n                        children: \"Trend Analysis\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                        lineNumber: 32,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 \".concat(activeTab === 'histogram' ? 'border-b-2 border-white font-bold' : ''),\n                        onClick: ()=>setActiveTab('histogram'),\n                        children: \"Time Distribution\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                        lineNumber: 38,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 \".concat(activeTab === 'density' ? 'border-b-2 border-white font-bold' : ''),\n                        onClick: ()=>setActiveTab('density'),\n                        children: \"Solve Density\"\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                        lineNumber: 44,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                lineNumber: 31,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-grow w-full h-full flex\",\n                children: [\n                    activeTab === 'chart' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TrendAnaTime__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        solves: solves\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                        lineNumber: 60,\n                        columnNumber: 43\n                    }, this),\n                    activeTab === 'histogram' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TimeDis__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                        solves: solves\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                        lineNumber: 61,\n                        columnNumber: 47\n                    }, this),\n                    activeTab === 'density' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_SolveDen__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                        solves: solves\n                    }, void 0, false, {\n                        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                        lineNumber: 62,\n                        columnNumber: 45\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n                lineNumber: 59,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\Wpi\\\\Regularly\\\\Courses\\\\Sr\\\\2024_C_Term\\\\CS4241\\\\HW\\\\final-project-kermit-the-frog\\\\src\\\\app\\\\dataVis\\\\page.js\",\n        lineNumber: 24,\n        columnNumber: 9\n    }, this);\n}\n_s(DataDashboard, \"12/bzK0dDuT0vx3DBvqR8u9Ej10=\");\n_c = DataDashboard;\nvar _c;\n$RefreshReg$(_c, \"DataDashboard\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZGF0YVZpcy9wYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUU0QztBQUM1QyxNQUFNRSxLQUFLLE1BQU0sNE1BQVk7QUFDQTtBQUNIO0FBQ1k7QUFDTjtBQUNFO0FBQ2xDLHlDQUF5QztBQUUxQixTQUFTSzs7SUFDcEIsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdSLCtDQUFRQSxDQUFDLEVBQUU7SUFDdkMsTUFBTSxDQUFDUyxXQUFXQyxhQUFhLEdBQUdWLCtDQUFRQSxDQUFDO0lBRTNDRCxnREFBU0E7bUNBQUM7WUFDTlksTUFBTSxhQUNEQyxJQUFJOzJDQUFDLENBQUNDLFdBQWFBLFNBQVNDLElBQUk7MENBQ2hDRixJQUFJOzJDQUFDLENBQUNHLE9BQVNQLFVBQVVPLEtBQUtSLE1BQU07MENBQ3BDUyxLQUFLOzJDQUFDLENBQUNDLFFBQVVDLFFBQVFELEtBQUssQ0FBQyx3QkFBd0JBOztRQUNoRTtrQ0FBRyxFQUFFO0lBRUwscUJBQ0ksOERBQUNFO1FBQUlDLFdBQVU7OzBCQUNYLDhEQUFDQztnQkFBSUQsV0FBVTs7a0NBQ1gsOERBQUNsQixrREFBSUE7d0JBQUNvQixNQUFLO2tDQUFJOzs7Ozs7a0NBQ2YsOERBQUNwQixrREFBSUE7d0JBQUNvQixNQUFLO2tDQUFTOzs7Ozs7Ozs7Ozs7MEJBSXhCLDhEQUFDSDtnQkFBSUMsV0FBVTs7a0NBQ1gsOERBQUNHO3dCQUNHSCxXQUFXLGFBQThFLE9BQWpFWCxjQUFjLFVBQVUsc0NBQXNDO3dCQUN0RmUsU0FBUyxJQUFNZCxhQUFhO2tDQUMvQjs7Ozs7O2tDQUdELDhEQUFDYTt3QkFDR0gsV0FBVyxhQUFrRixPQUFyRVgsY0FBYyxjQUFjLHNDQUFzQzt3QkFDMUZlLFNBQVMsSUFBTWQsYUFBYTtrQ0FDL0I7Ozs7OztrQ0FHRCw4REFBQ2E7d0JBQ0dILFdBQVcsYUFBZ0YsT0FBbkVYLGNBQWMsWUFBWSxzQ0FBc0M7d0JBQ3hGZSxTQUFTLElBQU1kLGFBQWE7a0NBQy9COzs7Ozs7Ozs7Ozs7MEJBWUwsOERBQUNTO2dCQUFJQyxXQUFVOztvQkFDVlgsY0FBYyx5QkFBVyw4REFBQ04scURBQVFBO3dCQUFDSSxRQUFRQTs7Ozs7O29CQUMzQ0UsY0FBYyw2QkFBZSw4REFBQ0wsZ0RBQU9BO3dCQUFDRyxRQUFRQTs7Ozs7O29CQUM5Q0UsY0FBYywyQkFBYSw4REFBQ0osaURBQVFBO3dCQUFDRSxRQUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSzlEO0dBdkR3QkQ7S0FBQUEiLCJzb3VyY2VzIjpbIkU6XFxXcGlcXFJlZ3VsYXJseVxcQ291cnNlc1xcU3JcXDIwMjRfQ19UZXJtXFxDUzQyNDFcXEhXXFxmaW5hbC1wcm9qZWN0LWtlcm1pdC10aGUtZnJvZ1xcc3JjXFxhcHBcXGRhdGFWaXNcXHBhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuY29uc3QgZDMgPSBhd2FpdCBpbXBvcnQoJ2QzJyk7XHJcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluayc7XHJcbmltcG9ydCAnLi8uLi9nbG9iYWxzLmNzcyc7XHJcbmltcG9ydCBUcmVuZEFuYSBmcm9tICcuL1RyZW5kQW5hVGltZSc7XHJcbmltcG9ydCBUaW1lRGlzIGZyb20gJy4vVGltZURpcyc7XHJcbmltcG9ydCBTb2x2ZURlbiBmcm9tICcuL1NvbHZlRGVuJztcclxuLy8gaW1wb3J0IFNlc3Npb25IZWEgZnJvbSAnLi9TZXNzaW9uSGVhJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhdGFEYXNoYm9hcmQoKSB7XHJcbiAgICBjb25zdCBbc29sdmVzLCBzZXRTb2x2ZXNdID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgW2FjdGl2ZVRhYiwgc2V0QWN0aXZlVGFiXSA9IHVzZVN0YXRlKCdjaGFydCcpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgZmV0Y2goJy9hcGkvZGF0YScpXHJcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxyXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4gc2V0U29sdmVzKGRhdGEuc29sdmVzKSlcclxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YTonLCBlcnJvcikpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmF5LTEwMCBtYXgtaC1zY3JlZW4gbWF4LXctc2NyZWVuXCI+XHJcbiAgICAgICAgICAgIDxuYXYgY2xhc3NOYW1lPVwiYmctYmx1ZS02MDAgdGV4dC13aGl0ZSBwLTQgc2hhZG93LW1kIGZsZXgganVzdGlmeS1iZXR3ZWVuXCI+XHJcbiAgICAgICAgICAgICAgICA8TGluayBocmVmPVwiL1wiPktlcm1pdCBUaW1lcjwvTGluaz5cclxuICAgICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvdGltZXJcIj5CYWNrIHRvIFRpbWVyPC9MaW5rPlxyXG4gICAgICAgICAgICA8L25hdj5cclxuXHJcbiAgICAgICAgICAgIHsvKiBOYXZpZ2F0aW9uIFRhYnMgKi99XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBmbGV4IGp1c3RpZnktY2VudGVyIHNwYWNlLXgtNiBwLTJcIj5cclxuICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BweC00IHB5LTIgJHthY3RpdmVUYWIgPT09ICdjaGFydCcgPyAnYm9yZGVyLWItMiBib3JkZXItd2hpdGUgZm9udC1ib2xkJyA6ICcnfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKCdjaGFydCcpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIFRyZW5kIEFuYWx5c2lzXHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BweC00IHB5LTIgJHthY3RpdmVUYWIgPT09ICdoaXN0b2dyYW0nID8gJ2JvcmRlci1iLTIgYm9yZGVyLXdoaXRlIGZvbnQtYm9sZCcgOiAnJ31gfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEFjdGl2ZVRhYignaGlzdG9ncmFtJyl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgVGltZSBEaXN0cmlidXRpb25cclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHB4LTQgcHktMiAke2FjdGl2ZVRhYiA9PT0gJ2RlbnNpdHknID8gJ2JvcmRlci1iLTIgYm9yZGVyLXdoaXRlIGZvbnQtYm9sZCcgOiAnJ31gfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEFjdGl2ZVRhYignZGVuc2l0eScpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIFNvbHZlIERlbnNpdHlcclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgey8qPGJ1dHRvbiovfVxyXG4gICAgICAgICAgICAgICAgey8qICAgIGNsYXNzTmFtZT17YHB4LTQgcHktMiAke2FjdGl2ZVRhYiA9PT0gJ2hlYXRtYXAnID8gJ2JvcmRlci1iLTIgYm9yZGVyLXdoaXRlIGZvbnQtYm9sZCcgOiAnJ31gfSovfVxyXG4gICAgICAgICAgICAgICAgey8qICAgIG9uQ2xpY2s9eygpID0+IHNldEFjdGl2ZVRhYignaGVhdG1hcCcpfSovfVxyXG4gICAgICAgICAgICAgICAgey8qPiovfVxyXG4gICAgICAgICAgICAgICAgey8qICAgIFNlc3Npb24gSGVhdG1hcCovfVxyXG4gICAgICAgICAgICAgICAgey8qPC9idXR0b24+Ki99XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgey8qIER5bmFtaWMgQ29udGVudCBCYXNlZCBvbiBTZWxlY3RlZCBUYWIgKi99XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC1ncm93IHctZnVsbCBoLWZ1bGwgZmxleFwiPlxyXG4gICAgICAgICAgICAgICAge2FjdGl2ZVRhYiA9PT0gJ2NoYXJ0JyAmJiA8VHJlbmRBbmEgc29sdmVzPXtzb2x2ZXN9Lz59XHJcbiAgICAgICAgICAgICAgICB7YWN0aXZlVGFiID09PSAnaGlzdG9ncmFtJyAmJiA8VGltZURpcyBzb2x2ZXM9e3NvbHZlc30gLz59XHJcbiAgICAgICAgICAgICAgICB7YWN0aXZlVGFiID09PSAnZGVuc2l0eScgJiYgPFNvbHZlRGVuIHNvbHZlcz17c29sdmVzfSAvPn1cclxuICAgICAgICAgICAgICAgIHsvKnthY3RpdmVUYWIgPT09ICdoZWF0bWFwJyAmJiA8U2Vzc2lvbkhlYSBzb2x2ZXM9e3NvbHZlc30gLz59Ki99XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJkMyIsIkxpbmsiLCJUcmVuZEFuYSIsIlRpbWVEaXMiLCJTb2x2ZURlbiIsIkRhdGFEYXNoYm9hcmQiLCJzb2x2ZXMiLCJzZXRTb2x2ZXMiLCJhY3RpdmVUYWIiLCJzZXRBY3RpdmVUYWIiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsImpzb24iLCJkYXRhIiwiY2F0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJkaXYiLCJjbGFzc05hbWUiLCJuYXYiLCJocmVmIiwiYnV0dG9uIiwib25DbGljayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/dataVis/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiRTpcXFdwaVxcUmVndWxhcmx5XFxDb3Vyc2VzXFxTclxcMjAyNF9DX1Rlcm1cXENTNDI0MVxcSFdcXGZpbmFsLXByb2plY3Qta2VybWl0LXRoZS1mcm9nXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxyZWFjdFxcY2pzXFxyZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGlzYWJsZWREZXB0aCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gICAgICBkaXNhYmxlZERlcHRoLS07XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7IGNvbmZpZ3VyYWJsZTogITAsIGVudW1lcmFibGU6ICEwLCB3cml0YWJsZTogITAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkxvZyB9KSxcbiAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2SW5mbyB9KSxcbiAgICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2V2FybiB9KSxcbiAgICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkVycm9yIH0pLFxuICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXAgfSksXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZCB9KSxcbiAgICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwRW5kIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgMCA+IGRpc2FibGVkRGVwdGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCBcIlwiO1xuICAgICAgICAgIHN1ZmZpeCA9XG4gICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgICAgICA/IFwiICg8YW5vbnltb3VzPilcIlxuICAgICAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICBpZiAodm9pZCAwICE9PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgcmVlbnRyeSA9ICEwO1xuICAgICAgZnJhbWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZha2UuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgIEZha2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzYW1wbGUuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9XG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICAgICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICk7XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIHsgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIgfVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPVxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgICAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IG5hbWVQcm9wRGVzY3JpcHRvciA9IDA7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yKys7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlcisrO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlciAmJlxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcjtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tLCBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yIHx8IDEgIT09IF9SdW5JblJvb3RGcmFtZSREZXRlcikge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS0sXG4gICAgICAgICAgICAgICAgICAgIDAgPiBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIF9mcmFtZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgKF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZm4uZGlzcGxheU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAocmVlbnRyeSA9ICExKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZpb3VzRGlzcGF0Y2hlciksXG4gICAgICAgICAgcmVlbmFibGVMb2dzKCksXG4gICAgICAgICAgKEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnJhbWUpO1xuICAgICAgfVxuICAgICAgc2FtcGxlTGluZXMgPSAoc2FtcGxlTGluZXMgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgICAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHNhbXBsZUxpbmVzKVxuICAgICAgICA6IFwiXCI7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJiBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc2FtcGxlTGluZXMpO1xuICAgICAgcmV0dXJuIHNhbXBsZUxpbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgICB2YXIgcHJvdG90eXBlID0gdHlwZS5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgISghcHJvdG90eXBlIHx8ICFwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyLCAhMSkpLCB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgcHJvdG90eXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKHByb3RvdHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fFxuICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLmdldE1vZHVsZUlkKSlcbiAgICAgICkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjb25maWcuY2hpbGRyZW47XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPCBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpc1N0YXRpY0NoaWxkcmVuXSwgdHlwZSk7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2UgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgIClcbiAgICAgICAgICBjaGlsZHJlbiArPVxuICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICBudWxsID09PSB0eXBlXG4gICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwibnVsbFwiKVxuICAgICAgICAgIDogaXNBcnJheUltcGwodHlwZSlcbiAgICAgICAgICAgID8gKGlzU3RhdGljQ2hpbGRyZW4gPSBcImFycmF5XCIpXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICAgICAgPyAoKGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICBcIiAvPlwiKSxcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4gPVxuICAgICAgICAgICAgICAgICAgXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikpXG4gICAgICAgICAgICAgIDogKGlzU3RhdGljQ2hpbGRyZW4gPSB0eXBlb2YgdHlwZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIixcbiAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwgY2hpbGRyZW4sIHNlbGYsIHNvdXJjZSwgZ2V0T3duZXIoKSwgbWF5YmVLZXkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgKVxuICAgICAgICBpZiAoaXNBcnJheUltcGwobm9kZSkpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpXG4gICAgICAgICAgbm9kZS5fc3RvcmUgJiYgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAobnVsbCA9PT0gbm9kZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgICAgPyAoaSA9IG51bGwpXG4gICAgICAgICAgICA6ICgoaSA9XG4gICAgICAgICAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBub2RlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgICAgICAgICAgbm9kZVtcIkBAaXRlcmF0b3JcIl0pLFxuICAgICAgICAgICAgICAoaSA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkgPyBpIDogbnVsbCkpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkgJiZcbiAgICAgICAgICAgIGkgIT09IG5vZGUuZW50cmllcyAmJlxuICAgICAgICAgICAgKChpID0gaS5jYWxsKG5vZGUpKSwgaSAhPT0gbm9kZSkpXG4gICAgICAgIClcbiAgICAgICAgICBmb3IgKDsgIShub2RlID0gaS5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgIGlzVmFsaWRFbGVtZW50KG5vZGUudmFsdWUpICYmXG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkobm9kZS52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9iamVjdCAmJlxuICAgICAgICBudWxsICE9PSBvYmplY3QgJiZcbiAgICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKFxuICAgICAgICBlbGVtZW50Ll9zdG9yZSAmJlxuICAgICAgICAhZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgIG51bGwgPT0gZWxlbWVudC5rZXkgJiZcbiAgICAgICAgKChlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSAxKSxcbiAgICAgICAgKHBhcmVudFR5cGUgPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpKSxcbiAgICAgICAgIW93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSlcbiAgICAgICkge1xuICAgICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbcGFyZW50VHlwZV0gPSAhMDtcbiAgICAgICAgdmFyIGNoaWxkT3duZXIgPSBcIlwiO1xuICAgICAgICBlbGVtZW50ICYmXG4gICAgICAgICAgbnVsbCAhPSBlbGVtZW50Ll9vd25lciAmJlxuICAgICAgICAgIGVsZW1lbnQuX293bmVyICE9PSBnZXRPd25lcigpICYmXG4gICAgICAgICAgKChjaGlsZE93bmVyID0gbnVsbCksXG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLnRhZ1xuICAgICAgICAgICAgPyAoY2hpbGRPd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSlcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLm5hbWUgJiZcbiAgICAgICAgICAgICAgKGNoaWxkT3duZXIgPSBlbGVtZW50Ll9vd25lci5uYW1lKSxcbiAgICAgICAgICAoY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY2hpbGRPd25lciArIFwiLlwiKSk7XG4gICAgICAgIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSk7XG4gICAgICAgICAgcHJldkdldEN1cnJlbnRTdGFjayAmJiAoc3RhY2sgKz0gcHJldkdldEN1cnJlbnRTdGFjaygpIHx8IFwiXCIpO1xuICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICBjaGlsZE93bmVyXG4gICAgICAgICk7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICAgICAgdmFyIGluZm8gPSBcIlwiLFxuICAgICAgICBvd25lciA9IGdldE93bmVyKCk7XG4gICAgICBvd25lciAmJlxuICAgICAgICAob3duZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3duZXIudHlwZSkpICYmXG4gICAgICAgIChpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBvd25lciArIFwiYC5cIik7XG4gICAgICBpbmZvIHx8XG4gICAgICAgICgocGFyZW50VHlwZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwYXJlbnRUeXBlKSkgJiZcbiAgICAgICAgICAoaW5mbyA9XG4gICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50VHlwZSArIFwiPi5cIikpO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xuICAgIHZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBkaXNhYmxlZERlcHRoID0gMCxcbiAgICAgIHByZXZMb2csXG4gICAgICBwcmV2SW5mbyxcbiAgICAgIHByZXZXYXJuLFxuICAgICAgcHJldkVycm9yLFxuICAgICAgcHJldkdyb3VwLFxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkLFxuICAgICAgcHJldkdyb3VwRW5kO1xuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICByZWVudHJ5ID0gITE7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgKFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcbiAgICApKCk7XG4gICAgdmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9LFxuICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwodHlwZSwgY29uZmlnLCBtYXliZUtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKTtcbiAgICB9O1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkU6XFxXcGlcXFJlZ3VsYXJseVxcQ291cnNlc1xcU3JcXDIwMjRfQ19UZXJtXFxDUzQyNDFcXEhXXFxmaW5hbC1wcm9qZWN0LWtlcm1pdC10aGUtZnJvZ1xcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGpzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22E%3A%5C%5CWpi%5C%5CRegularly%5C%5CCourses%5C%5CSr%5C%5C2024_C_Term%5C%5CCS4241%5C%5CHW%5C%5Cfinal-project-kermit-the-frog%5C%5Csrc%5C%5Capp%5C%5CdataVis%5C%5Cpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);